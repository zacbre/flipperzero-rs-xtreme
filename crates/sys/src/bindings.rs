/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const API_VERSION: u32 = 2883584;
pub type wint_t = core::ffi::c_int;
pub type __uint_least8_t = core::ffi::c_uchar;
pub type __uint_least16_t = core::ffi::c_ushort;
pub type _off_t = core::ffi::c_long;
pub type _fpos_t = core::ffi::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type __ULong = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: core::ffi::c_int,
    pub _maxwds: core::ffi::c_int,
    pub _sign: core::ffi::c_int,
    pub _wds: core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: core::ffi::c_int,
    pub __tm_min: core::ffi::c_int,
    pub __tm_hour: core::ffi::c_int,
    pub __tm_mday: core::ffi::c_int,
    pub __tm_mon: core::ffi::c_int,
    pub __tm_year: core::ffi::c_int,
    pub __tm_wday: core::ffi::c_int,
    pub __tm_yday: core::ffi::c_int,
    pub __tm_isdst: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut core::ffi::c_uchar,
    pub _size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut core::ffi::c_uchar,
    pub _r: core::ffi::c_int,
    pub _w: core::ffi::c_int,
    pub _flags: core::ffi::c_short,
    pub _file: core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: core::ffi::c_int,
    pub _cookie: *mut core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *mut core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: *const core::ffi::c_char,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut core::ffi::c_void,
            arg3: _fpos_t,
            arg4: core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut core::ffi::c_uchar,
    pub _ur: core::ffi::c_int,
    pub _ubuf: [core::ffi::c_uchar; 3usize],
    pub _nbuf: [core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [core::ffi::c_ushort; 3usize],
    pub _mult: [core::ffi::c_ushort; 3usize],
    pub _add: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: core::ffi::c_int,
    pub _emergency: [core::ffi::c_char; 25usize],
    pub _unspecified_locale_info: core::ffi::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: core::ffi::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: core::ffi::c_int,
    pub _cvtbuf: *mut core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: core::ffi::c_uint,
    pub _strtok_last: *mut core::ffi::c_char,
    pub _asctime_buf: [core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: core::ffi::c_int,
    pub _rand_next: core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [core::ffi::c_char; 8usize],
    pub _signal_buf: [core::ffi::c_char; 24usize],
    pub _getdate_err: core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut core::ffi::c_uchar; 30usize],
    pub _nmalloc: [core::ffi::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn free(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn malloc(arg1: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rand() -> core::ffi::c_int;
}
extern "C" {
    pub fn realloc(arg1: *mut core::ffi::c_void, arg2: core::ffi::c_uint)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn srand(__seed: core::ffi::c_uint);
}
extern "C" {
    pub fn strtof(__n: *const core::ffi::c_char, __end_PTR: *mut *mut core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn itoa(
        arg1: core::ffi::c_int,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn random() -> core::ffi::c_long;
}
extern "C" {
    pub fn strtoull(
        __n: *const core::ffi::c_char,
        __end_PTR: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
extern "C" {
    pub fn strcasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strcasestr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn strnlen(arg1: *const core::ffi::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub static _ctype_: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __assert_func(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        arg4: *const core::ffi::c_char,
    ) -> !;
}
pub type va_list = u32;
pub type FILE = __FILE;
extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Crash system\n\n"]
    pub fn __furi_crash_implementation();
}
extern "C" {
    #[doc = "Halt system\n\n"]
    pub fn __furi_halt_implementation();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __FuriCriticalInfo {
    pub isrm: u32,
    pub from_isr: bool,
    pub kernel_running: bool,
}
#[test]
fn bindgen_test_layout___FuriCriticalInfo() {
    const UNINIT: ::core::mem::MaybeUninit<__FuriCriticalInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__FuriCriticalInfo>(),
        8usize,
        concat!("Size of: ", stringify!(__FuriCriticalInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<__FuriCriticalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(__FuriCriticalInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).isrm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__FuriCriticalInfo),
            "::",
            stringify!(isrm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from_isr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__FuriCriticalInfo),
            "::",
            stringify!(from_isr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kernel_running) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(__FuriCriticalInfo),
            "::",
            stringify!(kernel_running)
        )
    );
}
extern "C" {
    pub fn __furi_critical_enter() -> __FuriCriticalInfo;
}
extern "C" {
    pub fn __furi_critical_exit(info: __FuriCriticalInfo);
}
#[doc = "Operation completed successfully.\n\n"]
pub const FuriStatus_FuriStatusOk: FuriStatus = 0;
pub const FuriStatus_FuriStatusError: FuriStatus = -1;
#[doc = "Operation not completed within the timeout period.\n\n"]
pub const FuriStatus_FuriStatusErrorTimeout: FuriStatus = -2;
#[doc = "Resource not available.\n\n"]
pub const FuriStatus_FuriStatusErrorResource: FuriStatus = -3;
#[doc = "Parameter error.\n\n"]
pub const FuriStatus_FuriStatusErrorParameter: FuriStatus = -4;
pub const FuriStatus_FuriStatusErrorNoMemory: FuriStatus = -5;
pub const FuriStatus_FuriStatusErrorISR: FuriStatus = -6;
#[doc = "Prevents enum down-size compiler optimization.\n\n"]
pub const FuriStatus_FuriStatusReserved: FuriStatus = 2147483647;
pub type FuriStatus = core::ffi::c_int;
pub type FuriEventFlag = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate FuriEventFlag\n\nReturns:\n\n* pointer to FuriEventFlag\n\n"]
    pub fn furi_event_flag_alloc() -> *mut FuriEventFlag;
}
extern "C" {
    #[doc = "Deallocate FuriEventFlag\n\n# Arguments\n\n* `instance` - pointer to FuriEventFlag\n\n"]
    pub fn furi_event_flag_free(instance: *mut FuriEventFlag);
}
extern "C" {
    #[doc = "Set flags\n\nReturns:\n\n* Resulting flags or error (FuriStatus)\n\n# Arguments\n\n* `instance` - pointer to FuriEventFlag\n* `flags` - [Direction: In] The flags\n\n"]
    pub fn furi_event_flag_set(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = "Clear flags\n\nReturns:\n\n* Resulting flags or error (FuriStatus)\n\n# Arguments\n\n* `instance` - pointer to FuriEventFlag\n* `flags` - [Direction: In] The flags\n\n"]
    pub fn furi_event_flag_clear(instance: *mut FuriEventFlag, flags: u32) -> u32;
}
extern "C" {
    #[doc = "Get flags\n\nReturns:\n\n* Resulting flags\n\n# Arguments\n\n* `instance` - pointer to FuriEventFlag\n\n"]
    pub fn furi_event_flag_get(instance: *mut FuriEventFlag) -> u32;
}
extern "C" {
    #[doc = "Wait flags\n\nReturns:\n\n* Resulting flags or error (FuriStatus)\n\n# Arguments\n\n* `instance` - pointer to FuriEventFlag\n* `flags` - [Direction: In] The flags\n* `options` - [Direction: In] The option flags\n* `timeout` - [Direction: In] The timeout\n\n"]
    pub fn furi_event_flag_wait(
        instance: *mut FuriEventFlag,
        flags: u32,
        options: u32,
        timeout: u32,
    ) -> u32;
}
extern "C" {
    #[doc = "Check if CPU is in IRQ or kernel running and IRQ is masked\nOriginally this primitive was born as a workaround for FreeRTOS kernel primitives shenanigans with PRIMASK.\nMeaningful use cases are:\nWhen kernel is started and you want to ensure that you are not in IRQ or IRQ is not masked(like in critical section)\n* When kernel is not started and you want to make sure that you are not in IRQ mode, ignoring PRIMASK.\nAs you can see there will be edge case when kernel is not started and PRIMASK is not 0 that may cause some funky behavior. Most likely it will happen after kernel primitives being used, but control not yet passed to kernel. It's up to you to figure out if it is safe for your code or not.\n\nReturns:\n\n* true if CPU is in IRQ or kernel running and IRQ is masked\n\n"]
    pub fn furi_kernel_is_irq_or_masked() -> bool;
}
extern "C" {
    #[doc = "Check if kernel is running\n\nReturns:\n\n* true if running, false otherwise\n\n"]
    pub fn furi_kernel_is_running() -> bool;
}
extern "C" {
    #[doc = "Lock kernel, pause process scheduling\n\n**Warning!**\n\n* This should never be called in interrupt request context.\n\nReturns:\n\n* previous lock state(0 - unlocked, 1 - locked)\n\n"]
    pub fn furi_kernel_lock() -> i32;
}
extern "C" {
    #[doc = "Unlock kernel, resume process scheduling\n\n**Warning!**\n\n* This should never be called in interrupt request context.\n\nReturns:\n\n* previous lock state(0 - unlocked, 1 - locked)\n\n"]
    pub fn furi_kernel_unlock() -> i32;
}
extern "C" {
    #[doc = "Restore kernel lock state\n\n**Warning!**\n\n* This should never be called in interrupt request context.\n\nReturns:\n\n* new lock state or error\n\n# Arguments\n\n* `lock` - [Direction: In] The lock state\n\n"]
    pub fn furi_kernel_restore_lock(lock: i32) -> i32;
}
extern "C" {
    #[doc = "Get kernel systick frequency\n\nReturns:\n\n* systick counts per second\n\n"]
    pub fn furi_kernel_get_tick_frequency() -> u32;
}
extern "C" {
    #[doc = "Delay execution\nAlso keep in mind delay is aliased to scheduler timer intervals.\n\n**Warning!**\n\n* This should never be called in interrupt request context.\n\n# Arguments\n\n* `ticks` - [Direction: In] The ticks count to pause\n\n"]
    pub fn furi_delay_tick(ticks: u32);
}
extern "C" {
    #[doc = "Delay until tick\n\n**Warning!**\n\n* This should never be called in interrupt request context.\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `ticks` - [Direction: In] The tick until which kerel should delay task execution\n\n"]
    pub fn furi_delay_until_tick(tick: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Get current tick counter\nSystem uptime, may overflow.\n\nReturns:\n\n* Current ticks in milliseconds\n\n"]
    pub fn furi_get_tick() -> u32;
}
extern "C" {
    #[doc = "Convert milliseconds to ticks\n\nReturns:\n\n* time in ticks\n\n# Arguments\n\n* `milliseconds` - [Direction: In] time in milliseconds\n\n"]
    pub fn furi_ms_to_ticks(milliseconds: u32) -> u32;
}
extern "C" {
    #[doc = "Delay in milliseconds\nThis method uses kernel ticks on the inside, which causes delay to be aliased to scheduler timer intervals. Real wait time will be between X+ milliseconds. Special value: 0, will cause task yield. Also if used when kernel is not running will fall back to `furi_delay_us`.\n\n**Warning!**\n\n* Cannot be used from ISR\n\n# Arguments\n\n* `milliseconds` - [Direction: In] milliseconds to wait\n\n"]
    pub fn furi_delay_ms(milliseconds: u32);
}
extern "C" {
    #[doc = "Delay in microseconds\nImplemented using Cortex DWT counter. Blocking and non aliased.\n\n# Arguments\n\n* `microseconds` - [Direction: In] microseconds to wait\n\n"]
    pub fn furi_delay_us(microseconds: u32);
}
pub const FuriLogLevel_FuriLogLevelDefault: FuriLogLevel = 0;
pub const FuriLogLevel_FuriLogLevelNone: FuriLogLevel = 1;
pub const FuriLogLevel_FuriLogLevelError: FuriLogLevel = 2;
pub const FuriLogLevel_FuriLogLevelWarn: FuriLogLevel = 3;
pub const FuriLogLevel_FuriLogLevelInfo: FuriLogLevel = 4;
pub const FuriLogLevel_FuriLogLevelDebug: FuriLogLevel = 5;
pub const FuriLogLevel_FuriLogLevelTrace: FuriLogLevel = 6;
pub type FuriLogLevel = core::ffi::c_uchar;
extern "C" {
    #[doc = "Print log record\n\n# Arguments\n\n* `level` - \n* `tag` - \n* `format` - \n* `...` - \n\n"]
    pub fn furi_log_print_format(
        level: FuriLogLevel,
        tag: *const core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    #[doc = "Print log record\n\n# Arguments\n\n* `level` - \n* `format` - \n* `...` - \n\n"]
    pub fn furi_log_print_raw_format(level: FuriLogLevel, format: *const core::ffi::c_char, ...);
}
extern "C" {
    #[doc = "Set log level\n\n# Arguments\n\n* `level` - [Direction: In] The level\n\n"]
    pub fn furi_log_set_level(level: FuriLogLevel);
}
extern "C" {
    #[doc = "Get log level\n\nReturns:\n\n* The furi log level.\n\n"]
    pub fn furi_log_get_level() -> FuriLogLevel;
}
extern "C" {
    #[doc = "Log level to string\n\nReturns:\n\n* The string\n\n# Arguments\n\n* `level` - [Direction: In] The level\n\n"]
    pub fn furi_log_level_to_string(
        level: FuriLogLevel,
        str_: *mut *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Log level from string\n\nReturns:\n\n* True if success, False otherwise\n\n# Arguments\n\n* `str` - [Direction: In] The string\n* `level` - The level\n\n"]
    pub fn furi_log_level_from_string(
        str_: *const core::ffi::c_char,
        level: *mut FuriLogLevel,
    ) -> bool;
}
extern "C" {
    #[doc = "Get free heap size\n\nReturns:\n\n* free heap size in bytes\n\n"]
    pub fn memmgr_get_free_heap() -> usize;
}
extern "C" {
    #[doc = "Get total heap size\n\nReturns:\n\n* total heap size in bytes\n\n"]
    pub fn memmgr_get_total_heap() -> usize;
}
extern "C" {
    #[doc = "Get heap watermark\n\nReturns:\n\n* minimum heap in bytes\n\n"]
    pub fn memmgr_get_minimum_free_heap() -> usize;
}
extern "C" {
    #[doc = "An aligned version of malloc, used when you need to get the aligned space on the heap Freeing the received address is performed ONLY through the aligned_free function\n\nReturns:\n\n* void*\n\n# Arguments\n\n* `size` - \n* `alignment` - \n\n"]
    pub fn aligned_malloc(size: usize, alignment: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Freed space obtained through the aligned_malloc function\n\n# Arguments\n\n* `p` - pointer to result of aligned_malloc\n\n"]
    pub fn aligned_free(p: *mut core::ffi::c_void);
}
pub const FuriThreadState_FuriThreadStateStopped: FuriThreadState = 0;
pub const FuriThreadState_FuriThreadStateStarting: FuriThreadState = 1;
pub const FuriThreadState_FuriThreadStateRunning: FuriThreadState = 2;
#[doc = "FuriThreadState\n\n"]
pub type FuriThreadState = core::ffi::c_uchar;
#[doc = "Uninitialized, choose system default\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityNone: FuriThreadPriority = 0;
#[doc = "Idle priority\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityIdle: FuriThreadPriority = 1;
#[doc = "Lowest\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityLowest: FuriThreadPriority = 14;
#[doc = "Low\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityLow: FuriThreadPriority = 15;
#[doc = "Normal\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityNormal: FuriThreadPriority = 16;
#[doc = "High\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityHigh: FuriThreadPriority = 17;
#[doc = "Highest\n\n"]
pub const FuriThreadPriority_FuriThreadPriorityHighest: FuriThreadPriority = 18;
pub const FuriThreadPriority_FuriThreadPriorityIsr: FuriThreadPriority = 31;
#[doc = "FuriThreadPriority\n\n"]
pub type FuriThreadPriority = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriThread {
    _unused: [u8; 0],
}
#[doc = "FuriThreadId proxy type to OS low level functions\n\n"]
pub type FuriThreadId = *mut core::ffi::c_void;
#[doc = "FuriThreadCallback Your callback to run in new thread\n\n**Warning!**\n\n* never use osThreadExit in FuriThread\n\n"]
pub type FuriThreadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> i32>;
#[doc = "Write to stdout callback\n\n# Arguments\n\n* `data` - pointer to data\n* `size` - data size @warning your handler must consume everything\n\n"]
pub type FuriThreadStdoutWriteCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *const core::ffi::c_char, size: usize)>;
#[doc = "FuriThread state change callback called upon thread state change\n\n# Arguments\n\n* `state` - new thread state\n* `context` - callback context\n\n"]
pub type FuriThreadStateCallback = ::core::option::Option<
    unsafe extern "C" fn(state: FuriThreadState, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Allocate FuriThread\n\nReturns:\n\n* FuriThread instance\n\n"]
    pub fn furi_thread_alloc() -> *mut FuriThread;
}
extern "C" {
    #[doc = "Allocate FuriThread, shortcut version\n\nReturns:\n\n* FuriThread*\n\n# Arguments\n\n* `name` - \n* `stack_size` - \n* `callback` - \n* `context` - \n\n"]
    pub fn furi_thread_alloc_ex(
        name: *const core::ffi::c_char,
        stack_size: u32,
        callback: FuriThreadCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriThread;
}
extern "C" {
    #[doc = "Release FuriThread\n\n**Warning!**\n\n* see furi_thread_join\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_free(thread: *mut FuriThread);
}
extern "C" {
    #[doc = "Set FuriThread name\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `name` - string\n\n"]
    pub fn furi_thread_set_name(thread: *mut FuriThread, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set FuriThread appid Technically, it is like a \"process id\", but it is not a system-wide unique identifier. All threads spawned by the same app will have the same appid.\n\n# Arguments\n\n* `thread` - \n* `appid` - \n\n"]
    pub fn furi_thread_set_appid(thread: *mut FuriThread, appid: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Mark thread as service The service cannot be stopped or removed, and cannot exit from the thread body\n\n# Arguments\n\n* `thread` - \n\n"]
    pub fn furi_thread_mark_as_service(thread: *mut FuriThread);
}
extern "C" {
    #[doc = "Set FuriThread stack size\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `stack_size` - stack size in bytes\n\n"]
    pub fn furi_thread_set_stack_size(thread: *mut FuriThread, stack_size: usize);
}
extern "C" {
    #[doc = "Set FuriThread callback\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `callback` - FuriThreadCallback, called upon thread run\n\n"]
    pub fn furi_thread_set_callback(thread: *mut FuriThread, callback: FuriThreadCallback);
}
extern "C" {
    #[doc = "Set FuriThread context\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `context` - pointer to context for thread callback\n\n"]
    pub fn furi_thread_set_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set FuriThread priority\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `priority` - FuriThreadPriority value\n\n"]
    pub fn furi_thread_set_priority(thread: *mut FuriThread, priority: FuriThreadPriority);
}
extern "C" {
    #[doc = "Set current thread priority\n\n# Arguments\n\n* `priority` - FuriThreadPriority value\n\n"]
    pub fn furi_thread_set_current_priority(priority: FuriThreadPriority);
}
extern "C" {
    #[doc = "Get current thread priority\n\nReturns:\n\n* FuriThreadPriority value\n\n"]
    pub fn furi_thread_get_current_priority() -> FuriThreadPriority;
}
extern "C" {
    #[doc = "Set FuriThread state change callback\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `callback` - state change callback\n\n"]
    pub fn furi_thread_set_state_callback(
        thread: *mut FuriThread,
        callback: FuriThreadStateCallback,
    );
}
extern "C" {
    #[doc = "Set FuriThread state change context\n\n# Arguments\n\n* `thread` - FuriThread instance\n* `context` - pointer to context\n\n"]
    pub fn furi_thread_set_state_context(thread: *mut FuriThread, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Get FuriThread state\n\nReturns:\n\n* thread state from FuriThreadState\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_get_state(thread: *mut FuriThread) -> FuriThreadState;
}
extern "C" {
    #[doc = "Start FuriThread\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_start(thread: *mut FuriThread);
}
extern "C" {
    #[doc = "Join FuriThread\n\n**Warning!**\n\n* Use this method only when CPU is not busy(Idle task receives control), otherwise it will wait forever.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_join(thread: *mut FuriThread) -> bool;
}
extern "C" {
    #[doc = "Get FreeRTOS FuriThreadId for FuriThread instance\n\nReturns:\n\n* FuriThreadId or NULL\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_get_id(thread: *mut FuriThread) -> FuriThreadId;
}
extern "C" {
    #[doc = "Enable heap tracing\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_enable_heap_trace(thread: *mut FuriThread);
}
extern "C" {
    #[doc = "Get thread heap size\n\nReturns:\n\n* size in bytes\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_get_heap_size(thread: *mut FuriThread) -> usize;
}
extern "C" {
    #[doc = "Get thread return code\n\nReturns:\n\n* return code\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_get_return_code(thread: *mut FuriThread) -> i32;
}
extern "C" {
    #[doc = "Get FreeRTOS FuriThreadId for current thread\n\nReturns:\n\n* FuriThreadId or NULL\n\n# Arguments\n\n* `thread` - FuriThread instance\n\n"]
    pub fn furi_thread_get_current_id() -> FuriThreadId;
}
extern "C" {
    #[doc = "Get FuriThread instance for current thread\n\nReturns:\n\n* pointer to FuriThread or NULL if this thread doesn't belongs to Furi\n\n"]
    pub fn furi_thread_get_current() -> *mut FuriThread;
}
extern "C" {
    #[doc = "Return control to scheduler\n\n"]
    pub fn furi_thread_yield();
}
extern "C" {
    pub fn furi_thread_flags_set(thread_id: FuriThreadId, flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_clear(flags: u32) -> u32;
}
extern "C" {
    pub fn furi_thread_flags_get() -> u32;
}
extern "C" {
    pub fn furi_thread_flags_wait(flags: u32, options: u32, timeout: u32) -> u32;
}
extern "C" {
    #[doc = "Enumerate threads\n\nReturns:\n\n* uint32_t threads count\n\n# Arguments\n\n* `thread_array` - array of FuriThreadId, where thread ids will be stored\n* `array_items` - array size\n\n"]
    pub fn furi_thread_enumerate(thread_array: *mut FuriThreadId, array_items: u32) -> u32;
}
extern "C" {
    #[doc = "Get thread name\n\nReturns:\n\n* const char* name or NULL\n\n# Arguments\n\n* `thread_id` - \n\n"]
    pub fn furi_thread_get_name(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get thread appid\n\nReturns:\n\n* const char* appid\n\n# Arguments\n\n* `thread_id` - \n\n"]
    pub fn furi_thread_get_appid(thread_id: FuriThreadId) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get thread stack watermark\n\nReturns:\n\n* uint32_t\n\n# Arguments\n\n* `thread_id` - \n\n"]
    pub fn furi_thread_get_stack_space(thread_id: FuriThreadId) -> u32;
}
extern "C" {
    #[doc = "Get STDOUT callback for thead\n\nReturns:\n\n* STDOUT callback\n\n"]
    pub fn furi_thread_get_stdout_callback() -> FuriThreadStdoutWriteCallback;
}
extern "C" {
    #[doc = "Set STDOUT callback for thread\n\n# Arguments\n\n* `callback` - callback or NULL to clear\n\n"]
    pub fn furi_thread_set_stdout_callback(callback: FuriThreadStdoutWriteCallback);
}
extern "C" {
    #[doc = "Write data to buffered STDOUT\n\nReturns:\n\n* size_t written data size\n\n# Arguments\n\n* `data` - input data\n* `size` - input data size\n\n"]
    pub fn furi_thread_stdout_write(data: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = "Flush data to STDOUT\n\nReturns:\n\n* int32_t error code\n\n"]
    pub fn furi_thread_stdout_flush() -> i32;
}
extern "C" {
    #[doc = "Suspend thread\n\n# Arguments\n\n* `thread_id` - thread id\n\n"]
    pub fn furi_thread_suspend(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = "Resume thread\n\n# Arguments\n\n* `thread_id` - thread id\n\n"]
    pub fn furi_thread_resume(thread_id: FuriThreadId);
}
extern "C" {
    #[doc = "Get thread suspended state\n\nReturns:\n\n* true if thread is suspended\n\n# Arguments\n\n* `thread_id` - thread id\n\n"]
    pub fn furi_thread_is_suspended(thread_id: FuriThreadId) -> bool;
}
extern "C" {
    #[doc = "Memmgr heap enable thread allocation tracking\n\n# Arguments\n\n* `thread_id` - - thread id to track\n\n"]
    pub fn memmgr_heap_enable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = "Memmgr heap disable thread allocation tracking\n\n# Arguments\n\n* `thread_id` - - thread id to track\n\n"]
    pub fn memmgr_heap_disable_thread_trace(taks_handle: FuriThreadId);
}
extern "C" {
    #[doc = "Memmgr heap get allocatred thread memory\n\nReturns:\n\n* bytes allocated right now\n\n# Arguments\n\n* `thread_id` - - thread id to track\n\n"]
    pub fn memmgr_heap_get_thread_memory(taks_handle: FuriThreadId) -> usize;
}
extern "C" {
    #[doc = "Memmgr heap get the max contiguous block size on the heap\n\nReturns:\n\n* size_t max contiguous block size\n\n"]
    pub fn memmgr_heap_get_max_free_block() -> usize;
}
extern "C" {
    #[doc = "Print the address and size of all free blocks to stdout\n\n"]
    pub fn memmgr_heap_printf_free_blocks();
}
pub type FuriMessageQueue = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate furi message queue\n\nReturns:\n\n* pointer to FuriMessageQueue instance\n\n# Arguments\n\n* `msg_count` - [Direction: In] The message count\n* `msg_size` - [Direction: In] The message size\n\n"]
    pub fn furi_message_queue_alloc(msg_count: u32, msg_size: u32) -> *mut FuriMessageQueue;
}
extern "C" {
    #[doc = "Free queue\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_free(instance: *mut FuriMessageQueue);
}
extern "C" {
    #[doc = "Put message into queue\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n* `msg_ptr` - [Direction: In] The message pointer\n* `timeout` - [Direction: In] The timeout\n* `msg_prio` - [Direction: In] The message prio\n\n"]
    pub fn furi_message_queue_put(
        instance: *mut FuriMessageQueue,
        msg_ptr: *const core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = "Get message from queue\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n* `msg_ptr` - The message pointer\n* `msg_prio` - The message prioority\n* `timeout` - [Direction: In] The timeout\n\n"]
    pub fn furi_message_queue_get(
        instance: *mut FuriMessageQueue,
        msg_ptr: *mut core::ffi::c_void,
        timeout: u32,
    ) -> FuriStatus;
}
extern "C" {
    #[doc = "Get queue capacity\n\nReturns:\n\n* capacity in object count\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_get_capacity(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = "Get message size\n\nReturns:\n\n* Message size in bytes\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_get_message_size(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = "Get message count in queue\n\nReturns:\n\n* Message count\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_get_count(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = "Get queue available space\n\nReturns:\n\n* Message count\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_get_space(instance: *mut FuriMessageQueue) -> u32;
}
extern "C" {
    #[doc = "Reset queue\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - pointer to FuriMessageQueue instance\n\n"]
    pub fn furi_message_queue_reset(instance: *mut FuriMessageQueue) -> FuriStatus;
}
pub const FuriMutexType_FuriMutexTypeNormal: FuriMutexType = 0;
pub const FuriMutexType_FuriMutexTypeRecursive: FuriMutexType = 1;
pub type FuriMutexType = core::ffi::c_uchar;
pub type FuriMutex = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate FuriMutex\n\nReturns:\n\n* pointer to FuriMutex instance\n\n# Arguments\n\n* `type` - [Direction: In] The mutex type\n\n"]
    pub fn furi_mutex_alloc(type_: FuriMutexType) -> *mut FuriMutex;
}
extern "C" {
    #[doc = "Free FuriMutex\n\n# Arguments\n\n* `instance` - The pointer to FuriMutex instance\n\n"]
    pub fn furi_mutex_free(instance: *mut FuriMutex);
}
extern "C" {
    #[doc = "Acquire mutex\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriMutex instance\n* `timeout` - [Direction: In] The timeout\n\n"]
    pub fn furi_mutex_acquire(instance: *mut FuriMutex, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Release mutex\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriMutex instance\n\n"]
    pub fn furi_mutex_release(instance: *mut FuriMutex) -> FuriStatus;
}
extern "C" {
    #[doc = "Get mutex owner thread id\n\nReturns:\n\n* The furi thread identifier.\n\n# Arguments\n\n* `instance` - The pointer to FuriMutex instance\n\n"]
    pub fn furi_mutex_get_owner(instance: *mut FuriMutex) -> FuriThreadId;
}
#[doc = "FuriPubSub Callback type\n\n"]
pub type FuriPubSubCallback = ::core::option::Option<
    unsafe extern "C" fn(message: *const core::ffi::c_void, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriPubSubSubscription {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate FuriPubSub\nReentrable, Not threadsafe, one owner\n\nReturns:\n\n* pointer to FuriPubSub instance\n\n"]
    pub fn furi_pubsub_alloc() -> *mut FuriPubSub;
}
extern "C" {
    #[doc = "Subscribe to FuriPubSub\nThreadsafe, Reentrable\n\nReturns:\n\n* pointer to FuriPubSubSubscription instance\n\n# Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n* `callback` - [Direction: In] The callback\n* `callback_context` - The callback context\n\n"]
    pub fn furi_pubsub_subscribe(
        pubsub: *mut FuriPubSub,
        callback: FuriPubSubCallback,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut FuriPubSubSubscription;
}
extern "C" {
    #[doc = "Unsubscribe from FuriPubSub\nNo use of `pubsub_subscription` allowed after call of this method Threadsafe, Reentrable.\n\n# Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n* `pubsub_subscription` - pointer to FuriPubSubSubscription instance\n\n"]
    pub fn furi_pubsub_unsubscribe(
        pubsub: *mut FuriPubSub,
        pubsub_subscription: *mut FuriPubSubSubscription,
    );
}
extern "C" {
    #[doc = "Publish message to FuriPubSub\nThreadsafe, Reentrable.\n\n# Arguments\n\n* `pubsub` - pointer to FuriPubSub instance\n* `message` - message pointer to publish\n\n"]
    pub fn furi_pubsub_publish(pubsub: *mut FuriPubSub, message: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Check if record exists\n\n# Arguments\n\n* `name` - record name\n\n# Notes\n\n* Thread safe. Create and destroy must be executed from the same thread.\n\n"]
    pub fn furi_record_exists(name: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Create record\n\n# Arguments\n\n* `name` - record name\n* `data` - data pointer\n\n# Notes\n\n* Thread safe. Create and destroy must be executed from the same thread.\n\n"]
    pub fn furi_record_create(name: *const core::ffi::c_char, data: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Open record\n\nReturns:\n\n* pointer to the record\n\n# Arguments\n\n* `name` - record name\n\n# Notes\n\n* Thread safe. Open and close must be executed from the same thread. Suspends caller thread till record is available\n\n"]
    pub fn furi_record_open(name: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Close record\n\n# Arguments\n\n* `name` - record name\n\n# Notes\n\n* Thread safe. Open and close must be executed from the same thread.\n\n"]
    pub fn furi_record_close(name: *const core::ffi::c_char);
}
pub type FuriSemaphore = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate semaphore\n\nReturns:\n\n* pointer to FuriSemaphore instance\n\n# Arguments\n\n* `max_count` - [Direction: In] The maximum count\n* `initial_count` - [Direction: In] The initial count\n\n"]
    pub fn furi_semaphore_alloc(max_count: u32, initial_count: u32) -> *mut FuriSemaphore;
}
extern "C" {
    #[doc = "Free semaphore\n\n# Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n"]
    pub fn furi_semaphore_free(instance: *mut FuriSemaphore);
}
extern "C" {
    #[doc = "Acquire semaphore\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n* `timeout` - [Direction: In] The timeout\n\n"]
    pub fn furi_semaphore_acquire(instance: *mut FuriSemaphore, timeout: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Release semaphore\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n"]
    pub fn furi_semaphore_release(instance: *mut FuriSemaphore) -> FuriStatus;
}
extern "C" {
    #[doc = "Get semaphore count\n\nReturns:\n\n* Semaphore count\n\n# Arguments\n\n* `instance` - The pointer to FuriSemaphore instance\n\n"]
    pub fn furi_semaphore_get_count(instance: *mut FuriSemaphore) -> u32;
}
pub type FuriTimerCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "One-shot timer.\n\n"]
pub const FuriTimerType_FuriTimerTypeOnce: FuriTimerType = 0;
#[doc = "Repeating timer.\n\n"]
pub const FuriTimerType_FuriTimerTypePeriodic: FuriTimerType = 1;
pub type FuriTimerType = core::ffi::c_uchar;
pub type FuriTimer = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate timer\n\nReturns:\n\n* The pointer to FuriTimer instance\n\n# Arguments\n\n* `func` - [Direction: In] The callback function\n* `type` - [Direction: In] The timer type\n* `context` - The callback context\n\n"]
    pub fn furi_timer_alloc(
        func: FuriTimerCallback,
        type_: FuriTimerType,
        context: *mut core::ffi::c_void,
    ) -> *mut FuriTimer;
}
extern "C" {
    #[doc = "Free timer\n\n# Arguments\n\n* `instance` - The pointer to FuriTimer instance\n\n"]
    pub fn furi_timer_free(instance: *mut FuriTimer);
}
extern "C" {
    #[doc = "Start timer\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriTimer instance\n* `ticks` - [Direction: In] The interval in ticks\n\n"]
    pub fn furi_timer_start(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Restart timer with previous timeout value\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriTimer instance\n* `ticks` - [Direction: In] The interval in ticks\n\n"]
    pub fn furi_timer_restart(instance: *mut FuriTimer, ticks: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Stop timer\n\nReturns:\n\n* The furi status.\n\n# Arguments\n\n* `instance` - The pointer to FuriTimer instance\n\n"]
    pub fn furi_timer_stop(instance: *mut FuriTimer) -> FuriStatus;
}
extern "C" {
    #[doc = "Is timer running\n\nReturns:\n\n* 0: not running, 1: running\n\n# Arguments\n\n* `instance` - The pointer to FuriTimer instance\n\n"]
    pub fn furi_timer_is_running(instance: *mut FuriTimer) -> u32;
}
extern "C" {
    #[doc = "Get timer expire time\n\nReturns:\n\n* expire tick\n\n# Arguments\n\n* `instance` - The Timer instance\n\n"]
    pub fn furi_timer_get_expire_time(instance: *mut FuriTimer) -> u32;
}
pub type FuriTimerPendigCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, arg: u32)>;
extern "C" {
    pub fn furi_timer_pending_callback(
        callback: FuriTimerPendigCallback,
        context: *mut core::ffi::c_void,
        arg: u32,
    );
}
#[doc = "Lower then other threads\n\n"]
pub const FuriTimerThreadPriority_FuriTimerThreadPriorityNormal: FuriTimerThreadPriority = 0;
#[doc = "Same as other threads\n\n"]
pub const FuriTimerThreadPriority_FuriTimerThreadPriorityElevated: FuriTimerThreadPriority = 1;
pub type FuriTimerThreadPriority = core::ffi::c_uchar;
extern "C" {
    #[doc = "Set Timer thread priority\n\n# Arguments\n\n* `priority` - [Direction: In] The priority\n\n"]
    pub fn furi_timer_set_thread_priority(priority: FuriTimerThreadPriority);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriString {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate new FuriString.\n\nReturns:\n\n* FuriString*\n\n"]
    pub fn furi_string_alloc() -> *mut FuriString;
}
extern "C" {
    #[doc = "Allocate new FuriString and set it to string. Allocate & Set the string a to the string.\n\nReturns:\n\n* FuriString*\n\n# Arguments\n\n* `source` - \n\n"]
    pub fn furi_string_alloc_set(source: *const FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = "Allocate new FuriString and set it to C string. Allocate & Set the string a to the C string.\n\nReturns:\n\n* FuriString*\n\n# Arguments\n\n* `cstr_source` - \n\n"]
    pub fn furi_string_alloc_set_str(cstr_source: *const core::ffi::c_char) -> *mut FuriString;
}
extern "C" {
    #[doc = "Allocate new FuriString and printf to it. Initialize and set a string to the given formatted value.\n\nReturns:\n\n* FuriString*\n\n# Arguments\n\n* `format` - \n* `...` - \n\n"]
    pub fn furi_string_alloc_printf(format: *const core::ffi::c_char, ...) -> *mut FuriString;
}
extern "C" {
    #[doc = "Allocate new FuriString and printf to it. Initialize and set a string to the given formatted value.\n\nReturns:\n\n* FuriString*\n\n# Arguments\n\n* `format` - \n* `args` - \n\n"]
    pub fn furi_string_alloc_vprintf(
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> *mut FuriString;
}
extern "C" {
    #[doc = "Allocate new FuriString and move source string content to it. Allocate the string, set it to the other one, and destroy the other one.\n\nReturns:\n\n* FuriString*\n\n# Arguments\n\n* `source` - \n\n"]
    pub fn furi_string_alloc_move(source: *mut FuriString) -> *mut FuriString;
}
extern "C" {
    #[doc = "Free FuriString.\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_free(string: *mut FuriString);
}
extern "C" {
    #[doc = "Reserve memory for string. Modify the string capacity to be able to handle at least 'alloc' characters (including final null char).\n\n# Arguments\n\n* `string` - \n* `size` - \n\n"]
    pub fn furi_string_reserve(string: *mut FuriString, size: usize);
}
extern "C" {
    #[doc = "Reset string. Make the string empty.\n\n# Arguments\n\n* `s` - \n\n"]
    pub fn furi_string_reset(string: *mut FuriString);
}
extern "C" {
    #[doc = "Swap two strings. Swap the two strings string_1 and string_2.\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_swap(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = "Move string_2 content to string_1. Set the string to the other one, and destroy the other one.\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_move(string_1: *mut FuriString, string_2: *mut FuriString);
}
extern "C" {
    #[doc = "Compute a hash for the string.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_hash(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = "Get string size (usually length, but not for UTF-8)\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_size(string: *const FuriString) -> usize;
}
extern "C" {
    #[doc = "Check that string is empty or not\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_empty(string: *const FuriString) -> bool;
}
extern "C" {
    #[doc = "Get the character at the given index. Return the selected character of the string.\n\nReturns:\n\n* char\n\n# Arguments\n\n* `string` - \n* `index` - \n\n"]
    pub fn furi_string_get_char(string: *const FuriString, index: usize) -> core::ffi::c_char;
}
extern "C" {
    #[doc = "Return the string view a classic C string.\n\nReturns:\n\n* const char*\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_get_cstr(string: *const FuriString) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Set the string to the other string. Set the string to the source string.\n\n# Arguments\n\n* `string` - \n* `source` - \n\n"]
    pub fn furi_string_set(string: *mut FuriString, source: *mut FuriString);
}
extern "C" {
    #[doc = "Set the string to the other C string. Set the string to the source C string.\n\n# Arguments\n\n* `string` - \n* `source` - \n\n"]
    pub fn furi_string_set_str(string: *mut FuriString, source: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set the string to the n first characters of the C string.\n\n# Arguments\n\n* `string` - \n* `source` - \n* `length` - \n\n"]
    pub fn furi_string_set_strn(
        string: *mut FuriString,
        source: *const core::ffi::c_char,
        length: usize,
    );
}
extern "C" {
    #[doc = "Set the character at the given index.\n\n# Arguments\n\n* `string` - \n* `index` - \n* `c` - \n\n"]
    pub fn furi_string_set_char(string: *mut FuriString, index: usize, c: core::ffi::c_char);
}
extern "C" {
    #[doc = "Set the string to the n first characters of other one.\n\n# Arguments\n\n* `string` - \n* `source` - \n* `offset` - \n* `length` - \n\n"]
    pub fn furi_string_set_n(
        string: *mut FuriString,
        source: *const FuriString,
        offset: usize,
        length: usize,
    );
}
extern "C" {
    #[doc = "Format in the string the given printf format\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string` - \n* `format` - \n* `...` - \n\n"]
    pub fn furi_string_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Format in the string the given printf format\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string` - \n* `format` - \n* `args` - \n\n"]
    pub fn furi_string_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Append a character to the string.\n\n# Arguments\n\n* `string` - \n* `c` - \n\n"]
    pub fn furi_string_push_back(string: *mut FuriString, c: core::ffi::c_char);
}
extern "C" {
    #[doc = "Append a string to the string. Concatenate the string with the other string.\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_cat(string_1: *mut FuriString, string_2: *const FuriString);
}
extern "C" {
    #[doc = "Append a C string to the string. Concatenate the string with the C string.\n\n# Arguments\n\n* `string_1` - \n* `cstring_2` - \n\n"]
    pub fn furi_string_cat_str(string_1: *mut FuriString, cstring_2: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Append to the string the formatted string of the given printf format.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string` - \n* `format` - \n* `...` - \n\n"]
    pub fn furi_string_cat_printf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Append to the string the formatted string of the given printf format.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string` - \n* `format` - \n* `args` - \n\n"]
    pub fn furi_string_cat_vprintf(
        string: *mut FuriString,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Compare two strings and return the sort order.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_cmp(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Compare string with C string and return the sort order.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string_1` - \n* `cstring_2` - \n\n"]
    pub fn furi_string_cmp_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Compare two strings (case insensitive according to the current locale) and return the sort order. Note: doesn't work with UTF-8 strings.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_cmpi(
        string_1: *const FuriString,
        string_2: *const FuriString,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Compare string with C string (case insensitive according to the current locale) and return the sort order. Note: doesn't work with UTF-8 strings.\n\nReturns:\n\n* int\n\n# Arguments\n\n* `string_1` - \n* `cstring_2` - \n\n"]
    pub fn furi_string_cmpi_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = "Search the first occurrence of the needle in the string from the position start. Return STRING_FAILURE if not found. By default, start is zero.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `start` - \n\n"]
    pub fn furi_string_search(
        string: *const FuriString,
        needle: *const FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Search the first occurrence of the needle in the string from the position start. Return STRING_FAILURE if not found.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `start` - \n\n"]
    pub fn furi_string_search_str(
        string: *const FuriString,
        needle: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Search for the position of the character c from the position start (include) in the string. Return STRING_FAILURE if not found. By default, start is zero.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `c` - \n* `start` - \n\n"]
    pub fn furi_string_search_char(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Reverse search for the position of the character c from the position start (include) in the string. Return STRING_FAILURE if not found. By default, start is zero.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `c` - \n* `start` - \n\n"]
    pub fn furi_string_search_rchar(
        string: *const FuriString,
        c: core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Test if two strings are equal.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string_1` - \n* `string_2` - \n\n"]
    pub fn furi_string_equal(string_1: *const FuriString, string_2: *const FuriString) -> bool;
}
extern "C" {
    #[doc = "Test if the string is equal to the C string.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string_1` - \n* `cstring_2` - \n\n"]
    pub fn furi_string_equal_str(
        string_1: *const FuriString,
        cstring_2: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Replace in the string the sub-string at position 'pos' for 'len' bytes into the C string 'replace'.\n\n# Arguments\n\n* `string` - \n* `pos` - \n* `len` - \n* `replace` - \n\n"]
    pub fn furi_string_replace_at(
        string: *mut FuriString,
        pos: usize,
        len: usize,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Replace a string 'needle' to string 'replace' in a string from 'start' position. By default, start is zero. Return STRING_FAILURE if 'needle' not found or replace position.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `replace` - \n* `start` - \n\n"]
    pub fn furi_string_replace(
        string: *mut FuriString,
        needle: *mut FuriString,
        replace: *mut FuriString,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Replace a C string 'needle' to C string 'replace' in a string from 'start' position. By default, start is zero. Return STRING_FAILURE if 'needle' not found or replace position.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `replace` - \n* `start` - \n\n"]
    pub fn furi_string_replace_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
        start: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Replace all occurrences of 'needle' string into 'replace' string.\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `replace` - \n\n"]
    pub fn furi_string_replace_all(
        string: *mut FuriString,
        needle: *const FuriString,
        replace: *const FuriString,
    );
}
extern "C" {
    #[doc = "Replace all occurrences of 'needle' C string into 'replace' C string.\n\n# Arguments\n\n* `string` - \n* `needle` - \n* `replace` - \n\n"]
    pub fn furi_string_replace_all_str(
        string: *mut FuriString,
        needle: *const core::ffi::c_char,
        replace: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Test if the string starts with the given string.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string` - \n* `start` - \n\n"]
    pub fn furi_string_start_with(string: *const FuriString, start: *const FuriString) -> bool;
}
extern "C" {
    #[doc = "Test if the string starts with the given C string.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string` - \n* `start` - \n\n"]
    pub fn furi_string_start_with_str(
        string: *const FuriString,
        start: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Test if the string ends with the given string.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string` - \n* `end` - \n\n"]
    pub fn furi_string_end_with(string: *const FuriString, end: *const FuriString) -> bool;
}
extern "C" {
    #[doc = "Test if the string ends with the given C string.\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `string` - \n* `end` - \n\n"]
    pub fn furi_string_end_with_str(
        string: *const FuriString,
        end: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Trim the string left to the first 'index' bytes.\n\n# Arguments\n\n* `string` - \n* `index` - \n\n"]
    pub fn furi_string_left(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = "Trim the string right from the 'index' position to the last position.\n\n# Arguments\n\n* `string` - \n* `index` - \n\n"]
    pub fn furi_string_right(string: *mut FuriString, index: usize);
}
extern "C" {
    #[doc = "Trim the string from position index to size bytes. See also furi_string_set_n.\n\n# Arguments\n\n* `string` - \n* `index` - \n* `size` - \n\n"]
    pub fn furi_string_mid(string: *mut FuriString, index: usize, size: usize);
}
extern "C" {
    #[doc = "Trim a string from the given set of characters (default is \" \\n\\r\\t\").\n\n# Arguments\n\n* `string` - \n* `chars` - \n\n"]
    pub fn furi_string_trim(string: *mut FuriString, chars: *const core::ffi::c_char);
}
#[doc = "An unicode value.\n\n"]
pub type FuriStringUnicodeValue = core::ffi::c_uint;
extern "C" {
    #[doc = "Compute the length in UTF8 characters in the string.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `string` - \n\n"]
    pub fn furi_string_utf8_length(string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = "Push unicode into string, encoding it in UTF8.\n\n# Arguments\n\n* `string` - \n* `unicode` - \n\n"]
    pub fn furi_string_utf8_push(string: *mut FuriString, unicode: FuriStringUnicodeValue);
}
pub const FuriStringUTF8State_FuriStringUTF8StateStarting: FuriStringUTF8State = 0;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding1: FuriStringUTF8State = 1;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding2: FuriStringUTF8State = 2;
pub const FuriStringUTF8State_FuriStringUTF8StateDecoding3: FuriStringUTF8State = 3;
pub const FuriStringUTF8State_FuriStringUTF8StateError: FuriStringUTF8State = 4;
#[doc = "State of the UTF8 decoding machine state.\n\n"]
pub type FuriStringUTF8State = core::ffi::c_uchar;
extern "C" {
    #[doc = "Main generic UTF8 decoder. It takes a character, and the previous state and the previous value of the unicode value. It updates the state and the decoded unicode value. A decoded unicode encoded value is valid only when the state is FuriStringUTF8StateStarting.\n\n# Arguments\n\n* `c` - \n* `state` - \n* `unicode` - \n\n"]
    pub fn furi_string_utf8_decode(
        c: core::ffi::c_char,
        state: *mut FuriStringUTF8State,
        unicode: *mut FuriStringUnicodeValue,
    );
}
pub type FuriStreamBuffer = core::ffi::c_void;
extern "C" {
    #[doc = "Allocate stream buffer instance. Stream buffer implementation assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader).\n\nReturns:\n\n* The stream buffer instance.\n\n# Arguments\n\n* `size` - The total number of bytes the stream buffer will be able to hold at any one time.\n* `trigger_level` - The number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.\n\n"]
    pub fn furi_stream_buffer_alloc(size: usize, trigger_level: usize) -> *mut FuriStreamBuffer;
}
extern "C" {
    #[doc = "Free stream buffer instance\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_free(stream_buffer: *mut FuriStreamBuffer);
}
extern "C" {
    #[doc = "Set trigger level for stream buffer. A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state.\n\nReturns:\n\n* true if trigger level can be be updated (new trigger level was less than or equal to the stream buffer's length).\n* false if trigger level can't be be updated (new trigger level was greater than the stream buffer's length).\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance\n* `trigger_level` - The new trigger level for the stream buffer.\n\n"]
    pub fn furi_stream_set_trigger_level(
        stream_buffer: *mut FuriStreamBuffer,
        trigger_level: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Sends bytes to a stream buffer. The bytes are copied into the stream buffer. Wakes up task waiting for data to become available if called from ISR.\n\nReturns:\n\n* The number of bytes actually written to the stream buffer.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n* `data` - A pointer to the data that is to be copied into the stream buffer.\n* `length` - The maximum number of bytes to copy from data into the stream buffer.\n* `timeout` - The maximum amount of time the task should remain in the Blocked state to wait for space to become available if the stream buffer is full. Will return immediately if timeout is zero. Setting timeout to FuriWaitForever will cause the task to wait indefinitely. Ignored if called from ISR.\n\n"]
    pub fn furi_stream_buffer_send(
        stream_buffer: *mut FuriStreamBuffer,
        data: *const core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = "Receives bytes from a stream buffer. Wakes up task waiting for space to become available if called from ISR.\n\nReturns:\n\n* The number of bytes read from the stream buffer, if any.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n* `data` - A pointer to the buffer into which the received bytes will be copied.\n* `length` - The length of the buffer pointed to by the data parameter.\n* `timeout` - The maximum amount of time the task should remain in the Blocked state to wait for data to become available if the stream buffer is empty. Will return immediately if timeout is zero. Setting timeout to FuriWaitForever will cause the task to wait indefinitely. Ignored if called from ISR.\n\n"]
    pub fn furi_stream_buffer_receive(
        stream_buffer: *mut FuriStreamBuffer,
        data: *mut core::ffi::c_void,
        length: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = "Queries a stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.\n\nReturns:\n\n* The number of bytes that can be read from the stream buffer before the stream buffer would be empty.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_bytes_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = "Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.\n\nReturns:\n\n* The number of bytes that can be written to the stream buffer before the stream buffer would be full.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_spaces_available(stream_buffer: *mut FuriStreamBuffer) -> usize;
}
extern "C" {
    #[doc = "Queries a stream buffer to see if it is full.\n\nReturns:\n\n* true if the stream buffer is full.\n* false if the stream buffer is not full.\n\n# Arguments\n\n* `stream_buffer` - stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_is_full(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = "Queries a stream buffer to see if it is empty.\n\nReturns:\n\n* true if the stream buffer is empty.\n* false if the stream buffer is not empty.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_is_empty(stream_buffer: *mut FuriStreamBuffer) -> bool;
}
extern "C" {
    #[doc = "Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.\n\nReturns:\n\n* FuriStatusOk if the stream buffer is reset.\n* FuriStatusError if there was a task blocked waiting to send to or read from the stream buffer then the stream buffer is not reset.\n\n# Arguments\n\n* `stream_buffer` - The stream buffer instance.\n\n"]
    pub fn furi_stream_buffer_reset(stream_buffer: *mut FuriStreamBuffer) -> FuriStatus;
}
extern "C" {
    #[doc = "System Clock Frequency\n\n"]
    pub static mut SystemCoreClock: u32;
}
#[doc = "Comparator\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct COMP_TypeDef {
    #[doc = "COMP control and status register,               Address offset: 0x00\n\n"]
    pub CSR: u32,
}
#[test]
fn bindgen_test_layout_COMP_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<COMP_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<COMP_TypeDef>(),
        4usize,
        concat!("Size of: ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<COMP_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(COMP_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(COMP_TypeDef),
            "::",
            stringify!(CSR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "DMA interrupt status register,                 Address offset: 0x00\n\n"]
    pub ISR: u32,
    #[doc = "DMA interrupt flag clear register,             Address offset: 0x04\n\n"]
    pub IFCR: u32,
}
#[test]
fn bindgen_test_layout_DMA_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<DMA_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMA_TypeDef>(),
        8usize,
        concat!("Size of: ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<DMA_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(DMA_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IFCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DMA_TypeDef),
            "::",
            stringify!(IFCR)
        )
    );
}
#[doc = "General Purpose I/O\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPIO_TypeDef {
    #[doc = "GPIO port mode register,               Address offset: 0x00\n\n"]
    pub MODER: u32,
    #[doc = "GPIO port output type register,        Address offset: 0x04\n\n"]
    pub OTYPER: u32,
    #[doc = "GPIO port output speed register,       Address offset: 0x08\n\n"]
    pub OSPEEDR: u32,
    #[doc = "GPIO port pull-up/pull-down register,  Address offset: 0x0C\n\n"]
    pub PUPDR: u32,
    #[doc = "GPIO port input data register,         Address offset: 0x10\n\n"]
    pub IDR: u32,
    #[doc = "GPIO port output data register,        Address offset: 0x14\n\n"]
    pub ODR: u32,
    #[doc = "GPIO port bit set/reset  register,     Address offset: 0x18\n\n"]
    pub BSRR: u32,
    #[doc = "GPIO port configuration lock register, Address offset: 0x1C\n\n"]
    pub LCKR: u32,
    #[doc = "GPIO alternate function registers,     Address offset: 0x20-0x24\n\n"]
    pub AFR: [u32; 2usize],
    #[doc = "GPIO Bit Reset register,               Address offset: 0x28\n\n"]
    pub BRR: u32,
}
#[test]
fn bindgen_test_layout_GPIO_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<GPIO_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GPIO_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<GPIO_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(GPIO_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(MODER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OTYPER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OTYPER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSPEEDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(OSPEEDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PUPDR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(PUPDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IDR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(IDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ODR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(ODR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BSRR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BSRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LCKR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(LCKR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AFR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(AFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPIO_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
}
#[doc = "Inter-integrated Circuit Interface\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2C_TypeDef {
    #[doc = "I2C Control register 1,            Address offset: 0x00\n\n"]
    pub CR1: u32,
    #[doc = "I2C Control register 2,            Address offset: 0x04\n\n"]
    pub CR2: u32,
    #[doc = "I2C Own address 1 register,        Address offset: 0x08\n\n"]
    pub OAR1: u32,
    #[doc = "I2C Own address 2 register,        Address offset: 0x0C\n\n"]
    pub OAR2: u32,
    #[doc = "I2C Timing register,               Address offset: 0x10\n\n"]
    pub TIMINGR: u32,
    #[doc = "I2C Timeout register,              Address offset: 0x14\n\n"]
    pub TIMEOUTR: u32,
    #[doc = "I2C Interrupt and status register, Address offset: 0x18\n\n"]
    pub ISR: u32,
    #[doc = "I2C Interrupt clear register,      Address offset: 0x1C\n\n"]
    pub ICR: u32,
    #[doc = "I2C PEC register,                  Address offset: 0x20\n\n"]
    pub PECR: u32,
    #[doc = "I2C Receive data register,         Address offset: 0x24\n\n"]
    pub RXDR: u32,
    #[doc = "I2C Transmit data register,        Address offset: 0x28\n\n"]
    pub TXDR: u32,
}
#[test]
fn bindgen_test_layout_I2C_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<I2C_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<I2C_TypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<I2C_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(I2C_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OAR2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(OAR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMINGR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMINGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMEOUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TIMEOUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PECR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(PECR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(RXDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(I2C_TypeDef),
            "::",
            stringify!(TXDR)
        )
    );
}
#[doc = "LPTIMER\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LPTIM_TypeDef {
    #[doc = "LPTIM Interrupt and Status register,                Address offset: 0x00\n\n"]
    pub ISR: u32,
    #[doc = "LPTIM Interrupt Clear register,                     Address offset: 0x04\n\n"]
    pub ICR: u32,
    #[doc = "LPTIM Interrupt Enable register,                    Address offset: 0x08\n\n"]
    pub IER: u32,
    #[doc = "LPTIM Configuration register,                       Address offset: 0x0C\n\n"]
    pub CFGR: u32,
    #[doc = "LPTIM Control register,                             Address offset: 0x10\n\n"]
    pub CR: u32,
    #[doc = "LPTIM Compare register,                             Address offset: 0x14\n\n"]
    pub CMP: u32,
    #[doc = "LPTIM Autoreload register,                          Address offset: 0x18\n\n"]
    pub ARR: u32,
    #[doc = "LPTIM Counter register,                             Address offset: 0x1C\n\n"]
    pub CNT: u32,
    #[doc = "LPTIM Option register,                              Address offset: 0x20\n\n"]
    pub OR: u32,
}
#[test]
fn bindgen_test_layout_LPTIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LPTIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LPTIM_TypeDef>(),
        36usize,
        concat!("Size of: ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LPTIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LPTIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IER) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(IER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CFGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMP) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LPTIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
}
#[doc = "Real-Time Clock\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TypeDef {
    #[doc = "RTC time register,                                         Address offset: 0x00\n\n"]
    pub TR: u32,
    #[doc = "RTC date register,                                         Address offset: 0x04\n\n"]
    pub DR: u32,
    #[doc = "RTC control register,                                      Address offset: 0x08\n\n"]
    pub CR: u32,
    #[doc = "RTC initialization and status register,                    Address offset: 0x0C\n\n"]
    pub ISR: u32,
    #[doc = "RTC prescaler register,                                    Address offset: 0x10\n\n"]
    pub PRER: u32,
    #[doc = "RTC wakeup timer register,                                 Address offset: 0x14\n\n"]
    pub WUTR: u32,
    #[doc = "Reserved,                                                  Address offset: 0x18\n\n"]
    pub RESERVED: u32,
    #[doc = "RTC alarm A register,                                      Address offset: 0x1C\n\n"]
    pub ALRMAR: u32,
    #[doc = "RTC alarm B register,                                      Address offset: 0x20\n\n"]
    pub ALRMBR: u32,
    #[doc = "RTC write protection register,                             Address offset: 0x24\n\n"]
    pub WPR: u32,
    #[doc = "RTC sub second register,                                   Address offset: 0x28\n\n"]
    pub SSR: u32,
    #[doc = "RTC shift control register,                                Address offset: 0x2C\n\n"]
    pub SHIFTR: u32,
    #[doc = "RTC time stamp time register,                              Address offset: 0x30\n\n"]
    pub TSTR: u32,
    #[doc = "RTC time stamp date register,                              Address offset: 0x34\n\n"]
    pub TSDR: u32,
    #[doc = "RTC time-stamp sub second register,                        Address offset: 0x38\n\n"]
    pub TSSSR: u32,
    #[doc = "RTC calibration register,                                  Address offset: 0x3C\n\n"]
    pub CALR: u32,
    #[doc = "RTC tamper configuration register,                         Address offset: 0x40\n\n"]
    pub TAMPCR: u32,
    #[doc = "RTC alarm A sub second register,                           Address offset: 0x44\n\n"]
    pub ALRMASSR: u32,
    #[doc = "RTC alarm B sub second register,                           Address offset: 0x48\n\n"]
    pub ALRMBSSR: u32,
    #[doc = "RTC option register,                                       Address offset  0x4C\n\n"]
    pub OR: u32,
    #[doc = "RTC backup register 0,                                     Address offset: 0x50\n\n"]
    pub BKP0R: u32,
    #[doc = "RTC backup register 1,                                     Address offset: 0x54\n\n"]
    pub BKP1R: u32,
    #[doc = "RTC backup register 2,                                     Address offset: 0x58\n\n"]
    pub BKP2R: u32,
    #[doc = "RTC backup register 3,                                     Address offset: 0x5C\n\n"]
    pub BKP3R: u32,
    #[doc = "RTC backup register 4,                                     Address offset: 0x60\n\n"]
    pub BKP4R: u32,
    #[doc = "RTC backup register 5,                                     Address offset: 0x64\n\n"]
    pub BKP5R: u32,
    #[doc = "RTC backup register 6,                                     Address offset: 0x68\n\n"]
    pub BKP6R: u32,
    #[doc = "RTC backup register 7,                                     Address offset: 0x6C\n\n"]
    pub BKP7R: u32,
    #[doc = "RTC backup register 8,                                     Address offset: 0x70\n\n"]
    pub BKP8R: u32,
    #[doc = "RTC backup register 9,                                     Address offset: 0x74\n\n"]
    pub BKP9R: u32,
    #[doc = "RTC backup register 10,                                    Address offset: 0x78\n\n"]
    pub BKP10R: u32,
    #[doc = "RTC backup register 11,                                    Address offset: 0x7C\n\n"]
    pub BKP11R: u32,
    #[doc = "RTC backup register 12,                                    Address offset: 0x80\n\n"]
    pub BKP12R: u32,
    #[doc = "RTC backup register 13,                                    Address offset: 0x84\n\n"]
    pub BKP13R: u32,
    #[doc = "RTC backup register 14,                                    Address offset: 0x88\n\n"]
    pub BKP14R: u32,
    #[doc = "RTC backup register 15,                                    Address offset: 0x8C\n\n"]
    pub BKP15R: u32,
    #[doc = "RTC backup register 16,                                    Address offset: 0x90\n\n"]
    pub BKP16R: u32,
    #[doc = "RTC backup register 17,                                    Address offset: 0x94\n\n"]
    pub BKP17R: u32,
    #[doc = "RTC backup register 18,                                    Address offset: 0x98\n\n"]
    pub BKP18R: u32,
    #[doc = "RTC backup register 19,                                    Address offset: 0x9C\n\n"]
    pub BKP19R: u32,
}
#[test]
fn bindgen_test_layout_RTC_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TypeDef>(),
        160usize,
        concat!("Size of: ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRER) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(PRER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WUTR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WUTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(RESERVED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMAR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WPR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(WPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHIFTR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(SHIFTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSTR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSDR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TSSSR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TSSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALR) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(CALR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCR) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(TAMPCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMASSR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMASSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALRMBSSR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(ALRMBSSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP0R) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP0R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP1R) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP1R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP2R) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP2R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP3R) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP3R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP4R) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP4R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP5R) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP5R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP6R) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP6R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP7R) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP7R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP8R) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP8R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP9R) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP9R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP10R) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP10R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP11R) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP11R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP12R) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP12R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP13R) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP13R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP14R) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP14R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP15R) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP15R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP16R) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP16R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP17R) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP17R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP18R) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP18R)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKP19R) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TypeDef),
            "::",
            stringify!(BKP19R)
        )
    );
}
#[doc = "Serial Peripheral Interface\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPI_TypeDef {
    #[doc = "SPI Control register 1,       Address offset: 0x00\n\n"]
    pub CR1: u32,
    #[doc = "SPI Control register 2,       Address offset: 0x04\n\n"]
    pub CR2: u32,
    #[doc = "SPI Status register,          Address offset: 0x08\n\n"]
    pub SR: u32,
    #[doc = "SPI data register,            Address offset: 0x0C\n\n"]
    pub DR: u32,
    #[doc = "SPI CRC polynomial register,  Address offset: 0x10\n\n"]
    pub CRCPR: u32,
    #[doc = "SPI Rx CRC register,          Address offset: 0x14\n\n"]
    pub RXCRCR: u32,
    #[doc = "SPI Tx CRC register,          Address offset: 0x18\n\n"]
    pub TXCRCR: u32,
}
#[test]
fn bindgen_test_layout_SPI_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<SPI_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SPI_TypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<SPI_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(SPI_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(DR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(CRCPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXCRCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(RXCRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TXCRCR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPI_TypeDef),
            "::",
            stringify!(TXCRCR)
        )
    );
}
#[doc = "TIM\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIM_TypeDef {
    #[doc = "TIM control register 1,                   Address offset: 0x00\n\n"]
    pub CR1: u32,
    #[doc = "TIM control register 2,                   Address offset: 0x04\n\n"]
    pub CR2: u32,
    #[doc = "TIM slave mode control register,          Address offset: 0x08\n\n"]
    pub SMCR: u32,
    #[doc = "TIM DMA/interrupt enable register,        Address offset: 0x0C\n\n"]
    pub DIER: u32,
    #[doc = "TIM status register,                      Address offset: 0x10\n\n"]
    pub SR: u32,
    #[doc = "TIM event generation register,            Address offset: 0x14\n\n"]
    pub EGR: u32,
    #[doc = "TIM capture/compare mode register 1,      Address offset: 0x18\n\n"]
    pub CCMR1: u32,
    #[doc = "TIM capture/compare mode register 2,      Address offset: 0x1C\n\n"]
    pub CCMR2: u32,
    #[doc = "TIM capture/compare enable register,      Address offset: 0x20\n\n"]
    pub CCER: u32,
    #[doc = "TIM counter register,                     Address offset: 0x24\n\n"]
    pub CNT: u32,
    #[doc = "TIM prescaler register,                   Address offset: 0x28\n\n"]
    pub PSC: u32,
    #[doc = "TIM auto-reload register,                 Address offset: 0x2C\n\n"]
    pub ARR: u32,
    #[doc = "TIM repetition counter register,          Address offset: 0x30\n\n"]
    pub RCR: u32,
    #[doc = "TIM capture/compare register 1,           Address offset: 0x34\n\n"]
    pub CCR1: u32,
    #[doc = "TIM capture/compare register 2,           Address offset: 0x38\n\n"]
    pub CCR2: u32,
    #[doc = "TIM capture/compare register 3,           Address offset: 0x3C\n\n"]
    pub CCR3: u32,
    #[doc = "TIM capture/compare register 4,           Address offset: 0x40\n\n"]
    pub CCR4: u32,
    #[doc = "TIM break and dead-time register,         Address offset: 0x44\n\n"]
    pub BDTR: u32,
    #[doc = "TIM DMA control register,                 Address offset: 0x48\n\n"]
    pub DCR: u32,
    #[doc = "TIM DMA address for full transfer,        Address offset: 0x4C\n\n"]
    pub DMAR: u32,
    #[doc = "TIM option register                       Address offset: 0x50\n\n"]
    pub OR: u32,
    #[doc = "TIM capture/compare mode register 3,      Address offset: 0x54\n\n"]
    pub CCMR3: u32,
    #[doc = "TIM capture/compare register5,            Address offset: 0x58\n\n"]
    pub CCR5: u32,
    #[doc = "TIM capture/compare register6,            Address offset: 0x5C\n\n"]
    pub CCR6: u32,
    #[doc = "TIM Alternate function option register 1, Address offset: 0x60\n\n"]
    pub AF1: u32,
    #[doc = "TIM Alternate function option register 2, Address offset: 0x64\n\n"]
    pub AF2: u32,
}
#[test]
fn bindgen_test_layout_TIM_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<TIM_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TIM_TypeDef>(),
        104usize,
        concat!("Size of: ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<TIM_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(TIM_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SMCR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SMCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIER) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DIER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(SR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EGR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(EGR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCER) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CNT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PSC) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(PSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ARR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(ARR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RCR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(RCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR4) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BDTR) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(BDTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DMAR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(DMAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(OR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCMR3) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCMR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR5) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR6) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(CCR6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AF2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(TIM_TypeDef),
            "::",
            stringify!(AF2)
        )
    );
}
#[doc = "Universal Synchronous Asynchronous Receiver Transmitter\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "USART Control register 1,                 Address offset: 0x00\n\n"]
    pub CR1: u32,
    #[doc = "USART Control register 2,                 Address offset: 0x04\n\n"]
    pub CR2: u32,
    #[doc = "USART Control register 3,                 Address offset: 0x08\n\n"]
    pub CR3: u32,
    #[doc = "USART Baud rate register,                 Address offset: 0x0C\n\n"]
    pub BRR: u32,
    #[doc = "USART Guard time and prescaler register,  Address offset: 0x10\n\n"]
    pub GTPR: u32,
    #[doc = "USART Receiver Time Out register,         Address offset: 0x14\n\n"]
    pub RTOR: u32,
    #[doc = "USART Request register,                   Address offset: 0x18\n\n"]
    pub RQR: u32,
    #[doc = "USART Interrupt and status register,      Address offset: 0x1C\n\n"]
    pub ISR: u32,
    #[doc = "USART Interrupt flag Clear register,      Address offset: 0x20\n\n"]
    pub ICR: u32,
    #[doc = "USART Receive Data register,              Address offset: 0x24\n\n"]
    pub RDR: u32,
    #[doc = "USART Transmit Data register,             Address offset: 0x28\n\n"]
    pub TDR: u32,
    #[doc = "USART Prescaler register,                 Address offset: 0x2C\n\n"]
    pub PRESC: u32,
}
#[test]
fn bindgen_test_layout_USART_TypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<USART_TypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USART_TypeDef>(),
        48usize,
        concat!("Size of: ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<USART_TypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(USART_TypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CR3) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(CR3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BRR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(BRR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GTPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(GTPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTOR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RQR) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RQR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ISR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICR) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(ICR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(RDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TDR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(TDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRESC) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(USART_TypeDef),
            "::",
            stringify!(PRESC)
        )
    );
}
pub const ErrorStatus_SUCCESS: ErrorStatus = 0;
pub const ErrorStatus_ERROR: ErrorStatus = 1;
pub type ErrorStatus = core::ffi::c_uchar;
#[doc = "LL GPIO Init Structure definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_GPIO_InitTypeDef {
    #[doc = "Specifies the GPIO pins to be configured.\nThis parameter can be any value of  [`GPIO_LL_EC_PIN`]\n\n"]
    pub Pin: u32,
    #[doc = "Specifies the operating mode for the selected pins.\nThis parameter can be a value of  [`GPIO_LL_EC_MODE`]\nGPIO HW configuration can be modified afterwards using unitary function  [`LL_GPIO_SetPinMode()`]\n\n"]
    pub Mode: u32,
    #[doc = "Specifies the speed for the selected pins.\nThis parameter can be a value of  [`GPIO_LL_EC_SPEED`]\nGPIO HW configuration can be modified afterwards using unitary function  [`LL_GPIO_SetPinSpeed()`]\n\n"]
    pub Speed: u32,
    #[doc = "Specifies the operating output type for the selected pins.\nThis parameter can be a value of  [`GPIO_LL_EC_OUTPUT`]\nGPIO HW configuration can be modified afterwards using unitary function  [`LL_GPIO_SetPinOutputType()`]\n\n"]
    pub OutputType: u32,
    #[doc = "Specifies the operating Pull-up/Pull down for the selected pins.\nThis parameter can be a value of  [`GPIO_LL_EC_PULL`]\nGPIO HW configuration can be modified afterwards using unitary function  [`LL_GPIO_SetPinPull()`]\n\n"]
    pub Pull: u32,
    #[doc = "Specifies the Peripheral to be connected to the selected pins.\nThis parameter can be a value of  [`GPIO_LL_EC_AF`]\nGPIO HW configuration can be modified afterwards using unitary function  [`LL_GPIO_SetAFPin_0_7()`] and LL_GPIO_SetAFPin_8_15().\n\n"]
    pub Alternate: u32,
}
#[test]
fn bindgen_test_layout_LL_GPIO_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_GPIO_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_GPIO_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_GPIO_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_GPIO_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(OutputType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pull) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Pull)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alternate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_GPIO_InitTypeDef),
            "::",
            stringify!(Alternate)
        )
    );
}
extern "C" {
    pub fn LL_GPIO_Init(
        GPIOx: *mut GPIO_TypeDef,
        GPIO_InitStruct: *mut LL_GPIO_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Interrupt callback prototype\n\n"]
pub type GpioExtiCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
pub const GpioMode_GpioModeInput: GpioMode = 0;
pub const GpioMode_GpioModeOutputPushPull: GpioMode = 1;
pub const GpioMode_GpioModeOutputOpenDrain: GpioMode = 2;
pub const GpioMode_GpioModeAltFunctionPushPull: GpioMode = 3;
pub const GpioMode_GpioModeAltFunctionOpenDrain: GpioMode = 4;
pub const GpioMode_GpioModeAnalog: GpioMode = 5;
pub const GpioMode_GpioModeInterruptRise: GpioMode = 6;
pub const GpioMode_GpioModeInterruptFall: GpioMode = 7;
pub const GpioMode_GpioModeInterruptRiseFall: GpioMode = 8;
pub const GpioMode_GpioModeEventRise: GpioMode = 9;
pub const GpioMode_GpioModeEventFall: GpioMode = 10;
pub const GpioMode_GpioModeEventRiseFall: GpioMode = 11;
#[doc = "Gpio modes\n\n"]
pub type GpioMode = core::ffi::c_uchar;
pub const GpioPull_GpioPullNo: GpioPull = 0;
pub const GpioPull_GpioPullUp: GpioPull = 1;
pub const GpioPull_GpioPullDown: GpioPull = 2;
#[doc = "Gpio pull modes\n\n"]
pub type GpioPull = core::ffi::c_uchar;
pub const GpioSpeed_GpioSpeedLow: GpioSpeed = 0;
pub const GpioSpeed_GpioSpeedMedium: GpioSpeed = 1;
pub const GpioSpeed_GpioSpeedHigh: GpioSpeed = 2;
pub const GpioSpeed_GpioSpeedVeryHigh: GpioSpeed = 3;
#[doc = "Gpio speed modes\n\n"]
pub type GpioSpeed = core::ffi::c_uchar;
#[doc = "MCO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0MCO: GpioAltFn = 0;
#[doc = "LSCO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0LSCO: GpioAltFn = 0;
#[doc = "JTMS-SWDIO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0JTMS_SWDIO: GpioAltFn = 0;
#[doc = "JTCK-SWCLK Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0JTCK_SWCLK: GpioAltFn = 0;
#[doc = "JTDI Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0JTDI: GpioAltFn = 0;
#[doc = "RCT_OUT Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0RTC_OUT: GpioAltFn = 0;
#[doc = "JTDO-TRACESWO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0JTD_TRACE: GpioAltFn = 0;
#[doc = "NJTRST Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0NJTRST: GpioAltFn = 0;
#[doc = "RTC_REFIN Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0RTC_REFIN: GpioAltFn = 0;
#[doc = "TRACED0 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRACED0: GpioAltFn = 0;
#[doc = "TRACED1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRACED1: GpioAltFn = 0;
#[doc = "TRACED2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRACED2: GpioAltFn = 0;
#[doc = "TRACED3 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRACED3: GpioAltFn = 0;
#[doc = "TRIG_INOUT Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRIG_INOUT: GpioAltFn = 0;
#[doc = "TRACECK Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0TRACECK: GpioAltFn = 0;
#[doc = "System Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn0SYS: GpioAltFn = 0;
#[doc = "TIM1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn1TIM1: GpioAltFn = 1;
#[doc = "TIM2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn1TIM2: GpioAltFn = 1;
#[doc = "LPTIM1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn1LPTIM1: GpioAltFn = 1;
#[doc = "TIM2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn2TIM2: GpioAltFn = 2;
#[doc = "TIM1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn2TIM1: GpioAltFn = 2;
#[doc = "SAI1_CK1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn3SAI1: GpioAltFn = 3;
#[doc = "SPI2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn3SPI2: GpioAltFn = 3;
#[doc = "TIM1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn3TIM1: GpioAltFn = 3;
#[doc = "I2C1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn4I2C1: GpioAltFn = 4;
#[doc = "I2C3 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn4I2C3: GpioAltFn = 4;
#[doc = "SPI1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn5SPI1: GpioAltFn = 5;
#[doc = "SPI2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn5SPI2: GpioAltFn = 5;
#[doc = "MCO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6MCO: GpioAltFn = 6;
#[doc = "LSCO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6LSCO: GpioAltFn = 6;
#[doc = "RF_DTB0 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB0: GpioAltFn = 6;
#[doc = "RF_DTB1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB1: GpioAltFn = 6;
#[doc = "RF_DTB2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB2: GpioAltFn = 6;
#[doc = "RF_DTB3 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB3: GpioAltFn = 6;
#[doc = "RF_DTB4 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB4: GpioAltFn = 6;
#[doc = "RF_DTB5 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB5: GpioAltFn = 6;
#[doc = "RF_DTB6 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB6: GpioAltFn = 6;
#[doc = "RF_DTB7 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB7: GpioAltFn = 6;
#[doc = "RF_DTB8 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB8: GpioAltFn = 6;
#[doc = "RF_DTB9 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB9: GpioAltFn = 6;
#[doc = "RF_DTB10 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB10: GpioAltFn = 6;
#[doc = "RF_DTB11 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB11: GpioAltFn = 6;
#[doc = "RF_DTB12 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB12: GpioAltFn = 6;
#[doc = "RF_DTB13 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB13: GpioAltFn = 6;
#[doc = "RF_DTB14 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB14: GpioAltFn = 6;
#[doc = "RF_DTB15 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB15: GpioAltFn = 6;
#[doc = "RF_DTB16 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB16: GpioAltFn = 6;
#[doc = "RF_DTB17 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB17: GpioAltFn = 6;
#[doc = "RF_DTB18 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_DTB18: GpioAltFn = 6;
#[doc = "RF_MISO Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_MISO: GpioAltFn = 6;
#[doc = "RF_MOSI Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_MOSI: GpioAltFn = 6;
#[doc = "RF_SCK Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_SCK: GpioAltFn = 6;
#[doc = "RF_NSS Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn6RF_NSS: GpioAltFn = 6;
#[doc = "USART1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn7USART1: GpioAltFn = 7;
#[doc = "LPUART1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn8LPUART1: GpioAltFn = 8;
#[doc = "IR Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn8IR: GpioAltFn = 8;
#[doc = "TSC Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn9TSC: GpioAltFn = 9;
#[doc = "QUADSPI Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn10QUADSPI: GpioAltFn = 10;
#[doc = "USB Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn10USB: GpioAltFn = 10;
#[doc = "LCD Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn11LCD: GpioAltFn = 11;
#[doc = "COMP1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn12COMP1: GpioAltFn = 12;
#[doc = "COMP2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn12COMP2: GpioAltFn = 12;
#[doc = "TIM1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn12TIM1: GpioAltFn = 12;
#[doc = "SAI1 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn13SAI1: GpioAltFn = 13;
#[doc = "TIM2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn14TIM2: GpioAltFn = 14;
#[doc = "TIM16 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn14TIM16: GpioAltFn = 14;
#[doc = "TIM17 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn14TIM17: GpioAltFn = 14;
#[doc = "LPTIM2 Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn14LPTIM2: GpioAltFn = 14;
#[doc = "EVENTOUT Alternate Function mapping\n\n"]
pub const GpioAltFn_GpioAltFn15EVENTOUT: GpioAltFn = 15;
#[doc = "just dummy value\n\n"]
pub const GpioAltFn_GpioAltFnUnused: GpioAltFn = 16;
#[doc = "Gpio alternate functions\n\n"]
pub type GpioAltFn = core::ffi::c_uchar;
#[doc = "Gpio structure\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPin {
    pub port: *mut GPIO_TypeDef,
    pub pin: u16,
}
#[test]
fn bindgen_test_layout_GpioPin() {
    const UNINIT: ::core::mem::MaybeUninit<GpioPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GpioPin>(),
        8usize,
        concat!("Size of: ", stringify!(GpioPin))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPin>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPin),
            "::",
            stringify!(pin)
        )
    );
}
extern "C" {
    #[doc = "GPIO initialization function, simple version\n\n# Arguments\n\n* `gpio` - GpioPin\n* `mode` - GpioMode\n\n"]
    pub fn furi_hal_gpio_init_simple(gpio: *const GpioPin, mode: GpioMode);
}
extern "C" {
    #[doc = "GPIO initialization function, normal version\n\n# Arguments\n\n* `gpio` - GpioPin\n* `mode` - GpioMode\n* `pull` - GpioPull\n* `speed` - GpioSpeed\n\n"]
    pub fn furi_hal_gpio_init(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
    );
}
extern "C" {
    #[doc = "GPIO initialization function, extended version\n\n# Arguments\n\n* `gpio` - GpioPin\n* `mode` - GpioMode\n* `pull` - GpioPull\n* `speed` - GpioSpeed\n* `alt_fn` - GpioAltFn\n\n"]
    pub fn furi_hal_gpio_init_ex(
        gpio: *const GpioPin,
        mode: GpioMode,
        pull: GpioPull,
        speed: GpioSpeed,
        alt_fn: GpioAltFn,
    );
}
extern "C" {
    #[doc = "Add and enable interrupt\n\n# Arguments\n\n* `gpio` - GpioPin\n* `cb` - GpioExtiCallback\n* `ctx` - context for callback\n\n"]
    pub fn furi_hal_gpio_add_int_callback(
        gpio: *const GpioPin,
        cb: GpioExtiCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Enable interrupt\n\n# Arguments\n\n* `gpio` - GpioPin\n\n"]
    pub fn furi_hal_gpio_enable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = "Disable interrupt\n\n# Arguments\n\n* `gpio` - GpioPin\n\n"]
    pub fn furi_hal_gpio_disable_int_callback(gpio: *const GpioPin);
}
extern "C" {
    #[doc = "Remove interrupt\n\n# Arguments\n\n* `gpio` - GpioPin\n\n"]
    pub fn furi_hal_gpio_remove_int_callback(gpio: *const GpioPin);
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: core::ffi::c_int) -> f32;
}
extern "C" {
    pub fn furi_run();
}
#[doc = "Cortex timer provides high precision low level expiring timer\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCortexTimer {
    pub start: u32,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_FuriHalCortexTimer() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCortexTimer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCortexTimer>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCortexTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalCortexTimer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCortexTimer),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = "Microseconds delay\n\n# Arguments\n\n* `microseconds` - [Direction: In] The microseconds to wait\n\n"]
    pub fn furi_hal_cortex_delay_us(microseconds: u32);
}
extern "C" {
    #[doc = "Get instructions per microsecond count\n\nReturns:\n\n* instructions per microsecond count\n\n"]
    pub fn furi_hal_cortex_instructions_per_microsecond() -> u32;
}
extern "C" {
    #[doc = "Get Timer\n\nReturns:\n\n* The FuriHalCortexTimer\n\n# Arguments\n\n* `timeout_us` - [Direction: In] The expire timeout in us\n\n"]
    pub fn furi_hal_cortex_timer_get(timeout_us: u32) -> FuriHalCortexTimer;
}
extern "C" {
    #[doc = "Check if timer expired\n\nReturns:\n\n* true if expired\n\n# Arguments\n\n* `cortex_timer` - [Direction: In] The FuriHalCortexTimer\n\n"]
    pub fn furi_hal_cortex_timer_is_expired(cortex_timer: FuriHalCortexTimer) -> bool;
}
extern "C" {
    #[doc = "Wait for timer expire\n\n# Arguments\n\n* `cortex_timer` - [Direction: In] The FuriHalCortexTimer\n\n"]
    pub fn furi_hal_cortex_timer_wait(cortex_timer: FuriHalCortexTimer);
}
pub const FuriHalCortexComp_FuriHalCortexComp0: FuriHalCortexComp = 0;
pub const FuriHalCortexComp_FuriHalCortexComp1: FuriHalCortexComp = 1;
pub const FuriHalCortexComp_FuriHalCortexComp2: FuriHalCortexComp = 2;
pub const FuriHalCortexComp_FuriHalCortexComp3: FuriHalCortexComp = 3;
pub type FuriHalCortexComp = core::ffi::c_uchar;
pub const FuriHalCortexCompSize_FuriHalCortexCompSizeWord: FuriHalCortexCompSize = 2;
pub const FuriHalCortexCompSize_FuriHalCortexCompSizeHalfWord: FuriHalCortexCompSize = 1;
pub const FuriHalCortexCompSize_FuriHalCortexCompSizeByte: FuriHalCortexCompSize = 0;
pub type FuriHalCortexCompSize = core::ffi::c_uchar;
pub const FuriHalCortexCompFunction_FuriHalCortexCompFunctionPC: FuriHalCortexCompFunction = 4;
pub const FuriHalCortexCompFunction_FuriHalCortexCompFunctionRead: FuriHalCortexCompFunction = 5;
pub const FuriHalCortexCompFunction_FuriHalCortexCompFunctionWrite: FuriHalCortexCompFunction = 6;
pub const FuriHalCortexCompFunction_FuriHalCortexCompFunctionReadWrite: FuriHalCortexCompFunction =
    6;
pub type FuriHalCortexCompFunction = core::ffi::c_uchar;
extern "C" {
    #[doc = "Enable DWT comparator\nAllows to programmatically set instruction/data breakpoints.\nMore details on how it works can be found in armv7m official documentation: <https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/The-DWT-comparators> <https://developer.arm.com/documentation/ddi0403/d/Debug-Architecture/ARMv7-M-Debug/The-Data-Watchpoint-and-Trace-unit/Comparator-Function-registers--DWT-FUNCTIONn>\n\n# Arguments\n\n* `comp` - [Direction: In] The Comparator\n* `function` - [Direction: In] The Comparator Function to use\n* `value` - [Direction: In] The value\n* `mask` - [Direction: In] The mask\n* `size` - [Direction: In] The size\n\n"]
    pub fn furi_hal_cortex_comp_enable(
        comp: FuriHalCortexComp,
        function: FuriHalCortexCompFunction,
        value: u32,
        mask: u32,
        size: FuriHalCortexCompSize,
    );
}
extern "C" {
    #[doc = "Reset DWT comparator\n\n# Arguments\n\n* `comp` - [Direction: In] The Comparator\n\n"]
    pub fn furi_hal_cortex_comp_reset(comp: FuriHalCortexComp);
}
extern "C" {
    pub fn LL_RCC_GetUSARTClockFreq(USARTxSource: u32) -> u32;
}
extern "C" {
    pub fn LL_RCC_GetLPUARTClockFreq(LPUARTxSource: u32) -> u32;
}
pub const FuriHalClockMcoSourceId_FuriHalClockMcoLse: FuriHalClockMcoSourceId = 0;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoSysclk: FuriHalClockMcoSourceId = 1;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi100k: FuriHalClockMcoSourceId = 2;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi200k: FuriHalClockMcoSourceId = 3;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi400k: FuriHalClockMcoSourceId = 4;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi800k: FuriHalClockMcoSourceId = 5;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi1m: FuriHalClockMcoSourceId = 6;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi2m: FuriHalClockMcoSourceId = 7;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi4m: FuriHalClockMcoSourceId = 8;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi8m: FuriHalClockMcoSourceId = 9;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi16m: FuriHalClockMcoSourceId = 10;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi24m: FuriHalClockMcoSourceId = 11;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi32m: FuriHalClockMcoSourceId = 12;
pub const FuriHalClockMcoSourceId_FuriHalClockMcoMsi48m: FuriHalClockMcoSourceId = 13;
pub type FuriHalClockMcoSourceId = core::ffi::c_uchar;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv1: FuriHalClockMcoDivisorId = 0;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv2: FuriHalClockMcoDivisorId = 268435456;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv4: FuriHalClockMcoDivisorId = 536870912;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv8: FuriHalClockMcoDivisorId = 805306368;
pub const FuriHalClockMcoDivisorId_FuriHalClockMcoDiv16: FuriHalClockMcoDivisorId = 1073741824;
pub type FuriHalClockMcoDivisorId = core::ffi::c_uint;
extern "C" {
    #[doc = "Enable clock output on MCO pin\n\n# Arguments\n\n* `source` - MCO clock source\n* `div` - MCO clock division\n\n"]
    pub fn furi_hal_clock_mco_enable(
        source: FuriHalClockMcoSourceId,
        div: FuriHalClockMcoDivisorId,
    );
}
extern "C" {
    #[doc = "Disable clock output on MCO pin\n\n"]
    pub fn furi_hal_clock_mco_disable();
}
pub const FuriHalBus_FuriHalBusAHB1_GRP1: FuriHalBus = 0;
pub const FuriHalBus_FuriHalBusDMA1: FuriHalBus = 1;
pub const FuriHalBus_FuriHalBusDMA2: FuriHalBus = 2;
pub const FuriHalBus_FuriHalBusDMAMUX1: FuriHalBus = 3;
pub const FuriHalBus_FuriHalBusCRC: FuriHalBus = 4;
pub const FuriHalBus_FuriHalBusTSC: FuriHalBus = 5;
pub const FuriHalBus_FuriHalBusAHB2_GRP1: FuriHalBus = 6;
pub const FuriHalBus_FuriHalBusGPIOA: FuriHalBus = 7;
pub const FuriHalBus_FuriHalBusGPIOB: FuriHalBus = 8;
pub const FuriHalBus_FuriHalBusGPIOC: FuriHalBus = 9;
pub const FuriHalBus_FuriHalBusGPIOD: FuriHalBus = 10;
pub const FuriHalBus_FuriHalBusGPIOE: FuriHalBus = 11;
pub const FuriHalBus_FuriHalBusGPIOH: FuriHalBus = 12;
pub const FuriHalBus_FuriHalBusADC: FuriHalBus = 13;
pub const FuriHalBus_FuriHalBusAES1: FuriHalBus = 14;
pub const FuriHalBus_FuriHalBusAHB3_GRP1: FuriHalBus = 15;
pub const FuriHalBus_FuriHalBusQUADSPI: FuriHalBus = 16;
pub const FuriHalBus_FuriHalBusPKA: FuriHalBus = 17;
pub const FuriHalBus_FuriHalBusAES2: FuriHalBus = 18;
pub const FuriHalBus_FuriHalBusRNG: FuriHalBus = 19;
pub const FuriHalBus_FuriHalBusHSEM: FuriHalBus = 20;
pub const FuriHalBus_FuriHalBusIPCC: FuriHalBus = 21;
pub const FuriHalBus_FuriHalBusFLASH: FuriHalBus = 22;
pub const FuriHalBus_FuriHalBusAPB1_GRP1: FuriHalBus = 23;
pub const FuriHalBus_FuriHalBusTIM2: FuriHalBus = 24;
pub const FuriHalBus_FuriHalBusLCD: FuriHalBus = 25;
pub const FuriHalBus_FuriHalBusSPI2: FuriHalBus = 26;
pub const FuriHalBus_FuriHalBusI2C1: FuriHalBus = 27;
pub const FuriHalBus_FuriHalBusI2C3: FuriHalBus = 28;
pub const FuriHalBus_FuriHalBusCRS: FuriHalBus = 29;
pub const FuriHalBus_FuriHalBusUSB: FuriHalBus = 30;
pub const FuriHalBus_FuriHalBusLPTIM1: FuriHalBus = 31;
pub const FuriHalBus_FuriHalBusAPB1_GRP2: FuriHalBus = 32;
pub const FuriHalBus_FuriHalBusLPUART1: FuriHalBus = 33;
pub const FuriHalBus_FuriHalBusLPTIM2: FuriHalBus = 34;
pub const FuriHalBus_FuriHalBusAPB2_GRP1: FuriHalBus = 35;
pub const FuriHalBus_FuriHalBusTIM1: FuriHalBus = 36;
pub const FuriHalBus_FuriHalBusSPI1: FuriHalBus = 37;
pub const FuriHalBus_FuriHalBusUSART1: FuriHalBus = 38;
pub const FuriHalBus_FuriHalBusTIM16: FuriHalBus = 39;
pub const FuriHalBus_FuriHalBusTIM17: FuriHalBus = 40;
pub const FuriHalBus_FuriHalBusSAI1: FuriHalBus = 41;
pub const FuriHalBus_FuriHalBusAPB3_GRP1: FuriHalBus = 42;
pub const FuriHalBus_FuriHalBusRF: FuriHalBus = 43;
pub const FuriHalBus_FuriHalBusMAX: FuriHalBus = 44;
pub type FuriHalBus = core::ffi::c_uchar;
extern "C" {
    #[doc = "Early initialization\n\n"]
    pub fn furi_hal_bus_init_early();
}
extern "C" {
    #[doc = "Early de-initialization\n\n"]
    pub fn furi_hal_bus_deinit_early();
}
extern "C" {
    #[doc = "Enable a peripheral by turning the clocking on and deasserting the reset.\n\n**Warning!**\n\n* Peripheral must be in disabled state in order to be enabled.\n\n# Arguments\n\n* `[in]` - bus Peripheral to be enabled.\n\n"]
    pub fn furi_hal_bus_enable(bus: FuriHalBus);
}
extern "C" {
    #[doc = "Reset a peripheral by sequentially asserting and deasserting the reset.\n\n**Warning!**\n\n* Peripheral must be in enabled state in order to be reset.\n\n# Arguments\n\n* `[in]` - bus Peripheral to be reset.\n\n"]
    pub fn furi_hal_bus_reset(bus: FuriHalBus);
}
extern "C" {
    #[doc = "Disable a peripheral by turning the clocking off and asserting the reset.\n\n**Warning!**\n\n* Peripheral must be in enabled state in order to be disabled.\n\n# Arguments\n\n* `[in]` - bus Peripheral to be disabled.\n\n"]
    pub fn furi_hal_bus_disable(bus: FuriHalBus);
}
extern "C" {
    #[doc = "Check if peripheral is enabled\n\n**Warning!**\n\n* FuriHalBusAPB3_GRP1 is a special group of shared peripherals, for core1 its clock is always on and the only status we can report is peripheral reset status. Check code and Reference Manual for details.\n\nReturns:\n\n* true if enabled or always enabled, false otherwise\n\n# Arguments\n\n* `bus` - [Direction: In] The peripheral to check\n\n"]
    pub fn furi_hal_bus_is_enabled(bus: FuriHalBus) -> bool;
}
#[doc = "Master key\n\n"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeMaster: FuriHalCryptoKeyType = 0;
#[doc = "Simple unencrypted key\n\n"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeSimple: FuriHalCryptoKeyType = 1;
#[doc = "Encrypted with Master key\n\n"]
pub const FuriHalCryptoKeyType_FuriHalCryptoKeyTypeEncrypted: FuriHalCryptoKeyType = 2;
#[doc = "FuriHalCryptoKey Type\n\n"]
pub type FuriHalCryptoKeyType = core::ffi::c_uchar;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize128: FuriHalCryptoKeySize = 0;
pub const FuriHalCryptoKeySize_FuriHalCryptoKeySize256: FuriHalCryptoKeySize = 1;
#[doc = "FuriHalCryptoKey Size in bits\n\n"]
pub type FuriHalCryptoKeySize = core::ffi::c_uchar;
#[doc = "FuriHalCryptoKey\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalCryptoKey {
    pub type_: FuriHalCryptoKeyType,
    pub size: FuriHalCryptoKeySize,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_FuriHalCryptoKey() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalCryptoKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalCryptoKey>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalCryptoKey>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalCryptoKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalCryptoKey),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "operation successful\n\n"]
pub const FuriHalCryptoGCMState_FuriHalCryptoGCMStateOk: FuriHalCryptoGCMState = 0;
#[doc = "error during encryption/decryption\n\n"]
pub const FuriHalCryptoGCMState_FuriHalCryptoGCMStateError: FuriHalCryptoGCMState = 1;
#[doc = "tags do not match, auth failed\n\n"]
pub const FuriHalCryptoGCMState_FuriHalCryptoGCMStateAuthFailure: FuriHalCryptoGCMState = 2;
#[doc = "FuriHalCryptoGCMState Result of a GCM operation\n\n"]
pub type FuriHalCryptoGCMState = core::ffi::c_uchar;
extern "C" {
    #[doc = "Verify factory provisioned keys\n\nReturns:\n\n* true if all enclave keys are intact, false otherwise\n\n# Arguments\n\n* `keys_nb` - The keys number of\n* `valid_keys_nb` - The valid keys number of\n\n"]
    pub fn furi_hal_crypto_enclave_verify(keys_nb: *mut u8, valid_keys_nb: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Ensure that requested slot and slots before this slot contains keys.\nThis function is used to provision FURI_HAL_CRYPTO_ENCLAVE_UNIQUE_KEY_SLOT. Also you may want to use it to generate some unique keys in user key slot range.\n\n**Warning!**\n\n* Because of the sequential nature of the secure enclave this method will generate key for all slots from FURI_HAL_CRYPTO_ENCLAVE_FACTORY_KEY_SLOT_END to the slot your requested. Keys are generated using on-chip RNG.\n\nReturns:\n\n* true if key exists or created, false if enclave corrupted\n\n# Arguments\n\n* `key_slot` - [Direction: In] The key slot to enclave\n\n"]
    pub fn furi_hal_crypto_enclave_ensure_key(key_slot: u8) -> bool;
}
extern "C" {
    #[doc = "Store key in crypto enclave\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `key` - FuriHalCryptoKey to be stored\n* `slot` - pointer to int where enclave slot will be stored\n\n"]
    pub fn furi_hal_crypto_enclave_store_key(key: *mut FuriHalCryptoKey, slot: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Init AES engine and load key from crypto enclave\n\n**Warning!**\n\n* Use only with furi_hal_crypto_enclave_unload_key()\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `slot` - enclave slot\n* `iv` - [Direction: In] pointer to 16 bytes Initialization Vector data\n\n"]
    pub fn furi_hal_crypto_enclave_load_key(slot: u8, iv: *const u8) -> bool;
}
extern "C" {
    #[doc = "Unload key and deinit AES engine\n\n**Warning!**\n\n* Use only with furi_hal_crypto_enclave_load_key()\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `slot` - enclave slot\n\n"]
    pub fn furi_hal_crypto_enclave_unload_key(slot: u8) -> bool;
}
extern "C" {
    #[doc = "Init AES engine and load supplied key\n\n**Warning!**\n\n* Use only with furi_hal_crypto_unload_key()\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `key` - [Direction: In] pointer to 32 bytes key data\n* `iv` - [Direction: In] pointer to 16 bytes Initialization Vector data\n\n"]
    pub fn furi_hal_crypto_load_key(key: *const u8, iv: *const u8) -> bool;
}
extern "C" {
    #[doc = "Unload key and de-init AES engine\n\n**Warning!**\n\n* Use this function only with furi_hal_crypto_load_key()\n\nReturns:\n\n* true on success\n\n"]
    pub fn furi_hal_crypto_unload_key() -> bool;
}
extern "C" {
    #[doc = "Encrypt data\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `input` - pointer to input data\n* `output` - pointer to output data\n* `size` - input/output buffer size in bytes\n\n"]
    pub fn furi_hal_crypto_encrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
    #[doc = "Decrypt data\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `input` - pointer to input data\n* `output` - pointer to output data\n* `size` - input/output buffer size in bytes\n\n"]
    pub fn furi_hal_crypto_decrypt(input: *const u8, output: *mut u8, size: usize) -> bool;
}
extern "C" {
    #[doc = "Encrypt the input using AES-CTR\nDecryption can be performed by supplying the ciphertext as input. Inits and deinits the AES engine internally.\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `key` - [Direction: In] pointer to 32 bytes key data\n* `iv` - [Direction: In] pointer to 12 bytes Initialization Vector data\n* `input` - [Direction: In] pointer to input data\n* `output` - [Direction: In, Out] pointer to output data\n* `length` - length of the input and output in bytes\n\n"]
    pub fn furi_hal_crypto_ctr(
        key: *const u8,
        iv: *const u8,
        input: *const u8,
        output: *mut u8,
        length: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Encrypt/decrypt the input using AES-GCM\nWhen decrypting the tag generated needs to be compared to the tag attached to the ciphertext in a constant-time fashion. If the tags are not equal, the decryption failed and the plaintext returned needs to be discarded. Inits and deinits the AES engine internally.\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `key` - [Direction: In] pointer to 32 bytes key data\n* `iv` - [Direction: In] pointer to 12 bytes Initialization Vector data\n* `aad` - [Direction: In] pointer to additional authentication data\n* `aad_length` - length of the additional authentication data in bytes\n* `input` - [Direction: In] pointer to input data\n* `output` - [Direction: In, Out] pointer to output data\n* `length` - length of the input and output in bytes\n* `tag` - [Direction: In, Out] pointer to 16 bytes space for the tag\n* `decrypt` - true for decryption, false otherwise\n\n"]
    pub fn furi_hal_crypto_gcm(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *mut u8,
        decrypt: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "Encrypt the input using AES-GCM and generate a tag\nInits and deinits the AES engine internally.\n\nReturns:\n\n* FuriHalCryptoGCMStateOk on success, FuriHalCryptoGCMStateError on failure\n\n# Arguments\n\n* `key` - [Direction: In] pointer to 32 bytes key data\n* `iv` - [Direction: In] pointer to 12 bytes Initialization Vector data\n* `aad` - [Direction: In] pointer to additional authentication data\n* `aad_length` - length of the additional authentication data in bytes\n* `input` - [Direction: In] pointer to input data\n* `output` - [Direction: In, Out] pointer to output data\n* `length` - length of the input and output in bytes\n* `tag` - [Direction: In, Out] pointer to 16 bytes space for the tag\n\n"]
    pub fn furi_hal_crypto_gcm_encrypt_and_tag(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *mut u8,
    ) -> FuriHalCryptoGCMState;
}
extern "C" {
    #[doc = "Decrypt the input using AES-GCM and verify the provided tag\nInits and deinits the AES engine internally.\n\nReturns:\n\n* FuriHalCryptoGCMStateOk on success, FuriHalCryptoGCMStateError on failure, FuriHalCryptoGCMStateAuthFailure if the tag does not match\n\n# Arguments\n\n* `key` - [Direction: In] pointer to 32 bytes key data\n* `iv` - [Direction: In] pointer to 12 bytes Initialization Vector data\n* `aad` - [Direction: In] pointer to additional authentication data\n* `aad_length` - length of the additional authentication data in bytes\n* `input` - [Direction: In] pointer to input data\n* `output` - [Direction: In, Out] pointer to output data\n* `length` - length of the input and output in bytes\n* `tag` - [Direction: In, Out] pointer to 16 bytes tag\n\n"]
    pub fn furi_hal_crypto_gcm_decrypt_and_verify(
        key: *const u8,
        iv: *const u8,
        aad: *const u8,
        aad_length: usize,
        input: *const u8,
        output: *mut u8,
        length: usize,
        tag: *const u8,
    ) -> FuriHalCryptoGCMState;
}
pub type FuriHalConsoleTxCallback = ::core::option::Option<
    unsafe extern "C" fn(buffer: *const u8, size: usize, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_console_init();
}
extern "C" {
    pub fn furi_hal_console_enable();
}
extern "C" {
    pub fn furi_hal_console_disable();
}
extern "C" {
    pub fn furi_hal_console_set_tx_callback(
        callback: FuriHalConsoleTxCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_console_tx(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    pub fn furi_hal_console_tx_with_new_line(buffer: *const u8, buffer_size: usize);
}
extern "C" {
    #[doc = "Printf-like plain uart interface\n\n**Warning!**\n\n* Will not work in ISR context\n\n# Arguments\n\n* `format` - \n* `...` - \n\n"]
    pub fn furi_hal_console_printf(format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn furi_hal_console_puts(data: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Enable MCU debug\n\n"]
    pub fn furi_hal_debug_enable();
}
extern "C" {
    #[doc = "Disable MCU debug\n\n"]
    pub fn furi_hal_debug_disable();
}
extern "C" {
    #[doc = "Check if GDB debug session is active\n\n"]
    pub fn furi_hal_debug_is_gdb_session_active() -> bool;
}
extern "C" {
    #[doc = "Early initialization\n\n"]
    pub fn furi_hal_dma_init_early();
}
extern "C" {
    #[doc = "Early de-initialization\n\n"]
    pub fn furi_hal_dma_deinit_early();
}
extern "C" {
    pub fn furi_hal_os_tick();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSdInfo {
    #[doc = "total capacity in bytes\n\n"]
    pub capacity: u64,
    #[doc = "block size\n\n"]
    pub block_size: u32,
    #[doc = "logical capacity in blocks\n\n"]
    pub logical_block_count: u32,
    #[doc = "logical block size in bytes\n\n"]
    pub logical_block_size: u32,
    #[doc = "manufacturer ID\n\n"]
    pub manufacturer_id: u8,
    #[doc = "OEM ID, 2 characters + null terminator\n\n"]
    pub oem_id: [core::ffi::c_char; 3usize],
    #[doc = "product name, 5 characters + null terminator\n\n"]
    pub product_name: [core::ffi::c_char; 6usize],
    #[doc = "product revision major\n\n"]
    pub product_revision_major: u8,
    #[doc = "product revision minor\n\n"]
    pub product_revision_minor: u8,
    #[doc = "product serial number\n\n"]
    pub product_serial_number: u32,
    #[doc = "manufacturing month\n\n"]
    pub manufacturing_month: u8,
    #[doc = "manufacturing year\n\n"]
    pub manufacturing_year: u16,
}
#[test]
fn bindgen_test_layout_FuriHalSdInfo() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSdInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSdInfo>(),
        40usize,
        concat!("Size of: ", stringify!(FuriHalSdInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSdInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FuriHalSdInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logical_block_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(logical_block_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logical_block_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(logical_block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer_id) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(manufacturer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oem_id) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(oem_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(product_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_major) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(product_revision_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_minor) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(product_revision_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_serial_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(product_serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_month) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(manufacturing_month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_year) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSdInfo),
            "::",
            stringify!(manufacturing_year)
        )
    );
}
extern "C" {
    #[doc = "Init SD card presence detection\n\n"]
    pub fn furi_hal_sd_presence_init();
}
extern "C" {
    #[doc = "Get SD card status\n\nReturns:\n\n* true if SD card is present\n\n"]
    pub fn furi_hal_sd_is_present() -> bool;
}
extern "C" {
    #[doc = "SD card max mount retry count\n\nReturns:\n\n* uint8_t\n\n"]
    pub fn furi_hal_sd_max_mount_retry_count() -> u8;
}
extern "C" {
    #[doc = "Init SD card\n\nReturns:\n\n* FuriStatus\n\n# Arguments\n\n* `power_reset` - reset card power\n\n"]
    pub fn furi_hal_sd_init(power_reset: bool) -> FuriStatus;
}
extern "C" {
    #[doc = "Read blocks from SD card\n\nReturns:\n\n* FuriStatus\n\n# Arguments\n\n* `buff` - \n* `sector` - \n* `count` - \n\n"]
    pub fn furi_hal_sd_read_blocks(buff: *mut u32, sector: u32, count: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Write blocks to SD card\n\nReturns:\n\n* FuriStatus\n\n# Arguments\n\n* `buff` - \n* `sector` - \n* `count` - \n\n"]
    pub fn furi_hal_sd_write_blocks(buff: *const u32, sector: u32, count: u32) -> FuriStatus;
}
extern "C" {
    #[doc = "Get SD card info\n\nReturns:\n\n* FuriStatus\n\n# Arguments\n\n* `info` - \n\n"]
    pub fn furi_hal_sd_info(info: *mut FuriHalSdInfo) -> FuriStatus;
}
extern "C" {
    #[doc = "Get SD card state\n\nReturns:\n\n* FuriStatus\n\n"]
    pub fn furi_hal_sd_get_card_state() -> FuriStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_I2C_InitTypeDef {
    #[doc = "Specifies the peripheral mode.\nThis parameter can be a value of  [`I2C_LL_EC_PERIPHERAL_MODE`]\nThis feature can be modified afterwards using unitary function [`LL_I2C_SetMode()`]\n\n"]
    pub PeripheralMode: u32,
    #[doc = "Specifies the SDA setup, hold time and the SCL high, low period values.\nThis parameter must be set by referring to the STM32CubeMX Tool and\nthe helper macro  [`__LL_I2C_CONVERT_TIMINGS()`]\nThis feature can be modified afterwards using unitary function [`LL_I2C_SetTiming()`]\n\n"]
    pub Timing: u32,
    #[doc = "Enables or disables analog noise filter.\nThis parameter can be a value of  [`I2C_LL_EC_ANALOGFILTER_SELECTION`]\nThis feature can be modified afterwards using unitary functions [`LL_I2C_EnableAnalogFilter()`] or LL_I2C_DisableAnalogFilter().\n\n"]
    pub AnalogFilter: u32,
    #[doc = "Configures the digital noise filter.\nThis parameter can be a number between Min_Data = 0x00 and Max_Data = 0x0F.\nThis feature can be modified afterwards using unitary function [`LL_I2C_SetDigitalFilter()`]\n\n"]
    pub DigitalFilter: u32,
    #[doc = "Specifies the device own address 1.\nThis parameter must be a value between Min_Data = 0x00 and Max_Data = 0x3FF.\nThis feature can be modified afterwards using unitary function [`LL_I2C_SetOwnAddress1()`]\n\n"]
    pub OwnAddress1: u32,
    #[doc = "Specifies the ACKnowledge or Non ACKnowledge condition after the address receive\nmatch code or next received byte.\nThis parameter can be a value of  [`I2C_LL_EC_I2C_ACKNOWLEDGE`]\nThis feature can be modified afterwards using unitary function [`LL_I2C_AcknowledgeNextData()`]\n\n"]
    pub TypeAcknowledge: u32,
    #[doc = "Specifies the device own address 1 size (7-bit or 10-bit).\nThis parameter can be a value of  [`I2C_LL_EC_OWNADDRESS1`]\nThis feature can be modified afterwards using unitary function [`LL_I2C_SetOwnAddress1()`]\n\n"]
    pub OwnAddrSize: u32,
}
#[test]
fn bindgen_test_layout_LL_I2C_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_I2C_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_I2C_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_I2C_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_I2C_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeripheralMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(PeripheralMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(Timing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AnalogFilter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(AnalogFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DigitalFilter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(DigitalFilter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddress1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddress1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TypeAcknowledge) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(TypeAcknowledge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnAddrSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_I2C_InitTypeDef),
            "::",
            stringify!(OwnAddrSize)
        )
    );
}
extern "C" {
    pub fn LL_I2C_Init(
        I2Cx: *mut I2C_TypeDef,
        I2C_InitStruct: *const LL_I2C_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Bus initialization event, called on system start\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventInit: FuriHalI2cBusEvent = 0;
#[doc = "Bus deinitialization event, called on system stop\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeinit: FuriHalI2cBusEvent = 1;
#[doc = "Bus lock event, called before activation\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventLock: FuriHalI2cBusEvent = 2;
#[doc = "Bus unlock event, called after deactivation\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventUnlock: FuriHalI2cBusEvent = 3;
#[doc = "Bus activation event, called before handle activation\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventActivate: FuriHalI2cBusEvent = 4;
#[doc = "Bus deactivation event, called after handle deactivation\n\n"]
pub const FuriHalI2cBusEvent_FuriHalI2cBusEventDeactivate: FuriHalI2cBusEvent = 5;
#[doc = "FuriHal i2c bus states\n\n"]
pub type FuriHalI2cBusEvent = core::ffi::c_uchar;
#[doc = "FuriHal i2c bus event callback\n\n"]
pub type FuriHalI2cBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalI2cBus, event: FuriHalI2cBusEvent),
>;
#[doc = "FuriHal i2c bus\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBus {
    pub i2c: *mut I2C_TypeDef,
    pub current_handle: *mut FuriHalI2cBusHandle,
    pub callback: FuriHalI2cBusEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBus>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBus>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(current_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBus),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = "Handle activate: connect gpio and apply bus config\n\n"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventActivate: FuriHalI2cBusHandleEvent = 0;
#[doc = "Handle deactivate: disconnect gpio and reset bus config\n\n"]
pub const FuriHalI2cBusHandleEvent_FuriHalI2cBusHandleEventDeactivate: FuriHalI2cBusHandleEvent = 1;
#[doc = "FuriHal i2c handle states\n\n"]
pub type FuriHalI2cBusHandleEvent = core::ffi::c_uchar;
#[doc = "FuriHal i2c handle event callback\n\n"]
pub type FuriHalI2cBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalI2cBusHandle, event: FuriHalI2cBusHandleEvent),
>;
#[doc = "FuriHal i2c handle\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalI2cBusHandle {
    pub bus: *mut FuriHalI2cBus,
    pub callback: FuriHalI2cBusHandleEventCallback,
}
#[test]
fn bindgen_test_layout_FuriHalI2cBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalI2cBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalI2cBusHandle>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalI2cBusHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalI2cBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalI2cBusHandle),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[doc = "Internal(power) i2c bus, I2C1, under reset when not used\n\n"]
    pub static mut furi_hal_i2c_bus_power: FuriHalI2cBus;
}
extern "C" {
    #[doc = "External i2c bus, I2C3, under reset when not used\n\n"]
    pub static mut furi_hal_i2c_bus_external: FuriHalI2cBus;
}
extern "C" {
    #[doc = "Handle for internal(power) i2c bus Bus: furi_hal_i2c_bus_external Pins: PA9(SCL) / PA10(SDA), float on release Params: 400khz\n\n"]
    pub static mut furi_hal_i2c_handle_power: FuriHalI2cBusHandle;
}
extern "C" {
    #[doc = "Handle for external i2c bus Bus: furi_hal_i2c_bus_external Pins: PC0(SCL) / PC1(SDA), float on release Params: 100khz\n\n"]
    pub static mut furi_hal_i2c_handle_external: FuriHalI2cBusHandle;
}
#[doc = "Begin the transaction by sending a START condition followed by the address\n\n"]
pub const FuriHalI2cBegin_FuriHalI2cBeginStart: FuriHalI2cBegin = 0;
#[doc = "Begin the transaction by sending a RESTART condition followed by the address\n\n# Notes\n\n* Must follow a transaction ended with FuriHalI2cEndAwaitRestart\n\n"]
pub const FuriHalI2cBegin_FuriHalI2cBeginRestart: FuriHalI2cBegin = 1;
#[doc = "Continue the previous transaction with new data\n\n# Notes\n\n* Must follow a transaction ended with FuriHalI2cEndPause and be of the same type (RX/TX)\n\n"]
pub const FuriHalI2cBegin_FuriHalI2cBeginResume: FuriHalI2cBegin = 2;
#[doc = "Transaction beginning signal\n\n"]
pub type FuriHalI2cBegin = core::ffi::c_uchar;
#[doc = "End the transaction by sending a STOP condition\n\n"]
pub const FuriHalI2cEnd_FuriHalI2cEndStop: FuriHalI2cEnd = 0;
#[doc = "End the transaction by clock stretching\n\n# Notes\n\n* Must be followed by a transaction using FuriHalI2cBeginRestart\n\n"]
pub const FuriHalI2cEnd_FuriHalI2cEndAwaitRestart: FuriHalI2cEnd = 1;
#[doc = "Pauses the transaction by clock stretching\n\n# Notes\n\n* Must be followed by a transaction using FuriHalI2cBeginResume\n\n"]
pub const FuriHalI2cEnd_FuriHalI2cEndPause: FuriHalI2cEnd = 2;
#[doc = "Transaction end signal\n\n"]
pub type FuriHalI2cEnd = core::ffi::c_uchar;
extern "C" {
    #[doc = "Acquire I2C bus handle\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n\n"]
    pub fn furi_hal_i2c_acquire(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = "Release I2C bus handle\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance acquired in `furi_hal_i2c_acquire`\n\n"]
    pub fn furi_hal_i2c_release(handle: *mut FuriHalI2cBusHandle);
}
extern "C" {
    #[doc = "Perform I2C TX transfer\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `address` - I2C slave address\n* `data` - Pointer to data buffer\n* `size` - Size of data buffer\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_tx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *const u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C TX transfer, with additional settings.\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `address` - I2C slave address\n* `ten_bit` - Whether the address is 10 bits wide\n* `data` - Pointer to data buffer\n* `size` - Size of data buffer\n* `begin` - How to begin the transaction\n* `end` - How to end the transaction\n* `timer` - Timeout timer\n\n"]
    pub fn furi_hal_i2c_tx_ext(
        handle: *mut FuriHalI2cBusHandle,
        address: u16,
        ten_bit: bool,
        data: *const u8,
        size: usize,
        begin: FuriHalI2cBegin,
        end: FuriHalI2cEnd,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C RX transfer\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `address` - I2C slave address\n* `data` - Pointer to data buffer\n* `size` - Size of data buffer\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_rx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        data: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C RX transfer, with additional settings.\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `address` - I2C slave address\n* `ten_bit` - Whether the address is 10 bits wide\n* `data` - Pointer to data buffer\n* `size` - Size of data buffer\n* `begin` - How to begin the transaction\n* `end` - How to end the transaction\n* `timer` - Timeout timer\n\n"]
    pub fn furi_hal_i2c_rx_ext(
        handle: *mut FuriHalI2cBusHandle,
        address: u16,
        ten_bit: bool,
        data: *mut u8,
        size: usize,
        begin: FuriHalI2cBegin,
        end: FuriHalI2cEnd,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C TX and RX transfers\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `address` - I2C slave address\n* `tx_data` - Pointer to TX data buffer\n* `tx_size` - Size of TX data buffer\n* `rx_data` - Pointer to RX data buffer\n* `rx_size` - Size of RX data buffer\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_trx(
        handle: *mut FuriHalI2cBusHandle,
        address: u8,
        tx_data: *const u8,
        tx_size: usize,
        rx_data: *mut u8,
        rx_size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Check if I2C device presents on bus\n\nReturns:\n\n* true if device present and is ready, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_is_device_ready(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device register read (8-bit)\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `reg_addr` - Register address\n* `data` - Pointer to register value\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_read_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device register read (16-bit)\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `reg_addr` - Register address\n* `data` - Pointer to register value\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_read_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: *mut u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device memory read\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `mem_addr` - Memory start address\n* `data` - Pointer to data buffer\n* `len` - Size of data buffer\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_read_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *mut u8,
        len: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device register write (8-bit)\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `reg_addr` - Register address\n* `data` - Register value\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_write_reg_8(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u8,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device register write (16-bit)\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `reg_addr` - Register address\n* `data` - Register value\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_write_reg_16(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        reg_addr: u8,
        data: u16,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Perform I2C device memory\n\nReturns:\n\n* true on successful transfer, false otherwise\n\n# Arguments\n\n* `handle` - Pointer to FuriHalI2cBusHandle instance\n* `i2c_addr` - I2C slave address\n* `mem_addr` - Memory start address\n* `data` - Pointer to data buffer\n* `len` - Size of data buffer\n* `timeout` - Timeout in milliseconds\n\n"]
    pub fn furi_hal_i2c_write_mem(
        handle: *mut FuriHalI2cBusHandle,
        i2c_addr: u8,
        mem_addr: u8,
        data: *const u8,
        len: usize,
        timeout: u32,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRegionBand {
    pub start: u32,
    pub end: u32,
    pub power_limit: i8,
    pub duty_cycle: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRegionBand() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegionBand> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegionBand>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegionBand>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegionBand))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_limit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(power_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duty_cycle) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegionBand),
            "::",
            stringify!(duty_cycle)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct FuriHalRegion {
    pub country_code: [core::ffi::c_char; 4usize],
    pub bands_count: u16,
    pub bands: __IncompleteArrayField<FuriHalRegionBand>,
}
#[test]
fn bindgen_test_layout_FuriHalRegion() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRegion>(),
        8usize,
        concat!("Size of: ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRegion>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bands) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRegion),
            "::",
            stringify!(bands)
        )
    );
}
extern "C" {
    #[doc = "Get Region Data.\nRegion data may be allocated in Flash or in RAM. Keep in mind that we don't do memory management on our side.\n\nReturns:\n\n* pointer to FuriHalRegion instance (in RAM or Flash, check before freeing on region update)\n\n"]
    pub fn furi_hal_region_get() -> *const FuriHalRegion;
}
extern "C" {
    #[doc = "Set device region data\n\n# Arguments\n\n* `region` - pointer to the FuriHalRegion\n\n"]
    pub fn furi_hal_region_set(region: *mut FuriHalRegion);
}
extern "C" {
    #[doc = "Check if region data provisioned\n\nReturns:\n\n* true if provisioned, false otherwise\n\n"]
    pub fn furi_hal_region_is_provisioned() -> bool;
}
extern "C" {
    #[doc = "Get region name\n2 letter Region code according to iso 3166 standard There are 2 extra values that we use in special cases:\n* \"00\" - developer edition, unlocked\n* \"WW\" - world wide, region provisioned by default\n* \"--\" - no provisioned region\n\nReturns:\n\n* Pointer to string\n\n"]
    pub fn furi_hal_region_get_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Сheck if transmission is allowed on this frequency for your flipper region\n\nReturns:\n\n* true if allowed\n\n# Arguments\n\n* `frequency` - [Direction: In] The frequency\n* `value` - frequency in Hz\n\n"]
    pub fn furi_hal_region_is_frequency_allowed(frequency: u32) -> bool;
}
extern "C" {
    #[doc = "Get band data for frequency\n\nReturns:\n\n* { description_of_the_return_value }\n\n# Arguments\n\n* `frequency` - [Direction: In] The frequency\n\n"]
    pub fn furi_hal_region_get_band(frequency: u32) -> *const FuriHalRegionBand;
}
pub const InputKey_InputKeyUp: InputKey = 0;
pub const InputKey_InputKeyDown: InputKey = 1;
pub const InputKey_InputKeyRight: InputKey = 2;
pub const InputKey_InputKeyLeft: InputKey = 3;
pub const InputKey_InputKeyOk: InputKey = 4;
pub const InputKey_InputKeyBack: InputKey = 5;
#[doc = "Special value\n\n"]
pub const InputKey_InputKeyMAX: InputKey = 6;
pub type InputKey = core::ffi::c_uchar;
pub const Light_LightRed: Light = 1;
pub const Light_LightGreen: Light = 2;
pub const Light_LightBlue: Light = 4;
pub const Light_LightBacklight: Light = 8;
pub type Light = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InputPin {
    pub gpio: *const GpioPin,
    pub key: InputKey,
    pub inverted: bool,
    pub name: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InputPin() {
    const UNINIT: ::core::mem::MaybeUninit<InputPin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputPin>(),
        12usize,
        concat!("Size of: ", stringify!(InputPin))
    );
    assert_eq!(
        ::core::mem::align_of::<InputPin>(),
        4usize,
        concat!("Alignment of ", stringify!(InputPin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(gpio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inverted) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(inverted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InputPin),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GpioPinRecord {
    pub pin: *const GpioPin,
    pub name: *const core::ffi::c_char,
    pub number: u8,
    pub debug: bool,
}
#[test]
fn bindgen_test_layout_GpioPinRecord() {
    const UNINIT: ::core::mem::MaybeUninit<GpioPinRecord> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GpioPinRecord>(),
        12usize,
        concat!("Size of: ", stringify!(GpioPinRecord))
    );
    assert_eq!(
        ::core::mem::align_of::<GpioPinRecord>(),
        4usize,
        concat!("Alignment of ", stringify!(GpioPinRecord))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(GpioPinRecord),
            "::",
            stringify!(debug)
        )
    );
}
extern "C" {
    pub static input_pins: [InputPin; 0usize];
}
extern "C" {
    pub static input_pins_count: usize;
}
extern "C" {
    pub static gpio_pins: [GpioPinRecord; 0usize];
}
extern "C" {
    pub static gpio_pins_count: usize;
}
extern "C" {
    pub static gpio_swdio: GpioPin;
}
extern "C" {
    pub static gpio_swclk: GpioPin;
}
extern "C" {
    pub static gpio_vibro: GpioPin;
}
extern "C" {
    pub static gpio_ibutton: GpioPin;
}
extern "C" {
    pub static gpio_cc1101_g0: GpioPin;
}
extern "C" {
    pub static gpio_rf_sw_0: GpioPin;
}
extern "C" {
    pub static gpio_subghz_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_cs: GpioPin;
}
extern "C" {
    pub static gpio_display_rst_n: GpioPin;
}
extern "C" {
    pub static gpio_display_di: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cs: GpioPin;
}
extern "C" {
    pub static gpio_sdcard_cd: GpioPin;
}
extern "C" {
    pub static gpio_nfc_cs: GpioPin;
}
extern "C" {
    pub static gpio_button_up: GpioPin;
}
extern "C" {
    pub static gpio_button_down: GpioPin;
}
extern "C" {
    pub static gpio_button_right: GpioPin;
}
extern "C" {
    pub static gpio_button_left: GpioPin;
}
extern "C" {
    pub static gpio_button_ok: GpioPin;
}
extern "C" {
    pub static gpio_button_back: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_d_sck: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_miso: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_mosi: GpioPin;
}
extern "C" {
    pub static gpio_spi_r_sck: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc0: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc1: GpioPin;
}
extern "C" {
    pub static gpio_ext_pc3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb2: GpioPin;
}
extern "C" {
    pub static gpio_ext_pb3: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa4: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa6: GpioPin;
}
extern "C" {
    pub static gpio_ext_pa7: GpioPin;
}
extern "C" {
    pub static gpio_nfc_irq_rfid_pull: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier_out: GpioPin;
}
extern "C" {
    pub static gpio_rfid_data_in: GpioPin;
}
extern "C" {
    pub static gpio_rfid_carrier: GpioPin;
}
extern "C" {
    pub static gpio_infrared_rx: GpioPin;
}
extern "C" {
    pub static gpio_infrared_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_tx: GpioPin;
}
extern "C" {
    pub static gpio_usart_rx: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_sda: GpioPin;
}
extern "C" {
    pub static gpio_i2c_power_scl: GpioPin;
}
extern "C" {
    pub static gpio_speaker: GpioPin;
}
extern "C" {
    pub static gpio_periph_power: GpioPin;
}
extern "C" {
    pub static gpio_usb_dm: GpioPin;
}
extern "C" {
    pub static gpio_usb_dp: GpioPin;
}
extern "C" {
    #[doc = "Get a corresponding external connector pin number for a gpio\n\nReturns:\n\n* pin number or -1 if gpio is not on the external connector\n\n# Arguments\n\n* `gpio` - GpioPin\n\n"]
    pub fn furi_hal_resources_get_ext_pin_number(gpio: *const GpioPin) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalRtcDateTime {
    #[doc = "Hour in 24H format: 0-23\n\n"]
    pub hour: u8,
    #[doc = "Minute: 0-59\n\n"]
    pub minute: u8,
    #[doc = "Second: 0-59\n\n"]
    pub second: u8,
    #[doc = "Current day: 1-31\n\n"]
    pub day: u8,
    #[doc = "Current month: 1-12\n\n"]
    pub month: u8,
    #[doc = "Current year: 2000-2099\n\n"]
    pub year: u16,
    #[doc = "Current weekday: 1-7\n\n"]
    pub weekday: u8,
}
#[test]
fn bindgen_test_layout_FuriHalRtcDateTime() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalRtcDateTime> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalRtcDateTime>(),
        10usize,
        concat!("Size of: ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalRtcDateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(FuriHalRtcDateTime))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).weekday) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalRtcDateTime),
            "::",
            stringify!(weekday)
        )
    );
}
pub const FuriHalRtcFlag_FuriHalRtcFlagDebug: FuriHalRtcFlag = 1;
pub const FuriHalRtcFlag_FuriHalRtcFlagFactoryReset: FuriHalRtcFlag = 2;
pub const FuriHalRtcFlag_FuriHalRtcFlagLock: FuriHalRtcFlag = 4;
pub const FuriHalRtcFlag_FuriHalRtcFlagC2Update: FuriHalRtcFlag = 8;
pub const FuriHalRtcFlag_FuriHalRtcFlagHandOrient: FuriHalRtcFlag = 16;
pub const FuriHalRtcFlag_FuriHalRtcFlagLegacySleep: FuriHalRtcFlag = 32;
pub const FuriHalRtcFlag_FuriHalRtcFlagStealthMode: FuriHalRtcFlag = 64;
pub const FuriHalRtcFlag_FuriHalRtcFlagRandomFilename: FuriHalRtcFlag = 128;
pub type FuriHalRtcFlag = core::ffi::c_uchar;
#[doc = "Normal boot mode, default value\n\n"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeNormal: FuriHalRtcBootMode = 0;
#[doc = "Boot to DFU (MCU bootloader by ST)\n\n"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeDfu: FuriHalRtcBootMode = 1;
#[doc = "Boot to Update, pre update\n\n"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePreUpdate: FuriHalRtcBootMode = 2;
#[doc = "Boot to Update, main\n\n"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModeUpdate: FuriHalRtcBootMode = 3;
#[doc = "Boot to Update, post update\n\n"]
pub const FuriHalRtcBootMode_FuriHalRtcBootModePostUpdate: FuriHalRtcBootMode = 4;
pub type FuriHalRtcBootMode = core::ffi::c_uchar;
#[doc = "Disable allocation tracking\n\n"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeNone: FuriHalRtcHeapTrackMode = 0;
#[doc = "Enable allocation tracking for main application thread\n\n"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeMain: FuriHalRtcHeapTrackMode = 1;
#[doc = "Enable allocation tracking for main and children application threads\n\n"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeTree: FuriHalRtcHeapTrackMode = 2;
#[doc = "Enable allocation tracking for all threads\n\n"]
pub const FuriHalRtcHeapTrackMode_FuriHalRtcHeapTrackModeAll: FuriHalRtcHeapTrackMode = 3;
pub type FuriHalRtcHeapTrackMode = core::ffi::c_uchar;
#[doc = "RTC structure header\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterHeader: FuriHalRtcRegister = 0;
#[doc = "Various system bits\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterSystem: FuriHalRtcRegister = 1;
#[doc = "Pointer to Version\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterVersion: FuriHalRtcRegister = 2;
#[doc = "LFS geometry fingerprint\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterLfsFingerprint: FuriHalRtcRegister = 3;
#[doc = "Pointer to last fault message\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterFaultData: FuriHalRtcRegister = 4;
#[doc = "Failed pins count\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterPinFails: FuriHalRtcRegister = 5;
pub const FuriHalRtcRegister_FuriHalRtcRegisterUpdateFolderFSIndex: FuriHalRtcRegister = 6;
#[doc = "Service value, do not use\n\n"]
pub const FuriHalRtcRegister_FuriHalRtcRegisterMAX: FuriHalRtcRegister = 7;
pub type FuriHalRtcRegister = core::ffi::c_uchar;
#[doc = "Metric measurement units\n\n"]
pub const FuriHalRtcLocaleUnits_FuriHalRtcLocaleUnitsMetric: FuriHalRtcLocaleUnits = 0;
#[doc = "Imperial measurement units\n\n"]
pub const FuriHalRtcLocaleUnits_FuriHalRtcLocaleUnitsImperial: FuriHalRtcLocaleUnits = 1;
pub type FuriHalRtcLocaleUnits = core::ffi::c_uchar;
#[doc = "24-hour format\n\n"]
pub const FuriHalRtcLocaleTimeFormat_FuriHalRtcLocaleTimeFormat24h: FuriHalRtcLocaleTimeFormat = 0;
#[doc = "12-hour format\n\n"]
pub const FuriHalRtcLocaleTimeFormat_FuriHalRtcLocaleTimeFormat12h: FuriHalRtcLocaleTimeFormat = 1;
pub type FuriHalRtcLocaleTimeFormat = core::ffi::c_uchar;
#[doc = "Day/Month/Year\n\n"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatDMY: FuriHalRtcLocaleDateFormat = 0;
#[doc = "Month/Day/Year\n\n"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatMDY: FuriHalRtcLocaleDateFormat = 1;
#[doc = "Year/Month/Day\n\n"]
pub const FuriHalRtcLocaleDateFormat_FuriHalRtcLocaleDateFormatYMD: FuriHalRtcLocaleDateFormat = 2;
pub type FuriHalRtcLocaleDateFormat = core::ffi::c_uchar;
extern "C" {
    #[doc = "Force sync shadow registers\n\n"]
    pub fn furi_hal_rtc_sync_shadow();
}
extern "C" {
    #[doc = "Get RTC register content\n\nReturns:\n\n* content of the register\n\n# Arguments\n\n* `reg` - [Direction: In] The register identifier\n\n"]
    pub fn furi_hal_rtc_get_register(reg: FuriHalRtcRegister) -> u32;
}
extern "C" {
    #[doc = "Set register content\n\n# Arguments\n\n* `reg` - [Direction: In] The register identifier\n* `value` - [Direction: In] The value to store into register\n\n"]
    pub fn furi_hal_rtc_set_register(reg: FuriHalRtcRegister, value: u32);
}
extern "C" {
    #[doc = "Set Log Level value\n\n# Arguments\n\n* `level` - [Direction: In] The level to store\n\n"]
    pub fn furi_hal_rtc_set_log_level(level: u8);
}
extern "C" {
    #[doc = "Get Log Level value\n\nReturns:\n\n* The Log Level value\n\n"]
    pub fn furi_hal_rtc_get_log_level() -> u8;
}
extern "C" {
    #[doc = "Set RTC Flag\n\n# Arguments\n\n* `flag` - [Direction: In] The flag to set\n\n"]
    pub fn furi_hal_rtc_set_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    #[doc = "Reset RTC Flag\n\n# Arguments\n\n* `flag` - [Direction: In] The flag to reset\n\n"]
    pub fn furi_hal_rtc_reset_flag(flag: FuriHalRtcFlag);
}
extern "C" {
    #[doc = "Check if RTC Flag is set\n\nReturns:\n\n* true if set\n\n# Arguments\n\n* `flag` - [Direction: In] The flag to check\n\n"]
    pub fn furi_hal_rtc_is_flag_set(flag: FuriHalRtcFlag) -> bool;
}
extern "C" {
    #[doc = "Set RTC boot mode\n\n# Arguments\n\n* `mode` - [Direction: In] The mode to set\n\n"]
    pub fn furi_hal_rtc_set_boot_mode(mode: FuriHalRtcBootMode);
}
extern "C" {
    #[doc = "Get RTC boot mode\n\nReturns:\n\n* The RTC boot mode.\n\n"]
    pub fn furi_hal_rtc_get_boot_mode() -> FuriHalRtcBootMode;
}
extern "C" {
    #[doc = "Set Heap Track mode\n\n# Arguments\n\n* `mode` - [Direction: In] The mode to set\n\n"]
    pub fn furi_hal_rtc_set_heap_track_mode(mode: FuriHalRtcHeapTrackMode);
}
extern "C" {
    #[doc = "Get RTC Heap Track mode\n\nReturns:\n\n* The RTC heap track mode.\n\n"]
    pub fn furi_hal_rtc_get_heap_track_mode() -> FuriHalRtcHeapTrackMode;
}
extern "C" {
    #[doc = "Set locale units\n\n# Arguments\n\n* `mode` - [Direction: In] The RTC Locale Units\n\n"]
    pub fn furi_hal_rtc_set_locale_units(value: FuriHalRtcLocaleUnits);
}
extern "C" {
    #[doc = "Get RTC Locale Units\n\nReturns:\n\n* The RTC Locale Units.\n\n"]
    pub fn furi_hal_rtc_get_locale_units() -> FuriHalRtcLocaleUnits;
}
extern "C" {
    #[doc = "Set RTC Locale Time Format\n\n# Arguments\n\n* `value` - [Direction: In] The RTC Locale Time Format\n\n"]
    pub fn furi_hal_rtc_set_locale_timeformat(value: FuriHalRtcLocaleTimeFormat);
}
extern "C" {
    #[doc = "Get RTC Locale Time Format\n\nReturns:\n\n* The RTC Locale Time Format.\n\n"]
    pub fn furi_hal_rtc_get_locale_timeformat() -> FuriHalRtcLocaleTimeFormat;
}
extern "C" {
    #[doc = "Set RTC Locale Date Format\n\n# Arguments\n\n* `value` - [Direction: In] The RTC Locale Date Format\n\n"]
    pub fn furi_hal_rtc_set_locale_dateformat(value: FuriHalRtcLocaleDateFormat);
}
extern "C" {
    #[doc = "Get RTC Locale Date Format\n\nReturns:\n\n* The RTC Locale Date Format\n\n"]
    pub fn furi_hal_rtc_get_locale_dateformat() -> FuriHalRtcLocaleDateFormat;
}
extern "C" {
    #[doc = "Set RTC Date Time\n\n# Arguments\n\n* `datetime` - The date time to set\n\n"]
    pub fn furi_hal_rtc_set_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    #[doc = "Get RTC Date Time\n\n# Arguments\n\n* `datetime` - The datetime\n\n"]
    pub fn furi_hal_rtc_get_datetime(datetime: *mut FuriHalRtcDateTime);
}
extern "C" {
    #[doc = "Validate Date Time\n\nReturns:\n\n* { description_of_the_return_value }\n\n# Arguments\n\n* `datetime` - The datetime to validate\n\n"]
    pub fn furi_hal_rtc_validate_datetime(datetime: *mut FuriHalRtcDateTime) -> bool;
}
extern "C" {
    #[doc = "Set RTC Fault Data\n\n# Arguments\n\n* `value` - [Direction: In] The value\n\n"]
    pub fn furi_hal_rtc_set_fault_data(value: u32);
}
extern "C" {
    #[doc = "Get RTC Fault Data\n\nReturns:\n\n* RTC Fault Data value\n\n"]
    pub fn furi_hal_rtc_get_fault_data() -> u32;
}
extern "C" {
    #[doc = "Set Pin Fails count\n\n# Arguments\n\n* `value` - [Direction: In] The Pin Fails count\n\n"]
    pub fn furi_hal_rtc_set_pin_fails(value: u32);
}
extern "C" {
    #[doc = "Get Pin Fails count\n\nReturns:\n\n* Pin Fails Count\n\n"]
    pub fn furi_hal_rtc_get_pin_fails() -> u32;
}
extern "C" {
    #[doc = "Get UNIX Timestamp\n\nReturns:\n\n* Unix Timestamp in seconds from UNIX epoch start\n\n"]
    pub fn furi_hal_rtc_get_timestamp() -> u32;
}
extern "C" {
    #[doc = "Convert DateTime to UNIX timestamp\n\nReturns:\n\n* UNIX Timestamp in seconds from UNIX epoch start\n\n# Arguments\n\n* `datetime` - The datetime\n\n"]
    pub fn furi_hal_rtc_datetime_to_timestamp(datetime: *mut FuriHalRtcDateTime) -> u32;
}
extern "C" {
    #[doc = "Gets the number of days in the year according to the Gregorian calendar.\n\nReturns:\n\n* number of days in `year`.\n\n# Arguments\n\n* `year` - Input year.\n\n"]
    pub fn furi_hal_rtc_get_days_per_year(year: u16) -> u16;
}
extern "C" {
    #[doc = "Check if a year a leap year in the Gregorian calendar.\n\nReturns:\n\n* true if `year` is a leap year.\n\n# Arguments\n\n* `year` - Input year.\n\n"]
    pub fn furi_hal_rtc_is_leap_year(year: u16) -> bool;
}
extern "C" {
    #[doc = "Get the number of days in the month.\n\nReturns:\n\n* the number of days in the month\n\n# Arguments\n\n* `leap_year` - true to calculate based on leap years\n* `month` - month to check, where 1 = January\n\n"]
    pub fn furi_hal_rtc_get_days_per_month(leap_year: bool, month: u8) -> u8;
}
extern "C" {
    #[doc = "Acquire speaker ownership\n\n**Warning!**\n\n* You must acquire speaker ownership before use\n\nReturns:\n\n* bool returns true on success\n\n# Arguments\n\n* `timeout` - Timeout during which speaker ownership must be acquired\n\n"]
    pub fn furi_hal_speaker_acquire(timeout: u32) -> bool;
}
extern "C" {
    #[doc = "Release speaker ownership\n\n**Warning!**\n\n* You must release speaker ownership after use\n\n"]
    pub fn furi_hal_speaker_release();
}
extern "C" {
    #[doc = "Check current process speaker ownership\n\n**Warning!**\n\n* always returns true if called from ISR\n\nReturns:\n\n* bool returns true if process owns speaker\n\n"]
    pub fn furi_hal_speaker_is_mine() -> bool;
}
extern "C" {
    #[doc = "Play a note\n\n**Warning!**\n\n* no ownership check if called from ISR\n\n# Arguments\n\n* `frequency` - The frequency\n* `volume` - The volume\n\n"]
    pub fn furi_hal_speaker_start(frequency: f32, volume: f32);
}
extern "C" {
    #[doc = "Set volume\n\n**Warning!**\n\n* no ownership check if called from ISR\n\n# Arguments\n\n* `volume` - The volume\n\n"]
    pub fn furi_hal_speaker_set_volume(volume: f32);
}
extern "C" {
    #[doc = "Stop playback\n\n**Warning!**\n\n* no ownership check if called from ISR\n\n"]
    pub fn furi_hal_speaker_stop();
}
extern "C" {
    #[doc = "Set light value\n\n# Arguments\n\n* `light` - Light\n* `value` - light brightness [0-255]\n\n"]
    pub fn furi_hal_light_set(light: Light, value: u8);
}
extern "C" {
    #[doc = "Start hardware LED blinking mode\n\n# Arguments\n\n* `light` - Light\n* `brightness` - light brightness [0-255]\n* `on_time` - LED on time in ms\n* `period` - LED blink period in ms\n\n"]
    pub fn furi_hal_light_blink_start(light: Light, brightness: u8, on_time: u16, period: u16);
}
extern "C" {
    #[doc = "Stop hardware LED blinking mode\n\n"]
    pub fn furi_hal_light_blink_stop();
}
extern "C" {
    #[doc = "Set color in hardware LED blinking mode\n\n# Arguments\n\n* `light` - Light\n\n"]
    pub fn furi_hal_light_blink_set_color(light: Light);
}
extern "C" {
    #[doc = "Execute sequence\n\n# Arguments\n\n* `sequence` - Sequence to execute\n\n"]
    pub fn furi_hal_light_sequence(sequence: *const core::ffi::c_char);
}
#[doc = "Callback type called every time another key-value pair of device information is ready\n\n# Arguments\n\n* `key[in]` - device information type identifier\n* `value[in]` - device information value\n* `last[in]` - whether the passed key-value pair is the last one\n* `context[in]` - to pass to callback\n\n"]
pub type PropertyValueCallback = ::core::option::Option<
    unsafe extern "C" fn(
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        last: bool,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyValueContext {
    #[doc = "key string buffer, must be initialised before use\n\n"]
    pub key: *mut FuriString,
    #[doc = "value string buffer, must be initialised before use\n\n"]
    pub value: *mut FuriString,
    #[doc = "output callback function\n\n"]
    pub out: PropertyValueCallback,
    #[doc = "separator character between key parts\n\n"]
    pub sep: core::ffi::c_char,
    #[doc = "flag to indicate last element\n\n"]
    pub last: bool,
    #[doc = "user-defined context, passed through to out callback\n\n"]
    pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_PropertyValueContext() {
    const UNINIT: ::core::mem::MaybeUninit<PropertyValueContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PropertyValueContext>(),
        20usize,
        concat!("Size of: ", stringify!(PropertyValueContext))
    );
    assert_eq!(
        ::core::mem::align_of::<PropertyValueContext>(),
        4usize,
        concat!("Alignment of ", stringify!(PropertyValueContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sep) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyValueContext),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = "Builds key and value strings and outputs them via a callback function\n\n# Arguments\n\n* `ctx[in]` - local property context\n* `fmt[in]` - value format, set to NULL to bypass formatting\n* `nparts[in]` - number of key parts (separated by character)\n* `...[in]` - list of key parts followed by value\n\n"]
    pub fn property_value_out(
        ctx: *mut PropertyValueContext,
        fmt: *const core::ffi::c_char,
        nparts: core::ffi::c_uint,
        ...
    );
}
pub const FuriHalPowerIC_FuriHalPowerICCharger: FuriHalPowerIC = 0;
pub const FuriHalPowerIC_FuriHalPowerICFuelGauge: FuriHalPowerIC = 1;
#[doc = "Power IC type\n\n"]
pub type FuriHalPowerIC = core::ffi::c_uchar;
extern "C" {
    #[doc = "Check if gauge is ok\nVerifies that:\n* gauge is alive\n* correct profile loaded\n* self diagnostic status is good\n\nReturns:\n\n* true if gauge is ok\n\n"]
    pub fn furi_hal_power_gauge_is_ok() -> bool;
}
extern "C" {
    #[doc = "Check if gauge requests system shutdown\n\nReturns:\n\n* true if system shutdown requested\n\n"]
    pub fn furi_hal_power_is_shutdown_requested() -> bool;
}
extern "C" {
    #[doc = "Enter insomnia mode Prevents device from going to sleep\n\n**Warning!**\n\n* Internally increases insomnia level Must be paired with furi_hal_power_insomnia_exit\n\n"]
    pub fn furi_hal_power_insomnia_enter();
}
extern "C" {
    #[doc = "Exit insomnia mode Allow device to go to sleep\n\n**Warning!**\n\n* Internally decreases insomnia level. Must be paired with furi_hal_power_insomnia_enter\n\n"]
    pub fn furi_hal_power_insomnia_exit();
}
extern "C" {
    #[doc = "Check if sleep availble\n\nReturns:\n\n* true if available\n\n"]
    pub fn furi_hal_power_sleep_available() -> bool;
}
extern "C" {
    #[doc = "Go to sleep\n\n"]
    pub fn furi_hal_power_sleep();
}
extern "C" {
    #[doc = "Get predicted remaining battery capacity in percents\n\nReturns:\n\n* remaining battery capacity in percents\n\n"]
    pub fn furi_hal_power_get_pct() -> u8;
}
extern "C" {
    #[doc = "Get battery health state in percents\n\nReturns:\n\n* health in percents\n\n"]
    pub fn furi_hal_power_get_bat_health_pct() -> u8;
}
extern "C" {
    #[doc = "Get charging status\n\nReturns:\n\n* true if charging\n\n"]
    pub fn furi_hal_power_is_charging() -> bool;
}
extern "C" {
    #[doc = "Get charge complete status\n\nReturns:\n\n* true if done charging and connected to charger\n\n"]
    pub fn furi_hal_power_is_charging_done() -> bool;
}
extern "C" {
    #[doc = "Switch MCU to SHUTDOWN\n\n"]
    pub fn furi_hal_power_shutdown();
}
extern "C" {
    #[doc = "Poweroff device\n\n"]
    pub fn furi_hal_power_off();
}
extern "C" {
    #[doc = "Reset device\n\n"]
    pub fn furi_hal_power_reset();
}
extern "C" {
    #[doc = "OTG enable\n\n"]
    pub fn furi_hal_power_enable_otg() -> bool;
}
extern "C" {
    #[doc = "OTG disable\n\n"]
    pub fn furi_hal_power_disable_otg();
}
extern "C" {
    #[doc = "Check OTG status fault\n\n"]
    pub fn furi_hal_power_check_otg_fault() -> bool;
}
extern "C" {
    #[doc = "Check OTG status and disable it if falt happened\n\n"]
    pub fn furi_hal_power_check_otg_status();
}
extern "C" {
    #[doc = "Get OTG status\n\nReturns:\n\n* true if enabled\n\n"]
    pub fn furi_hal_power_is_otg_enabled() -> bool;
}
extern "C" {
    #[doc = "Get battery charge voltage limit in V\n\nReturns:\n\n* voltage in V\n\n"]
    pub fn furi_hal_power_get_battery_charge_voltage_limit() -> f32;
}
extern "C" {
    #[doc = "Set battery charge voltage limit in V\nInvalid values will be clamped downward to the nearest valid value.\n\nReturns:\n\n* voltage in V\n\n# Arguments\n\n* `voltage[in]` - voltage in V\n\n"]
    pub fn furi_hal_power_set_battery_charge_voltage_limit(voltage: f32);
}
extern "C" {
    #[doc = "Get remaining battery battery capacity in mAh\n\nReturns:\n\n* capacity in mAh\n\n"]
    pub fn furi_hal_power_get_battery_remaining_capacity() -> u32;
}
extern "C" {
    #[doc = "Get full charge battery capacity in mAh\n\nReturns:\n\n* capacity in mAh\n\n"]
    pub fn furi_hal_power_get_battery_full_capacity() -> u32;
}
extern "C" {
    #[doc = "Get battery capacity in mAh from battery profile\n\nReturns:\n\n* capacity in mAh\n\n"]
    pub fn furi_hal_power_get_battery_design_capacity() -> u32;
}
extern "C" {
    #[doc = "Get battery voltage in V\n\nReturns:\n\n* voltage in V\n\n# Arguments\n\n* `ic` - FuriHalPowerIc to get measurment\n\n"]
    pub fn furi_hal_power_get_battery_voltage(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = "Get battery current in A\n\nReturns:\n\n* current in A\n\n# Arguments\n\n* `ic` - FuriHalPowerIc to get measurment\n\n"]
    pub fn furi_hal_power_get_battery_current(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = "Get temperature in C\n\nReturns:\n\n* temperature in C\n\n# Arguments\n\n* `ic` - FuriHalPowerIc to get measurment\n\n"]
    pub fn furi_hal_power_get_battery_temperature(ic: FuriHalPowerIC) -> f32;
}
extern "C" {
    #[doc = "Get USB voltage in V\n\nReturns:\n\n* voltage in V\n\n"]
    pub fn furi_hal_power_get_usb_voltage() -> f32;
}
extern "C" {
    #[doc = "Enable 3.3v on external gpio and sd card\n\n"]
    pub fn furi_hal_power_enable_external_3_3v();
}
extern "C" {
    #[doc = "Disable 3.3v on external gpio and sd card\n\n"]
    pub fn furi_hal_power_disable_external_3_3v();
}
extern "C" {
    #[doc = "Enter supress charge mode.\nUse this function when your application need clean power supply.\n\n"]
    pub fn furi_hal_power_suppress_charge_enter();
}
extern "C" {
    #[doc = "Exit supress charge mode\n\n"]
    pub fn furi_hal_power_suppress_charge_exit();
}
extern "C" {
    #[doc = "Get power information\n\n# Arguments\n\n* `callback` - [Direction: In] callback to provide with new data\n* `sep` - [Direction: In] category separator character\n* `context` - [Direction: In] context to pass to callback\n\n"]
    pub fn furi_hal_power_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Get power debug information\n\n# Arguments\n\n* `callback` - [Direction: In] callback to provide with new data\n* `context` - [Direction: In] context to pass to callback\n\n"]
    pub fn furi_hal_power_debug_get(
        callback: PropertyValueCallback,
        context: *mut core::ffi::c_void,
    );
}
#[doc = "TIM Time Base configuration structure definition.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_InitTypeDef {
    #[doc = "Specifies the prescaler value used to divide the TIM clock.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\nThis feature can be modified afterwards using unitary function [`LL_TIM_SetPrescaler()`]\n\n"]
    pub Prescaler: u16,
    #[doc = "Specifies the counter mode.\nThis parameter can be a value of  [`TIM_LL_EC_COUNTERMODE`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_SetCounterMode()`]\n\n"]
    pub CounterMode: u32,
    #[doc = "Specifies the auto reload value to be loaded into the active\nAuto-Reload Register at the next update event.\nThis parameter must be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\nSome timer instances may support 32 bits counters. In that case this parameter must\nbe a number between 0x0000 and 0xFFFFFFFF.\nThis feature can be modified afterwards using unitary function [`LL_TIM_SetAutoReload()`]\n\n"]
    pub Autoreload: u32,
    #[doc = "Specifies the clock division.\nThis parameter can be a value of  [`TIM_LL_EC_CLOCKDIVISION`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_SetClockDivision()`]\n\n"]
    pub ClockDivision: u32,
    #[doc = "Specifies the repetition counter value. Each time the RCR downcounter\nreaches zero, an update event is generated and counting restarts\nfrom the RCR value (N).\nThis means in PWM mode that (N+1) corresponds to:\nthe number of PWM periods in edge-aligned mode\nthe number of half PWM period in center-aligned mode\nGP timers: this parameter must be a number between Min_Data = 0x00 and\nMax_Data = 0xFF.\nAdvanced timers: this parameter must be a number between Min_Data = 0x0000 and\nMax_Data = 0xFFFF.\nThis feature can be modified afterwards using unitary function [`LL_TIM_SetRepetitionCounter()`]\n\n"]
    pub RepetitionCounter: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_InitTypeDef>(),
        20usize,
        concat!("Size of: ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CounterMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(CounterMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Autoreload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(Autoreload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockDivision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(ClockDivision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RepetitionCounter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_InitTypeDef),
            "::",
            stringify!(RepetitionCounter)
        )
    );
}
#[doc = "TIM Output Compare configuration structure definition.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_TIM_OC_InitTypeDef {
    #[doc = "Specifies the output mode.\nThis parameter can be a value of  [`TIM_LL_EC_OCMODE`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_OC_SetMode()`]\n\n"]
    pub OCMode: u32,
    #[doc = "Specifies the TIM Output Compare state.\nThis parameter can be a value of  [`TIM_LL_EC_OCSTATE`]\nThis feature can be modified afterwards using unitary functions [`LL_TIM_CC_EnableChannel()`] or  [`LL_TIM_CC_DisableChannel()`]\n\n"]
    pub OCState: u32,
    #[doc = "Specifies the TIM complementary Output Compare state.\nThis parameter can be a value of  [`TIM_LL_EC_OCSTATE`]\nThis feature can be modified afterwards using unitary functions [`LL_TIM_CC_EnableChannel()`] or  [`LL_TIM_CC_DisableChannel()`]\n\n"]
    pub OCNState: u32,
    #[doc = "Specifies the Compare value to be loaded into the Capture Compare Register.\nThis parameter can be a number between Min_Data=0x0000 and Max_Data=0xFFFF.\nThis feature can be modified afterwards using unitary function\nLL_TIM_OC_SetCompareCHx (x=1..6).\n\n"]
    pub CompareValue: u32,
    #[doc = "Specifies the output polarity.\nThis parameter can be a value of  [`TIM_LL_EC_OCPOLARITY`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_OC_SetPolarity()`]\n\n"]
    pub OCPolarity: u32,
    #[doc = "Specifies the complementary output polarity.\nThis parameter can be a value of  [`TIM_LL_EC_OCPOLARITY`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_OC_SetPolarity()`]\n\n"]
    pub OCNPolarity: u32,
    #[doc = "Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of  [`TIM_LL_EC_OCIDLESTATE`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_OC_SetIdleState()`]\n\n"]
    pub OCIdleState: u32,
    #[doc = "Specifies the TIM Output Compare pin state during Idle state.\nThis parameter can be a value of  [`TIM_LL_EC_OCIDLESTATE`]\nThis feature can be modified afterwards using unitary function [`LL_TIM_OC_SetIdleState()`]\n\n"]
    pub OCNIdleState: u32,
}
#[test]
fn bindgen_test_layout_LL_TIM_OC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_TIM_OC_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_TIM_OC_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_TIM_OC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_TIM_OC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompareValue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(CompareValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNPolarity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCIdleState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCIdleState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OCNIdleState) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_TIM_OC_InitTypeDef),
            "::",
            stringify!(OCNIdleState)
        )
    );
}
extern "C" {
    pub fn LL_TIM_DeInit(TIMx: *mut TIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_Init(
        TIMx: *mut TIM_TypeDef,
        TIM_InitStruct: *const LL_TIM_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_TIM_OC_Init(
        TIMx: *mut TIM_TypeDef,
        Channel: u32,
        TIM_OC_InitStruct: *const LL_TIM_OC_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Timer ISR\n\n"]
pub type FuriHalInterruptISR =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1TrgComTim17: FuriHalInterruptId = 0;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1Cc: FuriHalInterruptId = 1;
pub const FuriHalInterruptId_FuriHalInterruptIdTim1UpTim16: FuriHalInterruptId = 2;
pub const FuriHalInterruptId_FuriHalInterruptIdTIM2: FuriHalInterruptId = 3;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch1: FuriHalInterruptId = 4;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch2: FuriHalInterruptId = 5;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch3: FuriHalInterruptId = 6;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch4: FuriHalInterruptId = 7;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch5: FuriHalInterruptId = 8;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch6: FuriHalInterruptId = 9;
pub const FuriHalInterruptId_FuriHalInterruptIdDma1Ch7: FuriHalInterruptId = 10;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch1: FuriHalInterruptId = 11;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch2: FuriHalInterruptId = 12;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch3: FuriHalInterruptId = 13;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch4: FuriHalInterruptId = 14;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch5: FuriHalInterruptId = 15;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch6: FuriHalInterruptId = 16;
pub const FuriHalInterruptId_FuriHalInterruptIdDma2Ch7: FuriHalInterruptId = 17;
pub const FuriHalInterruptId_FuriHalInterruptIdRcc: FuriHalInterruptId = 18;
pub const FuriHalInterruptId_FuriHalInterruptIdCOMP: FuriHalInterruptId = 19;
pub const FuriHalInterruptId_FuriHalInterruptIdHsem: FuriHalInterruptId = 20;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim1: FuriHalInterruptId = 21;
pub const FuriHalInterruptId_FuriHalInterruptIdLpTim2: FuriHalInterruptId = 22;
pub const FuriHalInterruptId_FuriHalInterruptIdMax: FuriHalInterruptId = 23;
pub type FuriHalInterruptId = core::ffi::c_uchar;
extern "C" {
    #[doc = "Set ISR and enable interrupt with default priority We don't clear interrupt flags for you, do it by your self.\n\n# Arguments\n\n* `index` - - interrupt ID\n* `isr` - - your interrupt service routine or use NULL to clear\n* `context` - - isr context\n\n"]
    pub fn furi_hal_interrupt_set_isr(
        index: FuriHalInterruptId,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set ISR and enable interrupt with custom priority We don't clear interrupt flags for you, do it by your self.\n\n# Arguments\n\n* `index` - - interrupt ID\n* `priority` - - 0 to 15, 0 highest\n* `isr` - - your interrupt service routine or use NULL to clear\n* `context` - - isr context\n\n"]
    pub fn furi_hal_interrupt_set_isr_ex(
        index: FuriHalInterruptId,
        priority: u16,
        isr: FuriHalInterruptISR,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Version {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Get current running firmware version handle.\nYou can store it somewhere. But if you want to retrieve data, you have to use 'version_*_get()' set of functions. Also, 'version_*_get()' imply to use this handle if no handle (NULL_PTR) provided.\n\nReturns:\n\n* pointer to Version data.\n\n"]
    pub fn version_get() -> *const Version;
}
extern "C" {
    #[doc = "Get git commit hash.\n\nReturns:\n\n* git hash\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_githash(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get git branch.\n\nReturns:\n\n* git branch\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_gitbranch(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get number of commit in git branch.\n\nReturns:\n\n* number of commit\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_gitbranchnum(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get build date.\n\nReturns:\n\n* build date\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_builddate(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get build version. Build version is last tag in git history.\n\nReturns:\n\n* build date\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_version(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get custom flipper name if set in version_set_custom_name\n\nReturns:\n\n* custom name or NULL\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_custom_name(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get hardware target this firmware was built for\n\nReturns:\n\n* build date\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_target(v: *const Version) -> u8;
}
extern "C" {
    #[doc = "Get flag indicating if this build is \"dirty\" (source code had uncommited changes)\n\nReturns:\n\n* build date\n\n# Arguments\n\n* `v` - pointer to Version data. NULL for currently running software.\n\n"]
    pub fn version_get_dirty_flag(v: *const Version) -> bool;
}
extern "C" {
    #[doc = "Get firmware origin. \"Official\" for mainline firmware, fork name for forks. Set by FIRMWARE_ORIGIN fbt argument.\n\n"]
    pub fn version_get_firmware_origin(v: *const Version) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get git repo origin\n\n"]
    pub fn version_get_git_origin(v: *const Version) -> *const core::ffi::c_char;
}
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion0: FuriHalVersionOtpVersion = 0;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion1: FuriHalVersionOtpVersion = 1;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersion2: FuriHalVersionOtpVersion = 2;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionEmpty: FuriHalVersionOtpVersion =
    4294967294;
pub const FuriHalVersionOtpVersion_FuriHalVersionOtpVersionUnknown: FuriHalVersionOtpVersion =
    4294967295;
#[doc = "OTP Versions enum\n\n"]
pub type FuriHalVersionOtpVersion = core::ffi::c_uint;
pub const FuriHalVersionColor_FuriHalVersionColorUnknown: FuriHalVersionColor = 0;
pub const FuriHalVersionColor_FuriHalVersionColorBlack: FuriHalVersionColor = 1;
pub const FuriHalVersionColor_FuriHalVersionColorWhite: FuriHalVersionColor = 2;
pub const FuriHalVersionColor_FuriHalVersionColorTransparent: FuriHalVersionColor = 3;
#[doc = "Device Colors\n\n"]
pub type FuriHalVersionColor = core::ffi::c_uchar;
pub const FuriHalVersionRegion_FuriHalVersionRegionUnknown: FuriHalVersionRegion = 0;
pub const FuriHalVersionRegion_FuriHalVersionRegionEuRu: FuriHalVersionRegion = 1;
pub const FuriHalVersionRegion_FuriHalVersionRegionUsCaAu: FuriHalVersionRegion = 2;
pub const FuriHalVersionRegion_FuriHalVersionRegionJp: FuriHalVersionRegion = 3;
pub const FuriHalVersionRegion_FuriHalVersionRegionWorld: FuriHalVersionRegion = 4;
#[doc = "Device Regions\n\n"]
pub type FuriHalVersionRegion = core::ffi::c_uchar;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayUnknown: FuriHalVersionDisplay = 0;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayErc: FuriHalVersionDisplay = 1;
pub const FuriHalVersionDisplay_FuriHalVersionDisplayMgg: FuriHalVersionDisplay = 2;
#[doc = "Device Display\n\n"]
pub type FuriHalVersionDisplay = core::ffi::c_uchar;
extern "C" {
    #[doc = "Check target firmware version\n\nReturns:\n\n* true if target and real matches\n\n"]
    pub fn furi_hal_version_do_i_belong_here() -> bool;
}
extern "C" {
    #[doc = "Get model name\n\nReturns:\n\n* model name C-string\n\n"]
    pub fn furi_hal_version_get_model_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get model name\n\nReturns:\n\n* model code C-string\n\n"]
    pub fn furi_hal_version_get_model_code() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get FCC ID\n\nReturns:\n\n* FCC id as C-string\n\n"]
    pub fn furi_hal_version_get_fcc_id() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get IC id\n\nReturns:\n\n* IC id as C-string\n\n"]
    pub fn furi_hal_version_get_ic_id() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get MIC id\n\nReturns:\n\n* MIC id as C-string\n\n"]
    pub fn furi_hal_version_get_mic_id() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get OTP version\n\nReturns:\n\n* OTP Version\n\n"]
    pub fn furi_hal_version_get_otp_version() -> FuriHalVersionOtpVersion;
}
extern "C" {
    #[doc = "Get hardware version\n\nReturns:\n\n* Hardware Version\n\n"]
    pub fn furi_hal_version_get_hw_version() -> u8;
}
extern "C" {
    #[doc = "Get hardware target\n\nReturns:\n\n* Hardware Target\n\n"]
    pub fn furi_hal_version_get_hw_target() -> u8;
}
extern "C" {
    #[doc = "Get hardware body\n\nReturns:\n\n* Hardware Body\n\n"]
    pub fn furi_hal_version_get_hw_body() -> u8;
}
extern "C" {
    #[doc = "Get hardware body color\n\nReturns:\n\n* Hardware Color\n\n"]
    pub fn furi_hal_version_get_hw_color() -> FuriHalVersionColor;
}
extern "C" {
    #[doc = "Get hardware connect\n\nReturns:\n\n* Hardware Interconnect\n\n"]
    pub fn furi_hal_version_get_hw_connect() -> u8;
}
extern "C" {
    #[doc = "Get hardware region (fake) = 0\n\nReturns:\n\n* Hardware Region (fake)\n\n"]
    pub fn furi_hal_version_get_hw_region() -> FuriHalVersionRegion;
}
extern "C" {
    #[doc = "Get hardware region name (fake) = R00\n\nReturns:\n\n* Hardware Region name (fake)\n\n"]
    pub fn furi_hal_version_get_hw_region_name() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get hardware region (OTP)\n\nReturns:\n\n* Hardware Region\n\n"]
    pub fn furi_hal_version_get_hw_region_otp() -> FuriHalVersionRegion;
}
extern "C" {
    #[doc = "Get hardware region name (OTP)\n\nReturns:\n\n* Hardware Region name\n\n"]
    pub fn furi_hal_version_get_hw_region_name_otp() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get hardware display id\n\nReturns:\n\n* Display id\n\n"]
    pub fn furi_hal_version_get_hw_display() -> FuriHalVersionDisplay;
}
extern "C" {
    #[doc = "Get hardware timestamp\n\nReturns:\n\n* Hardware Manufacture timestamp\n\n"]
    pub fn furi_hal_version_get_hw_timestamp() -> u32;
}
extern "C" {
    #[doc = "Get pointer to target name\n\nReturns:\n\n* Hardware Name C-string\n\n"]
    pub fn furi_hal_version_get_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get pointer to target device name\n\nReturns:\n\n* Hardware Device Name C-string\n\n"]
    pub fn furi_hal_version_get_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get pointer to target ble local device name\n\nReturns:\n\n* Ble Device Name C-string\n\n"]
    pub fn furi_hal_version_get_ble_local_device_name_ptr() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get BLE MAC address\n\nReturns:\n\n* pointer to BLE MAC address\n\n"]
    pub fn furi_hal_version_get_ble_mac() -> *const u8;
}
extern "C" {
    #[doc = "Get address of version structure of firmware.\n\nReturns:\n\n* Address of firmware version structure.\n\n"]
    pub fn furi_hal_version_get_firmware_version() -> *const Version;
}
extern "C" {
    #[doc = "Get platform UID size in bytes\n\nReturns:\n\n* UID size in bytes\n\n"]
    pub fn furi_hal_version_uid_size() -> usize;
}
extern "C" {
    #[doc = "Get const pointer to UID\n\nReturns:\n\n* pointer to UID\n\n"]
    pub fn furi_hal_version_uid() -> *const u8;
}
extern "C" {
    pub fn furi_hal_version_uid_default() -> *const u8;
}
pub const GapEventType_GapEventTypeConnected: GapEventType = 0;
pub const GapEventType_GapEventTypeDisconnected: GapEventType = 1;
pub const GapEventType_GapEventTypeStartAdvertising: GapEventType = 2;
pub const GapEventType_GapEventTypeStopAdvertising: GapEventType = 3;
pub const GapEventType_GapEventTypePinCodeShow: GapEventType = 4;
pub const GapEventType_GapEventTypePinCodeVerify: GapEventType = 5;
pub const GapEventType_GapEventTypeUpdateMTU: GapEventType = 6;
pub type GapEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub union GapEventData {
    pub pin_code: u32,
    pub max_packet_size: u16,
}
#[test]
fn bindgen_test_layout_GapEventData() {
    const UNINIT: ::core::mem::MaybeUninit<GapEventData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEventData>(),
        4usize,
        concat!("Size of: ", stringify!(GapEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(pin_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_packet_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEventData),
            "::",
            stringify!(max_packet_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GapEvent {
    pub type_: GapEventType,
    pub data: GapEventData,
}
#[test]
fn bindgen_test_layout_GapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<GapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GapEvent>(),
        8usize,
        concat!("Size of: ", stringify!(GapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<GapEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(GapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GapEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type GapEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: GapEvent, context: *mut core::ffi::c_void) -> bool,
>;
pub const GapPairing_GapPairingNone: GapPairing = 0;
pub const GapPairing_GapPairingPinCodeShow: GapPairing = 1;
pub const GapPairing_GapPairingPinCodeVerifyYesNo: GapPairing = 2;
pub type GapPairing = core::ffi::c_uchar;
pub const SerialServiceEventType_SerialServiceEventTypeDataReceived: SerialServiceEventType = 0;
pub const SerialServiceEventType_SerialServiceEventTypeDataSent: SerialServiceEventType = 1;
pub const SerialServiceEventType_SerialServiceEventTypesBleResetRequest: SerialServiceEventType = 2;
pub type SerialServiceEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceData {
    pub buffer: *mut u8,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_SerialServiceData() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceData>(),
        8usize,
        concat!("Size of: ", stringify!(SerialServiceData))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceData>(),
        4usize,
        concat!("Alignment of ", stringify!(SerialServiceData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SerialServiceEvent {
    pub event: SerialServiceEventType,
    pub data: SerialServiceData,
}
#[test]
fn bindgen_test_layout_SerialServiceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SerialServiceEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SerialServiceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SerialServiceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SerialServiceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SerialServiceEvent),
            "::",
            stringify!(data)
        )
    );
}
pub type SerialServiceEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SerialServiceEvent, context: *mut core::ffi::c_void) -> u16,
>;
pub const BleGlueC2Mode_BleGlueC2ModeUnknown: BleGlueC2Mode = 0;
pub const BleGlueC2Mode_BleGlueC2ModeFUS: BleGlueC2Mode = 1;
pub const BleGlueC2Mode_BleGlueC2ModeStack: BleGlueC2Mode = 2;
pub type BleGlueC2Mode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BleGlueC2Info {
    pub mode: BleGlueC2Mode,
    #[doc = "Wireless Info\n\n"]
    pub VersionMajor: u8,
    pub VersionMinor: u8,
    pub VersionSub: u8,
    pub VersionBranch: u8,
    pub VersionReleaseType: u8,
    pub MemorySizeSram2B: u8,
    pub MemorySizeSram2A: u8,
    pub MemorySizeSram1: u8,
    pub MemorySizeFlash: u8,
    pub StackType: u8,
    pub StackTypeString: [core::ffi::c_char; 20usize],
    #[doc = "Fus Info\n\n"]
    pub FusVersionMajor: u8,
    pub FusVersionMinor: u8,
    pub FusVersionSub: u8,
    pub FusMemorySizeSram2B: u8,
    pub FusMemorySizeSram2A: u8,
    pub FusMemorySizeFlash: u8,
}
#[test]
fn bindgen_test_layout_BleGlueC2Info() {
    const UNINIT: ::core::mem::MaybeUninit<BleGlueC2Info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BleGlueC2Info>(),
        37usize,
        concat!("Size of: ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        ::core::mem::align_of::<BleGlueC2Info>(),
        1usize,
        concat!("Alignment of ", stringify!(BleGlueC2Info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMajor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionMinor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionSub) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionBranch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionBranch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VersionReleaseType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(VersionReleaseType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2B) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram2A) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeSram1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeSram1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemorySizeFlash) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(MemorySizeFlash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackType) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackTypeString) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(StackTypeString)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMajor) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMajor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionMinor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionMinor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusVersionSub) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusVersionSub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2B) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2B)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeSram2A) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeSram2A)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FusMemorySizeFlash) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BleGlueC2Info),
            "::",
            stringify!(FusMemorySizeFlash)
        )
    );
}
pub type BleGlueKeyStorageChangedCallback = ::core::option::Option<
    unsafe extern "C" fn(change_addr_start: *mut u8, size: u16, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Initialize start core2 and initialize transport\n\n"]
    pub fn ble_glue_init();
}
extern "C" {
    #[doc = "Start Core2 Radio stack\n\nReturns:\n\n* true on success\n\n"]
    pub fn ble_glue_start() -> bool;
}
extern "C" {
    #[doc = "Is core2 alive and at least FUS is running\n\nReturns:\n\n* true if core2 is alive\n\n"]
    pub fn ble_glue_is_alive() -> bool;
}
extern "C" {
    #[doc = "Waits for C2 to reports its mode to callback\n\nReturns:\n\n* true if it reported before reaching timeout\n\n"]
    pub fn ble_glue_wait_for_c2_start(timeout: i32) -> bool;
}
extern "C" {
    pub fn ble_glue_get_c2_info() -> *const BleGlueC2Info;
}
extern "C" {
    #[doc = "Is core2 radio stack present and ready\n\nReturns:\n\n* true if present and ready\n\n"]
    pub fn ble_glue_is_radio_stack_ready() -> bool;
}
extern "C" {
    #[doc = "Set callback for NVM in RAM changes\n\n# Arguments\n\n* `callback` - [Direction: In] The callback to call on NVM change\n* `context` - The context for callback\n\n"]
    pub fn ble_glue_set_key_storage_changed_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop SHCI thread\n\n"]
    pub fn ble_glue_thread_stop();
}
extern "C" {
    pub fn ble_glue_reinit_c2() -> bool;
}
pub const BleGlueCommandResult_BleGlueCommandResultUnknown: BleGlueCommandResult = 0;
pub const BleGlueCommandResult_BleGlueCommandResultOK: BleGlueCommandResult = 1;
pub const BleGlueCommandResult_BleGlueCommandResultError: BleGlueCommandResult = 2;
pub const BleGlueCommandResult_BleGlueCommandResultRestartPending: BleGlueCommandResult = 3;
pub const BleGlueCommandResult_BleGlueCommandResultOperationOngoing: BleGlueCommandResult = 4;
pub type BleGlueCommandResult = core::ffi::c_uchar;
extern "C" {
    #[doc = "Restart MCU to launch radio stack firmware if necessary\n\nReturns:\n\n* true on radio stack start command\n\n"]
    pub fn ble_glue_force_c2_mode(mode: BleGlueC2Mode) -> BleGlueCommandResult;
}
extern "C" {
    pub fn ble_app_init() -> bool;
}
extern "C" {
    pub fn ble_app_get_key_storage_buff(addr: *mut *mut u8, size: *mut u16);
}
extern "C" {
    pub fn ble_app_thread_stop();
}
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusNotActive: FuriHalBtSerialRpcStatus = 0;
pub const FuriHalBtSerialRpcStatus_FuriHalBtSerialRpcStatusActive: FuriHalBtSerialRpcStatus = 1;
pub type FuriHalBtSerialRpcStatus = core::ffi::c_uchar;
#[doc = "Serial service callback type\n\n"]
pub type FuriHalBtSerialCallback = SerialServiceEventCallback;
extern "C" {
    #[doc = "Start Serial Profile\n\n"]
    pub fn furi_hal_bt_serial_start();
}
extern "C" {
    #[doc = "Stop Serial Profile\n\n"]
    pub fn furi_hal_bt_serial_stop();
}
extern "C" {
    #[doc = "Set Serial service events callback\n\n# Arguments\n\n* `buffer_size` - Applicaition buffer size\n* `calback` - FuriHalBtSerialCallback instance\n* `context` - pointer to context\n\n"]
    pub fn furi_hal_bt_serial_set_event_callback(
        buff_size: u16,
        callback: FuriHalBtSerialCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set BLE RPC status\n\n# Arguments\n\n* `status` - FuriHalBtSerialRpcStatus instance\n\n"]
    pub fn furi_hal_bt_serial_set_rpc_status(status: FuriHalBtSerialRpcStatus);
}
extern "C" {
    #[doc = "Notify that application buffer is empty\n\n"]
    pub fn furi_hal_bt_serial_notify_buffer_is_empty();
}
extern "C" {
    #[doc = "Send data through BLE\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `data` - data buffer\n* `size` - data buffer size\n\n"]
    pub fn furi_hal_bt_serial_tx(data: *mut u8, size: u16) -> bool;
}
pub const FuriHalBtStack_FuriHalBtStackUnknown: FuriHalBtStack = 0;
pub const FuriHalBtStack_FuriHalBtStackLight: FuriHalBtStack = 1;
pub const FuriHalBtStack_FuriHalBtStackFull: FuriHalBtStack = 2;
pub type FuriHalBtStack = core::ffi::c_uchar;
pub const FuriHalBtProfile_FuriHalBtProfileSerial: FuriHalBtProfile = 0;
pub const FuriHalBtProfile_FuriHalBtProfileHidKeyboard: FuriHalBtProfile = 1;
pub const FuriHalBtProfile_FuriHalBtProfileNumber: FuriHalBtProfile = 2;
pub type FuriHalBtProfile = core::ffi::c_uchar;
extern "C" {
    #[doc = "Lock core2 state transition\n\n"]
    pub fn furi_hal_bt_lock_core2();
}
extern "C" {
    #[doc = "Lock core2 state transition\n\n"]
    pub fn furi_hal_bt_unlock_core2();
}
extern "C" {
    #[doc = "Start radio stack\n\nReturns:\n\n* true on successfull radio stack start\n\n"]
    pub fn furi_hal_bt_start_radio_stack() -> bool;
}
extern "C" {
    #[doc = "Get radio stack type\n\nReturns:\n\n* FuriHalBtStack instance\n\n"]
    pub fn furi_hal_bt_get_radio_stack() -> FuriHalBtStack;
}
extern "C" {
    #[doc = "Check if radio stack supports BLE GAT/GAP\n\nReturns:\n\n* true if supported\n\n"]
    pub fn furi_hal_bt_is_ble_gatt_gap_supported() -> bool;
}
extern "C" {
    #[doc = "Check if radio stack supports testing\n\nReturns:\n\n* true if supported\n\n"]
    pub fn furi_hal_bt_is_testing_supported() -> bool;
}
extern "C" {
    #[doc = "Start BLE app\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `profile` - FuriHalBtProfile instance\n* `event_cb` - GapEventCallback instance\n* `context` - pointer to context\n\n"]
    pub fn furi_hal_bt_start_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Reinitialize core2\nAlso can be used to prepare core2 for stop modes\n\n"]
    pub fn furi_hal_bt_reinit();
}
extern "C" {
    #[doc = "Change BLE app Restarts 2nd core\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `profile` - FuriHalBtProfile instance\n* `event_cb` - GapEventCallback instance\n* `context` - pointer to context\n\n"]
    pub fn furi_hal_bt_change_app(
        profile: FuriHalBtProfile,
        event_cb: GapEventCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Update battery level\n\n# Arguments\n\n* `battery_level` - battery level\n\n"]
    pub fn furi_hal_bt_update_battery_level(battery_level: u8);
}
extern "C" {
    #[doc = "Update battery power state\n\n"]
    pub fn furi_hal_bt_update_power_state();
}
extern "C" {
    #[doc = "Checks if BLE state is active\n\nReturns:\n\n* true if device is connected or advertising, false otherwise\n\n"]
    pub fn furi_hal_bt_is_active() -> bool;
}
extern "C" {
    #[doc = "Start advertising\n\n"]
    pub fn furi_hal_bt_start_advertising();
}
extern "C" {
    #[doc = "Stop advertising\n\n"]
    pub fn furi_hal_bt_stop_advertising();
}
extern "C" {
    #[doc = "Get BT/BLE system component state\n\n# Arguments\n\n* `buffer` - [Direction: In] FuriString* buffer to write to\n\n"]
    pub fn furi_hal_bt_dump_state(buffer: *mut FuriString);
}
extern "C" {
    #[doc = "Get BT/BLE system component state\n\nReturns:\n\n* true if core2 is alive\n\n"]
    pub fn furi_hal_bt_is_alive() -> bool;
}
extern "C" {
    #[doc = "Get key storage buffer address and size\n\n# Arguments\n\n* `key_buff_addr` - pointer to store buffer address\n* `key_buff_size` - pointer to store buffer size\n\n"]
    pub fn furi_hal_bt_get_key_storage_buff(key_buff_addr: *mut *mut u8, key_buff_size: *mut u16);
}
extern "C" {
    #[doc = "Get SRAM2 hardware semaphore\n\n# Notes\n\n* Must be called before SRAM2 read/write operations\n\n"]
    pub fn furi_hal_bt_nvm_sram_sem_acquire();
}
extern "C" {
    #[doc = "Release SRAM2 hardware semaphore\n\n# Notes\n\n* Must be called after SRAM2 read/write operations\n\n"]
    pub fn furi_hal_bt_nvm_sram_sem_release();
}
extern "C" {
    #[doc = "Clear key storage\n\nReturns:\n\n* true on success\n\n"]
    pub fn furi_hal_bt_clear_white_list() -> bool;
}
extern "C" {
    #[doc = "Set key storage change callback\n\n# Arguments\n\n* `callback` - BleGlueKeyStorageChangedCallback instance\n* `context` - pointer to context\n\n"]
    pub fn furi_hal_bt_set_key_storage_change_callback(
        callback: BleGlueKeyStorageChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start ble tone tx at given channel and power\n\n# Arguments\n\n* `channel` - [Direction: In] The channel\n* `power` - [Direction: In] The power\n\n"]
    pub fn furi_hal_bt_start_tone_tx(channel: u8, power: u8);
}
extern "C" {
    #[doc = "Stop ble tone tx\n\n"]
    pub fn furi_hal_bt_stop_tone_tx();
}
extern "C" {
    #[doc = "Start sending ble packets at a given frequency and datarate\n\n# Arguments\n\n* `channel` - [Direction: In] The channel\n* `pattern` - [Direction: In] The pattern\n* `datarate` - [Direction: In] The datarate\n\n"]
    pub fn furi_hal_bt_start_packet_tx(channel: u8, pattern: u8, datarate: u8);
}
extern "C" {
    #[doc = "Stop sending ble packets\n\nReturns:\n\n* sent packet count\n\n"]
    pub fn furi_hal_bt_stop_packet_test() -> u16;
}
extern "C" {
    #[doc = "Start receiving packets\n\n# Arguments\n\n* `channel` - [Direction: In] RX channel\n* `datarate` - [Direction: In] Datarate\n\n"]
    pub fn furi_hal_bt_start_packet_rx(channel: u8, datarate: u8);
}
extern "C" {
    #[doc = "Set up the RF to listen to a given RF channel\n\n# Arguments\n\n* `channel` - [Direction: In] RX channel\n\n"]
    pub fn furi_hal_bt_start_rx(channel: u8);
}
extern "C" {
    #[doc = "Stop RF listenning\n\n"]
    pub fn furi_hal_bt_stop_rx();
}
extern "C" {
    #[doc = "Get RSSI\n\nReturns:\n\n* RSSI in dBm\n\n"]
    pub fn furi_hal_bt_get_rssi() -> f32;
}
extern "C" {
    #[doc = "Get number of transmitted packets\n\nReturns:\n\n* packet count\n\n"]
    pub fn furi_hal_bt_get_transmitted_packets() -> u32;
}
extern "C" {
    #[doc = "Reverse a MAC address byte order in-place\n\n# Arguments\n\n* `mac` - [Direction: In] mac address to reverse\n\n"]
    pub fn furi_hal_bt_reverse_mac_addr(mac_addr: *mut u8);
}
extern "C" {
    #[doc = "Modify profile advertisement name and restart bluetooth\n\n# Arguments\n\n* `profile` - [Direction: In] profile type\n* `name` - [Direction: In] new adv name\n\n"]
    pub fn furi_hal_bt_set_profile_adv_name(
        profile: FuriHalBtProfile,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn furi_hal_bt_get_profile_adv_name(profile: FuriHalBtProfile) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Modify profile mac address and restart bluetooth\n\n# Arguments\n\n* `profile` - [Direction: In] profile type\n* `mac` - [Direction: In] new mac address\n\n"]
    pub fn furi_hal_bt_set_profile_mac_addr(profile: FuriHalBtProfile, mac_addr: *const u8);
}
extern "C" {
    pub fn furi_hal_bt_get_profile_mac_addr(profile: FuriHalBtProfile) -> *const u8;
}
extern "C" {
    #[doc = "Set custom advertisement packet data\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `adv_data` - [Direction: In] pointer to advertisement data\n* `adv_len` - [Direction: In] length of advertisement data\n\n"]
    pub fn furi_hal_bt_custom_adv_set(adv_data: *const u8, adv_len: usize) -> bool;
}
extern "C" {
    #[doc = "Start custom advertisement beacon\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `min_interval` - [Direction: In] minimum advertisement interval (20 - 10240 ms)\n* `max_interval` - [Direction: In] maximum advertisement interval (20 - 10240 ms)\n* `mac_type` - [Direction: In] type of mac address (0x00 public, 0x01 static random)\n* `mac_addr` - [Direction: In] pointer to mac address\n* `power_amp_level` - [Direction: In] amplifier level (output dBm) (0x00 - 0x1F)\n\n"]
    pub fn furi_hal_bt_custom_adv_start(
        min_interval: u16,
        max_interval: u16,
        mac_type: u8,
        mac_addr: *const u8,
        power_amp_level: u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Stop custom advertisement beacon\n\nReturns:\n\n* true on success\n\n"]
    pub fn furi_hal_bt_custom_adv_stop() -> bool;
}
extern "C" {
    pub fn furi_hal_bt_set_profile_pairing_method(
        profile: FuriHalBtProfile,
        pairing_method: GapPairing,
    );
}
extern "C" {
    pub fn furi_hal_bt_get_profile_pairing_method(profile: FuriHalBtProfile) -> GapPairing;
}
extern "C" {
    pub fn furi_hal_bt_is_connected() -> bool;
}
extern "C" {
    #[doc = "Check & switch C2 to given mode\n\n# Arguments\n\n* `mode` - [Direction: In] mode to switch into\n\n"]
    pub fn furi_hal_bt_ensure_c2_mode(mode: BleGlueC2Mode) -> bool;
}
#[doc = "SPI Init structures definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_SPI_InitTypeDef {
    #[doc = "Specifies the SPI unidirectional or bidirectional data mode.\nThis parameter can be a value of  [`SPI_LL_EC_TRANSFER_MODE`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetTransferDirection()`]\n\n"]
    pub TransferDirection: u32,
    #[doc = "Specifies the SPI mode (Master/Slave).\nThis parameter can be a value of  [`SPI_LL_EC_MODE`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetMode()`]\n\n"]
    pub Mode: u32,
    #[doc = "Specifies the SPI data width.\nThis parameter can be a value of  [`SPI_LL_EC_DATAWIDTH`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetDataWidth()`]\n\n"]
    pub DataWidth: u32,
    #[doc = "Specifies the serial clock steady state.\nThis parameter can be a value of  [`SPI_LL_EC_POLARITY`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetClockPolarity()`]\n\n"]
    pub ClockPolarity: u32,
    #[doc = "Specifies the clock active edge for the bit capture.\nThis parameter can be a value of  [`SPI_LL_EC_PHASE`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetClockPhase()`]\n\n"]
    pub ClockPhase: u32,
    #[doc = "Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit.\nThis parameter can be a value of  [`SPI_LL_EC_NSS_MODE`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetNSSMode()`]\n\n"]
    pub NSS: u32,
    #[doc = "Specifies the BaudRate prescaler value which will be used to configure the transmit and receive SCK clock.\nThis parameter can be a value of  [`SPI_LL_EC_BAUDRATEPRESCALER`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetBaudRatePrescaler()`]\n\n# Notes\n\n* The communication clock is derived from the master clock. The slave clock does not need to be set.\n\n"]
    pub BaudRate: u32,
    #[doc = "Specifies whether data transfers start from MSB or LSB bit.\nThis parameter can be a value of  [`SPI_LL_EC_BIT_ORDER`]\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetTransferBitOrder()`]\n\n"]
    pub BitOrder: u32,
    #[doc = "Specifies if the CRC calculation is enabled or not.\nThis parameter can be a value of  [`SPI_LL_EC_CRC_CALCULATION`]\nThis feature can be modified afterwards using unitary functions  [`LL_SPI_EnableCRC()`] and  [`LL_SPI_DisableCRC()`]\n\n"]
    pub CRCCalculation: u32,
    #[doc = "Specifies the polynomial used for the CRC calculation.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0xFFFF.\nThis feature can be modified afterwards using unitary function  [`LL_SPI_SetCRCPolynomial()`]\n\n"]
    pub CRCPoly: u32,
}
#[test]
fn bindgen_test_layout_LL_SPI_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_SPI_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_SPI_InitTypeDef>(),
        40usize,
        concat!("Size of: ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_SPI_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_SPI_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPolarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockPhase) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(ClockPhase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NSS) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(NSS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BitOrder) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(BitOrder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCCalculation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCCalculation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCPoly) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_SPI_InitTypeDef),
            "::",
            stringify!(CRCPoly)
        )
    );
}
extern "C" {
    pub fn LL_SPI_Init(
        SPIx: *mut SPI_TypeDef,
        SPI_InitStruct: *mut LL_SPI_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "Bus initialization event, called on system start\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventInit: FuriHalSpiBusEvent = 0;
#[doc = "Bus deinitialization event, called on system stop\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeinit: FuriHalSpiBusEvent = 1;
#[doc = "Bus lock event, called before activation\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventLock: FuriHalSpiBusEvent = 2;
#[doc = "Bus unlock event, called after deactivation\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventUnlock: FuriHalSpiBusEvent = 3;
#[doc = "Bus activation event, called before handle activation\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventActivate: FuriHalSpiBusEvent = 4;
#[doc = "Bus deactivation event, called after handle deactivation\n\n"]
pub const FuriHalSpiBusEvent_FuriHalSpiBusEventDeactivate: FuriHalSpiBusEvent = 5;
#[doc = "FuriHal spi bus states\n\n"]
pub type FuriHalSpiBusEvent = core::ffi::c_uchar;
#[doc = "FuriHal spi bus event callback\n\n"]
pub type FuriHalSpiBusEventCallback = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut FuriHalSpiBus, event: FuriHalSpiBusEvent),
>;
#[doc = "FuriHal spi bus\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBus {
    pub spi: *mut SPI_TypeDef,
    pub callback: FuriHalSpiBusEventCallback,
    pub current_handle: *mut FuriHalSpiBusHandle,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBus() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBus>(),
        12usize,
        concat!("Size of: ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBus>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBus),
            "::",
            stringify!(current_handle)
        )
    );
}
#[doc = "Handle init, called on system start, initialize gpio for idle state\n\n"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventInit: FuriHalSpiBusHandleEvent = 0;
#[doc = "Handle deinit, called on system stop, deinitialize gpio for default state\n\n"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeinit: FuriHalSpiBusHandleEvent = 1;
#[doc = "Handle activate: connect gpio and apply bus config\n\n"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventActivate: FuriHalSpiBusHandleEvent = 2;
#[doc = "Handle deactivate: disconnect gpio and reset bus config\n\n"]
pub const FuriHalSpiBusHandleEvent_FuriHalSpiBusHandleEventDeactivate: FuriHalSpiBusHandleEvent = 3;
#[doc = "FuriHal spi handle states\n\n"]
pub type FuriHalSpiBusHandleEvent = core::ffi::c_uchar;
#[doc = "FuriHal spi handle event callback\n\n"]
pub type FuriHalSpiBusHandleEventCallback = ::core::option::Option<
    unsafe extern "C" fn(handle: *mut FuriHalSpiBusHandle, event: FuriHalSpiBusHandleEvent),
>;
#[doc = "FuriHal spi handle\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalSpiBusHandle {
    pub bus: *mut FuriHalSpiBus,
    pub callback: FuriHalSpiBusHandleEventCallback,
    pub miso: *const GpioPin,
    pub mosi: *const GpioPin,
    pub sck: *const GpioPin,
    pub cs: *const GpioPin,
}
#[test]
fn bindgen_test_layout_FuriHalSpiBusHandle() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalSpiBusHandle> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalSpiBusHandle>(),
        24usize,
        concat!("Size of: ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalSpiBusHandle>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalSpiBusHandle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(miso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(mosi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sck) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(sck)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalSpiBusHandle),
            "::",
            stringify!(cs)
        )
    );
}
extern "C" {
    #[doc = "Preset for ST25R916\n\n"]
    pub static furi_hal_spi_preset_2edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = "Preset for CC1101\n\n"]
    pub static furi_hal_spi_preset_1edge_low_8m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = "Preset for ST7567 (Display)\n\n"]
    pub static furi_hal_spi_preset_1edge_low_4m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = "Preset for SdCard in fast mode\n\n"]
    pub static furi_hal_spi_preset_1edge_low_16m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = "Preset for SdCard in slow mode\n\n"]
    pub static furi_hal_spi_preset_1edge_low_2m: LL_SPI_InitTypeDef;
}
extern "C" {
    #[doc = "Furi Hal Spi Bus R (Radio: CC1101, Nfc, External)\n\n"]
    pub static mut furi_hal_spi_bus_r: FuriHalSpiBus;
}
extern "C" {
    #[doc = "Furi Hal Spi Bus D (Display, SdCard)\n\n"]
    pub static mut furi_hal_spi_bus_d: FuriHalSpiBus;
}
extern "C" {
    #[doc = "CC1101 on `furi_hal_spi_bus_r`\n\n"]
    pub static mut furi_hal_spi_bus_handle_subghz: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "ST25R3916 on `furi_hal_spi_bus_r`\n\n"]
    pub static mut furi_hal_spi_bus_handle_nfc: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "External on `furi_hal_spi_bus_r` Preset: `furi_hal_spi_preset_1edge_low_2m`\nmiso: pa6 mosi: pa7 sck: pb3 cs:  pa4 (software controlled)\n\n**Warning!**\n\n* not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize Bus pins are floating on inactive state, CS high after initialization\n\n"]
    pub static mut furi_hal_spi_bus_handle_external: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "External on `furi_hal_spi_bus_r` Preset: `furi_hal_spi_preset_1edge_low_2m`\nmiso: pa6 mosi: pa7 sck: pb3 cs:  pc3 (software controlled)\n\n**Warning!**\n\n* not initialized by default, call `furi_hal_spi_bus_handle_init` to initialize Bus pins are floating on inactive state, CS high after initialization\n\n"]
    pub static mut furi_hal_spi_bus_handle_external_extra: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "ST7567(Display) on `furi_hal_spi_bus_d`\n\n"]
    pub static mut furi_hal_spi_bus_handle_display: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "SdCard in fast mode on `furi_hal_spi_bus_d`\n\n"]
    pub static mut furi_hal_spi_bus_handle_sd_fast: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "SdCard in slow mode on `furi_hal_spi_bus_d`\n\n"]
    pub static mut furi_hal_spi_bus_handle_sd_slow: FuriHalSpiBusHandle;
}
extern "C" {
    #[doc = "Initialize SPI Bus\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBus instance\n\n"]
    pub fn furi_hal_spi_bus_init(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = "Deinitialize SPI Bus\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBus instance\n\n"]
    pub fn furi_hal_spi_bus_deinit(bus: *mut FuriHalSpiBus);
}
extern "C" {
    #[doc = "Initialize SPI Bus Handle\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n\n"]
    pub fn furi_hal_spi_bus_handle_init(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = "Deinitialize SPI Bus Handle\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n\n"]
    pub fn furi_hal_spi_bus_handle_deinit(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = "Acquire SPI bus\n\n**Warning!**\n\n* blocking, calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n\n"]
    pub fn furi_hal_spi_acquire(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = "Release SPI bus\n\n**Warning!**\n\n* calls `furi_crash` on programming error, CS transition is up to handler event routine\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n\n"]
    pub fn furi_hal_spi_release(handle: *mut FuriHalSpiBusHandle);
}
extern "C" {
    #[doc = "SPI Receive\n\nReturns:\n\n* true on sucess\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n* `buffer` - receive buffer\n* `size` - transaction size (buffer size)\n* `timeout` - operation timeout in ms\n\n"]
    pub fn furi_hal_spi_bus_rx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "SPI Transmit\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n* `buffer` - transmit buffer\n* `size` - transaction size (buffer size)\n* `timeout` - operation timeout in ms\n\n"]
    pub fn furi_hal_spi_bus_tx(
        handle: *mut FuriHalSpiBusHandle,
        buffer: *const u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "SPI Transmit and Receive\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n* `tx_buffer` - pointer to tx buffer\n* `rx_buffer` - pointer to rx buffer\n* `size` - transaction size (buffer size)\n* `timeout` - operation timeout in ms\n\n"]
    pub fn furi_hal_spi_bus_trx(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *const u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "SPI Transmit and Receive with DMA\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `handle` - pointer to FuriHalSpiBusHandle instance\n* `tx_buffer` - pointer to tx buffer\n* `rx_buffer` - pointer to rx buffer\n* `size` - transaction size (buffer size)\n* `timeout_ms` - operation timeout in ms\n\n"]
    pub fn furi_hal_spi_bus_trx_dma(
        handle: *mut FuriHalSpiBusHandle,
        tx_buffer: *mut u8,
        rx_buffer: *mut u8,
        size: usize,
        timeout_ms: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Turn on/off vibro\n\n# Arguments\n\n* `value` - [Direction: In] new state\n\n"]
    pub fn furi_hal_vibro_on(value: bool);
}
#[doc = "<\\brief Function has an error, STALLPID will be issued.\n\n"]
pub const _usbd_respond_usbd_fail: _usbd_respond = 0;
#[doc = "<\\brief Function completes request accepted ZLP or data will be send.\n\n"]
pub const _usbd_respond_usbd_ack: _usbd_respond = 1;
#[doc = "<\\brief Function is busy. NAK handshake.\n\n"]
pub const _usbd_respond_usbd_nak: _usbd_respond = 2;
#[doc = "Reporting status results.\n\n"]
pub type _usbd_respond = core::ffi::c_uchar;
#[doc = "Reporting status results.\n\n"]
pub use self::_usbd_respond as usbd_respond;
#[doc = "Represents a USB device data.\n\n"]
pub type usbd_device = _usbd_device;
#[doc = "Represents generic USB control request.\n\n"]
#[repr(C)]
#[derive(Debug)]
pub struct usbd_ctlreq {
    #[doc = "<\\brief This bitmapped field identifies the characteristics of the specific request.\n\n"]
    pub bmRequestType: u8,
    #[doc = "<\\brief This field specifies the particular request.\n\n"]
    pub bRequest: u8,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to the request.\n\n"]
    pub wValue: u16,
    #[doc = "<\\brief It is used to pass a parameter to the device, specific to the request.\n\n"]
    pub wIndex: u16,
    #[doc = "<\\brief This field specifies the length of the data transferred during the second phase of the control transfer.\n\n"]
    pub wLength: u16,
    #[doc = "<\\brief Data payload.\n\n"]
    pub data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_usbd_ctlreq() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_ctlreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_ctlreq>(),
        8usize,
        concat!("Size of: ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_ctlreq>(),
        2usize,
        concat!("Alignment of ", stringify!(usbd_ctlreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bmRequestType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bmRequestType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bRequest) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(bRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(wLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_ctlreq),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "USB device status data.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_status {
    #[doc = "<\\brief Pointer to data buffer used for control requests.\n\n"]
    pub data_buf: *mut core::ffi::c_void,
    #[doc = "<\\brief Pointer to current data for control request.\n\n"]
    pub data_ptr: *mut core::ffi::c_void,
    #[doc = "<\\brief Count remained data for control request.\n\n"]
    pub data_count: u16,
    #[doc = "<\\brief Size of the data buffer for control requests.\n\n"]
    pub data_maxsize: u16,
    #[doc = "<\\brief Size of the control endpoint.\n\n"]
    pub ep0size: u8,
    #[doc = "<\\brief Current device configuration number.\n\n"]
    pub device_cfg: u8,
    #[doc = "<\\brief Current  [`usbd_machine_state`]\n\n"]
    pub device_state: u8,
    #[doc = "<\\brief Current  [`usbd_ctl_state`]\n\n"]
    pub control_state: u8,
}
#[test]
fn bindgen_test_layout_usbd_status() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_status> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_status>(),
        16usize,
        concat!("Size of: ", stringify!(usbd_status))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_status>(),
        4usize,
        concat!("Alignment of ", stringify!(usbd_status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_maxsize) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(data_maxsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep0size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(ep0size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_cfg) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_state) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(device_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_state) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_status),
            "::",
            stringify!(control_state)
        )
    );
}
#[doc = "Generic USB device event callback for events and endpoints processing\n\n# Arguments\n\n* `dev` - [Direction: In] pointer to USB device\n* `event` - [`USB_EVENTS`] \"USB event\"\n* `ep` - active endpoint number\n\n# Notes\n\n* endpoints with same indexes i.e. 0x01 and 0x81 shares same callback.\n\n"]
pub type usbd_evt_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, event: u8, ep: u8)>;
#[doc = "USB control transfer completed callback function.\n\n# Arguments\n\n* `dev` - [Direction: In] pointer to USB device\n* `req` - [Direction: In] pointer to usb request structure\n\n# Notes\n\n* usbd_device->complete_callback will be set to NULL after this callback completion.\n\n"]
pub type usbd_rqc_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, req: *mut usbd_ctlreq)>;
#[doc = "USB control callback function.\n\nUses for the control request processing. Some requests will be handled by core if callback don't process it (returns FALSE).\n*  If request was not processed STALL PID will be issued.\n* GET_CONFIGURATION\n* SET_CONFIGURATION (passes to  [`usbd_cfg_callback)`]\n* GET_DESCRIPTOR (passes to  [`usbd_dsc_callback)`]\n* GET_STATUS\n* SET_FEATURE, CLEAR_FEATURE (endpoints only)\n* SET_ADDRESS\n\nReturns:\n\n* usbd_respond status.\n\n# Arguments\n\n* `dev` - [Direction: In] points to USB device\n* `req` - [Direction: In] points to usb control request\n* `*callback` - [Direction: In, Out] USB control transfer completion callback, default is NULL (no callback)\n\n"]
pub type usbd_ctl_callback = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut usbd_device,
        req: *mut usbd_ctlreq,
        callback: *mut usbd_rqc_callback,
    ) -> usbd_respond,
>;
#[doc = "USB get descriptor callback function\n\nCalled when GET_DESCRIPTOR request issued\n\nReturns:\n\n* usbd_ack if you passed the correct descriptor, usbd_fail otherwise.\n\n# Arguments\n\n* `req` - [Direction: In] pointer to usb control request structure\n* `address` - [Direction: Out] pointer to the descriptor in memory. Points to req->data by default. You can use this buffer.\n* `dsize` - [Direction: Out] descriptor size. maximum buffer size by default.\n\n"]
pub type usbd_dsc_callback = ::core::option::Option<
    unsafe extern "C" fn(
        req: *mut usbd_ctlreq,
        address: *mut *mut core::ffi::c_void,
        dsize: *mut u16,
    ) -> usbd_respond,
>;
#[doc = "USB set configuration callback function\n\ncalled when SET_CONFIGURATION request issued\n\nReturns:\n\n* TRUE if success\n\n# Arguments\n\n* `dev` - [Direction: In] pointer to USB device\n* `cfg` - [Direction: In] configuration number.\n\n# Notes\n\n* if config is 0 device endpoints should be de-configured\n\n"]
pub type usbd_cfg_callback =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device, cfg: u8) -> usbd_respond>;
#[doc = "USBD_HW*\n/**\\brief Get USB device status and capabilities.\n\nReturns:\n\n* Hardware status and capabilities [`USBD_HW_CAPS`]\n\n"]
pub type usbd_hw_getinfo = ::core::option::Option<unsafe extern "C" fn() -> u32>;
#[doc = "Enables or disables USB hardware\n\n# Arguments\n\n* `enable` - Enables USB when TRUE disables otherwise.\n\n"]
pub type usbd_hw_enable = ::core::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = "Connects or disconnects USB hardware to/from usb host\n\nReturns:\n\n* lanes connection status.\n\n# Arguments\n\n* `connect` - Connects USB to host if TRUE, disconnects otherwise\n\n"]
pub type usbd_hw_connect = ::core::option::Option<unsafe extern "C" fn(connect: bool) -> u8>;
#[doc = "Sets USB hardware address\n\n# Arguments\n\n* `address` - USB address\n\n"]
pub type usbd_hw_setaddr = ::core::option::Option<unsafe extern "C" fn(address: u8)>;
#[doc = "Configures endpoint\n\nReturns:\n\n* TRUE if success\n\n# Arguments\n\n* `ep` - endpoint address. Use USB_EPDIR_ macros to set endpoint direction\n* `eptype` - endpoint type. Use USB_EPTYPE_* macros.\n* `epsize` - endpoint size in bytes\n\n"]
pub type usbd_hw_ep_config =
    ::core::option::Option<unsafe extern "C" fn(ep: u8, eptype: u8, epsize: u16) -> bool>;
#[doc = "De-configures, cleans and disables endpoint\n\n# Arguments\n\n* `ep` - endpoint index\n\n# Notes\n\n* if you have two one-direction single-buffered endpoints with same index (i.e. 0x02 and 0x82) both will be deconfigured.\n\n"]
pub type usbd_hw_ep_deconfig = ::core::option::Option<unsafe extern "C" fn(ep: u8)>;
#[doc = "Reads data from OUT or control endpoint\n\nReturns:\n\n* size of the actually received data, -1 on error.\n\n# Arguments\n\n* `ep` - endpoint index, should belong to OUT or CONTROL endpoint.\n* `buf` - pointer to read buffer\n* `blen` - size of the read buffer in bytes\n\n# Notes\n\n* if data does not fit buffer it will be truncated\n\n"]
pub type usbd_hw_ep_read = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *mut core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "Writes data to IN or control endpoint\n\nReturns:\n\n* number of written bytes\n\n# Arguments\n\n* `ep` - endpoint index, hould belong to IN or CONTROL endpoint\n* `buf` - pointer to data buffer\n* `blen` - size of data will be written\n\n"]
pub type usbd_hw_ep_write = ::core::option::Option<
    unsafe extern "C" fn(ep: u8, buf: *const core::ffi::c_void, blen: u16) -> i32,
>;
#[doc = "Stalls and unstalls endpoint\n\n# Arguments\n\n* `ep` - endpoint address\n* `stall` - endpoint will be stalled if TRUE and unstalled otherwise.\n\n# Notes\n\n* Has no effect on inactive endpoints.\n\n"]
pub type usbd_hw_ep_setstall = ::core::option::Option<unsafe extern "C" fn(ep: u8, stall: bool)>;
#[doc = "Checks endpoint for stalled state\n\nReturns:\n\n* TRUE if endpoint is stalled\n\n# Arguments\n\n* `ep` - endpoint address\n\n"]
pub type usbd_hw_ep_isstalled = ::core::option::Option<unsafe extern "C" fn(ep: u8) -> bool>;
#[doc = "Polls USB hardware for the events\n\n# Arguments\n\n* `dev` - [Direction: In] pointer to usb device structure\n* `callback` - callback to event processing subroutine\n\n"]
pub type usbd_hw_poll = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut usbd_device, callback: usbd_evt_callback),
>;
#[doc = "Gets frame number from usb hardware.\n\n"]
pub type usbd_hw_get_frameno = ::core::option::Option<unsafe extern "C" fn() -> u16>;
#[doc = "Makes a string descriptor contains unique serial number from hardware ID's\n\nReturns:\n\n* of the descriptor in bytes\n\n# Arguments\n\n* `buffer` - [Direction: In] pointer to buffer for the descriptor\n\n"]
pub type usbd_hw_get_serialno =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut core::ffi::c_void) -> u16>;
#[doc = "Represents a hardware USB driver call table.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usbd_driver {
    #[doc = "<\\copybrief usbd_hw_getinfo\n\n"]
    pub getinfo: usbd_hw_getinfo,
    #[doc = "<\\copybrief usbd_hw_enable\n\n"]
    pub enable: usbd_hw_enable,
    #[doc = "<\\copybrief usbd_hw_connect\n\n"]
    pub connect: usbd_hw_connect,
    #[doc = "<\\copybrief usbd_hw_setaddr\n\n"]
    pub setaddr: usbd_hw_setaddr,
    #[doc = "<\\copybrief usbd_hw_ep_config\n\n"]
    pub ep_config: usbd_hw_ep_config,
    #[doc = "<\\copybrief usbd_hw_ep_deconfig\n\n"]
    pub ep_deconfig: usbd_hw_ep_deconfig,
    #[doc = "<\\copybrief usbd_hw_ep_read\n\n"]
    pub ep_read: usbd_hw_ep_read,
    #[doc = "<\\copybrief usbd_hw_ep_write\n\n"]
    pub ep_write: usbd_hw_ep_write,
    #[doc = "<\\copybrief usbd_hw_ep_setstall\n\n"]
    pub ep_setstall: usbd_hw_ep_setstall,
    #[doc = "<\\copybrief usbd_hw_ep_isstalled\n\n"]
    pub ep_isstalled: usbd_hw_ep_isstalled,
    #[doc = "<\\copybrief usbd_hw_poll\n\n"]
    pub poll: usbd_hw_poll,
    #[doc = "<\\copybrief usbd_hw_get_frameno\n\n"]
    pub frame_no: usbd_hw_get_frameno,
    #[doc = "<\\copybrief usbd_hw_get_serialno\n\n"]
    pub get_serialno_desc: usbd_hw_get_serialno,
}
#[test]
fn bindgen_test_layout_usbd_driver() {
    const UNINIT: ::core::mem::MaybeUninit<usbd_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usbd_driver>(),
        52usize,
        concat!("Size of: ", stringify!(usbd_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<usbd_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(usbd_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(getinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setaddr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(setaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_config) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_deconfig) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_deconfig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_write) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_setstall) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_setstall)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_isstalled) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(ep_isstalled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(poll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_no) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(frame_no)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_serialno_desc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(usbd_driver),
            "::",
            stringify!(get_serialno_desc)
        )
    );
}
#[doc = "Represents a USB device data.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usbd_device {
    #[doc = "<\\copybrief usbd_driver\n\n"]
    pub driver: *const usbd_driver,
    #[doc = "<\\copybrief usbd_ctl_callback\n\n"]
    pub control_callback: usbd_ctl_callback,
    #[doc = "<\\copybrief usbd_rqc_callback\n\n"]
    pub complete_callback: usbd_rqc_callback,
    #[doc = "<\\copybrief usbd_cfg_callback\n\n"]
    pub config_callback: usbd_cfg_callback,
    #[doc = "<\\copybrief usbd_dsc_callback\n\n"]
    pub descriptor_callback: usbd_dsc_callback,
    #[doc = "<\\brief array of the event callbacks.\n\n"]
    pub events: [usbd_evt_callback; 8usize],
    #[doc = "<\\brief array of the endpoint callbacks.\n\n"]
    pub endpoint: [usbd_evt_callback; 8usize],
    #[doc = "<\\copybrief usbd_status\n\n"]
    pub status: usbd_status,
}
#[test]
fn bindgen_test_layout__usbd_device() {
    const UNINIT: ::core::mem::MaybeUninit<_usbd_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_usbd_device>(),
        100usize,
        concat!("Size of: ", stringify!(_usbd_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_usbd_device>(),
        4usize,
        concat!("Alignment of ", stringify!(_usbd_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(control_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).complete_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(complete_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(config_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descriptor_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(descriptor_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_usbd_device),
            "::",
            stringify!(status)
        )
    );
}
#[doc = "Represents a USB device descriptor\n\nA device descriptor describes general information about a USB device. It includes information that applies globally to the device and all of the device’s configurations. A USB device has only one device descriptor. A high-speed capable device that has different device information for full-speed and high-speed must also  have a  [`usb_qualifier_descriptor`]\n\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_device_descriptor {
    #[doc = "<\\brief Size of the descriptor, in bytes.\n\n"]
    pub bLength: u8,
    #[doc = "<\\brief  [`USB_DTYPE_DEVICE`] Device descriptor.\n\n"]
    pub bDescriptorType: u8,
    #[doc = "<\\brief BCD of the supported USB specification.\n\n"]
    pub bcdUSB: u16,
    #[doc = "<\\brief USB device class.\n\n"]
    pub bDeviceClass: u8,
    #[doc = "<\\brief USB device subclass.\n\n"]
    pub bDeviceSubClass: u8,
    #[doc = "<\\brief USB device protocol.\n\n"]
    pub bDeviceProtocol: u8,
    #[doc = "<\\brief Size of the control endpoint's bank in bytes.\n\n"]
    pub bMaxPacketSize0: u8,
    #[doc = "<\\brief Vendor ID for the USB product.\n\n"]
    pub idVendor: u16,
    #[doc = "<\\brief Unique product ID for the USB product.\n\n"]
    pub idProduct: u16,
    #[doc = "<\\brief Product release (version) number.\n\n"]
    pub bcdDevice: u16,
    #[doc = "<\\brief String index for the manufacturer's name.\n\n"]
    pub iManufacturer: u8,
    #[doc = "<\\brief String index for the product name/details.\n\n"]
    pub iProduct: u8,
    #[doc = "<\\brief String index for the product serial number.\n\n"]
    pub iSerialNumber: u8,
    #[doc = "<\\brief Total number of configurations supported by the device.\n\n"]
    pub bNumConfigurations: u8,
}
#[test]
fn bindgen_test_layout_usb_device_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<usb_device_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_device_descriptor>(),
        18usize,
        concat!("Size of: ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_device_descriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_device_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDescriptorType) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDescriptorType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdUSB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceClass) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceSubClass) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceSubClass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDeviceProtocol) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bDeviceProtocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bMaxPacketSize0) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bMaxPacketSize0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idVendor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idVendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idProduct) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(idProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bcdDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bcdDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iManufacturer) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iManufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iProduct) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iProduct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iSerialNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(iSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bNumConfigurations) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_device_descriptor),
            "::",
            stringify!(bNumConfigurations)
        )
    );
}
extern "C" {
    pub static usbd_devfs: usbd_driver;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FuriHalUsbInterface {
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut usbd_device,
            intf: *mut FuriHalUsbInterface,
            ctx: *mut core::ffi::c_void,
        ),
    >,
    pub deinit: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub wakeup: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut usbd_device)>,
    pub dev_descr: *mut usb_device_descriptor,
    pub str_manuf_descr: *mut core::ffi::c_void,
    pub str_prod_descr: *mut core::ffi::c_void,
    pub str_serial_descr: *mut core::ffi::c_void,
    pub cfg_descr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FuriHalUsbInterface() {
    const UNINIT: ::core::mem::MaybeUninit<FuriHalUsbInterface> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FuriHalUsbInterface>(),
        36usize,
        concat!("Size of: ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<FuriHalUsbInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(FuriHalUsbInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deinit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_descr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(dev_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_manuf_descr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_manuf_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_prod_descr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_prod_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_serial_descr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(str_serial_descr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfg_descr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FuriHalUsbInterface),
            "::",
            stringify!(cfg_descr)
        )
    );
}
extern "C" {
    #[doc = "USB device interface modes\n\n"]
    pub static mut usb_cdc_single: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_cdc_dual: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_hid_u2f: FuriHalUsbInterface;
}
extern "C" {
    pub static mut usb_ccid: FuriHalUsbInterface;
}
extern "C" {
    #[doc = "Set USB device configuration\n\nReturns:\n\n* true - mode switch started, false - mode switch is locked\n\n# Arguments\n\n* `mode` - new USB device mode\n* `ctx` - context passed to device mode init function\n\n"]
    pub fn furi_hal_usb_set_config(
        new_if: *mut FuriHalUsbInterface,
        ctx: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Get USB device configuration\n\nReturns:\n\n* current USB device mode\n\n"]
    pub fn furi_hal_usb_get_config() -> *mut FuriHalUsbInterface;
}
extern "C" {
    #[doc = "Get USB device configuration context\n\nReturns:\n\n* current USB device context\n\n"]
    pub fn furi_hal_usb_get_config_context() -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Lock USB device mode switch\n\n"]
    pub fn furi_hal_usb_lock();
}
extern "C" {
    #[doc = "Unlock USB device mode switch\n\n"]
    pub fn furi_hal_usb_unlock();
}
extern "C" {
    #[doc = "Check if USB device mode switch locked\n\nReturns:\n\n* lock state\n\n"]
    pub fn furi_hal_usb_is_locked() -> bool;
}
extern "C" {
    #[doc = "Disable USB device\n\n"]
    pub fn furi_hal_usb_disable();
}
extern "C" {
    #[doc = "Enable USB device\n\n"]
    pub fn furi_hal_usb_enable();
}
extern "C" {
    #[doc = "Restart USB device\n\n"]
    pub fn furi_hal_usb_reinit();
}
pub type HidStateCallback =
    ::core::option::Option<unsafe extern "C" fn(state: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Get USB HID connection state\n\nReturns:\n\n* true / false\n\n"]
    pub fn furi_hal_hid_is_connected() -> bool;
}
extern "C" {
    #[doc = "Get USB HID keyboard leds state\n\nReturns:\n\n* leds state\n\n"]
    pub fn furi_hal_hid_get_led_state() -> u8;
}
extern "C" {
    #[doc = "Set USB HID connect/disconnect callback\n\n# Arguments\n\n* `cb` - callback\n* `ctx` - callback context\n\n"]
    pub fn furi_hal_hid_set_state_callback(cb: HidStateCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set the following key to pressed state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = "Set the following key to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = "Clear all pressed keys and send HID report\n\n"]
    pub fn furi_hal_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = "Set mouse movement and send HID report\n\n# Arguments\n\n* `dx` - x coordinate delta\n* `dy` - y coordinate delta\n\n"]
    pub fn furi_hal_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = "Set mouse button to pressed state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = "Set mouse button to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = "Set mouse wheel position and send HID report\n\n# Arguments\n\n* `delta` - number of scroll steps\n\n"]
    pub fn furi_hal_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = "Set the following consumer key to pressed state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = "Set the following consumer key to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_hid_consumer_key_release(button: u16) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CcidCallbacks {
    pub icc_power_on_callback: ::core::option::Option<
        unsafe extern "C" fn(
            dataBlock: *mut u8,
            dataBlockLen: *mut u32,
            context: *mut core::ffi::c_void,
        ),
    >,
    pub xfr_datablock_callback: ::core::option::Option<
        unsafe extern "C" fn(
            dataBlock: *const u8,
            dataBlockLen: u32,
            responseDataBlock: *mut u8,
            responseDataBlockLen: *mut u32,
            context: *mut core::ffi::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_CcidCallbacks() {
    const UNINIT: ::core::mem::MaybeUninit<CcidCallbacks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CcidCallbacks>(),
        8usize,
        concat!("Size of: ", stringify!(CcidCallbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<CcidCallbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(CcidCallbacks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icc_power_on_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CcidCallbacks),
            "::",
            stringify!(icc_power_on_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xfr_datablock_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CcidCallbacks),
            "::",
            stringify!(xfr_datablock_callback)
        )
    );
}
extern "C" {
    pub fn furi_hal_ccid_set_callbacks(cb: *mut CcidCallbacks);
}
extern "C" {
    pub fn furi_hal_ccid_ccid_insert_smartcard();
}
extern "C" {
    pub fn furi_hal_ccid_ccid_remove_smartcard();
}
pub const FuriHalUartId_FuriHalUartIdUSART1: FuriHalUartId = 0;
pub const FuriHalUartId_FuriHalUartIdLPUART1: FuriHalUartId = 1;
#[doc = "UART channels\n\n"]
pub type FuriHalUartId = core::ffi::c_uchar;
pub const UartIrqEvent_UartIrqEventRXNE: UartIrqEvent = 0;
#[doc = "UART events\n\n"]
pub type UartIrqEvent = core::ffi::c_uchar;
extern "C" {
    #[doc = "Init UART Configures GPIO to UART function, configures UART hardware, enables UART hardware\n\n# Arguments\n\n* `channel` - UART channel\n* `baud` - baudrate\n\n"]
    pub fn furi_hal_uart_init(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = "Deinit UART Configures GPIO to analog, clears callback and callback context, disables UART hardware\n\n# Arguments\n\n* `channel` - UART channel\n\n"]
    pub fn furi_hal_uart_deinit(channel: FuriHalUartId);
}
extern "C" {
    #[doc = "Suspend UART operation Disables UART hardware, settings and callbacks are preserved\n\n# Arguments\n\n* `channel` - UART channel\n\n"]
    pub fn furi_hal_uart_suspend(channel: FuriHalUartId);
}
extern "C" {
    #[doc = "Resume UART operation Resumes UART hardware from suspended state\n\n# Arguments\n\n* `channel` - UART channel\n\n"]
    pub fn furi_hal_uart_resume(channel: FuriHalUartId);
}
extern "C" {
    #[doc = "Changes UART baudrate\n\n# Arguments\n\n* `channel` - UART channel\n* `baud` - baudrate\n\n"]
    pub fn furi_hal_uart_set_br(channel: FuriHalUartId, baud: u32);
}
extern "C" {
    #[doc = "Transmits data\n\n# Arguments\n\n* `channel` - UART channel\n* `buffer` - data\n* `buffer_size` - data size (in bytes)\n\n"]
    pub fn furi_hal_uart_tx(channel: FuriHalUartId, buffer: *mut u8, buffer_size: usize);
}
extern "C" {
    #[doc = "Sets UART event callback\n\n# Arguments\n\n* `channel` - UART channel\n* `callback` - callback pointer\n* `context` - callback context\n\n"]
    pub fn furi_hal_uart_set_irq_cb(
        channel: FuriHalUartId,
        callback: ::core::option::Option<
            unsafe extern "C" fn(event: UartIrqEvent, data: u8, context: *mut core::ffi::c_void),
        >,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_info_get_api_version(major: *mut u16, minor: *mut u16);
}
extern "C" {
    #[doc = "Get device information\n\n# Arguments\n\n* `callback` - [Direction: In] callback to provide with new data\n* `sep` - [Direction: In] category separator character\n* `context` - [Direction: In] context to pass to callback\n\n"]
    pub fn furi_hal_info_get(
        callback: PropertyValueCallback,
        sep: core::ffi::c_char,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Initialize random subsystem\n\n"]
    pub fn furi_hal_random_init();
}
extern "C" {
    #[doc = "Get random value\n\nReturns:\n\n* random value\n\n"]
    pub fn furi_hal_random_get() -> u32;
}
extern "C" {
    #[doc = "Fill buffer with random data\n\n# Arguments\n\n* `buf` - buffer pointer\n* `data` - buffer len\n\n"]
    pub fn furi_hal_random_fill_buf(buf: *mut u8, len: u32);
}
#[doc = "default configuration\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetIDLE: FuriHalSubGhzPreset = 0;
#[doc = "OOK, bandwidth 270kHz, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok270Async: FuriHalSubGhzPreset = 1;
#[doc = "OOK, bandwidth 650kHz, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetOok650Async: FuriHalSubGhzPreset = 2;
#[doc = "FM, deviation 2.380371 kHz, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev238Async: FuriHalSubGhzPreset = 3;
#[doc = "FM, deviation 47.60742 kHz, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPreset2FSKDev476Async: FuriHalSubGhzPreset = 4;
#[doc = "MSK, deviation 47.60742 kHz, 99.97Kb/s, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetMSK99_97KbAsync: FuriHalSubGhzPreset = 5;
#[doc = "GFSK, deviation 19.042969 kHz, 9.996Kb/s, asynchronous\n\n"]
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetGFSK9_99KbAsync: FuriHalSubGhzPreset = 6;
pub const FuriHalSubGhzPreset_FuriHalSubGhzPresetCustom: FuriHalSubGhzPreset = 7;
#[doc = "Radio Presets\n\n"]
pub type FuriHalSubGhzPreset = core::ffi::c_uchar;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct LevelDuration {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_LevelDuration() {
    assert_eq!(
        ::core::mem::size_of::<LevelDuration>(),
        4usize,
        concat!("Size of: ", stringify!(LevelDuration))
    );
    assert_eq!(
        ::core::mem::align_of::<LevelDuration>(),
        4usize,
        concat!("Alignment of ", stringify!(LevelDuration))
    );
}
impl LevelDuration {
    #[inline]
    pub fn duration(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_duration(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(duration: u32, level: u8) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let duration: u32 = unsafe { ::core::mem::transmute(duration) };
            duration as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let level: u8 = unsafe { ::core::mem::transmute(level) };
            level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Isolate Radio from antenna\n\n"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPathIsolate: FuriHalSubGhzPath = 0;
#[doc = "Center Frequency: 433MHz. Path 1: SW1RF1-SW2RF2, LCLCL\n\n"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath433: FuriHalSubGhzPath = 1;
#[doc = "Center Frequency: 315MHz. Path 2: SW1RF2-SW2RF1, LCLCLCL\n\n"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath315: FuriHalSubGhzPath = 2;
#[doc = "Center Frequency: 868MHz. Path 3: SW1RF3-SW2RF3, LCLC\n\n"]
pub const FuriHalSubGhzPath_FuriHalSubGhzPath868: FuriHalSubGhzPath = 3;
#[doc = "Switchable Radio Paths\n\n"]
pub type FuriHalSubGhzPath = core::ffi::c_uchar;
extern "C" {
    pub fn furi_hal_subghz_set_async_mirror_pin(pin: *const GpioPin);
}
extern "C" {
    #[doc = "Get data GPIO\n\nReturns:\n\n* pointer to the gpio pin structure\n\n"]
    pub fn furi_hal_subghz_get_data_gpio() -> *const GpioPin;
}
extern "C" {
    #[doc = "Send device to sleep mode\n\n"]
    pub fn furi_hal_subghz_sleep();
}
extern "C" {
    #[doc = "Load custom registers from preset\n\n# Arguments\n\n* `preset_data` - registers to load\n\n"]
    pub fn furi_hal_subghz_load_custom_preset(preset_data: *const u8);
}
extern "C" {
    #[doc = "Load registers\n\n# Arguments\n\n* `data` - Registers data\n\n"]
    pub fn furi_hal_subghz_load_registers(data: *const u8);
}
extern "C" {
    #[doc = "Load PATABLE\n\n# Arguments\n\n* `data` - 8 uint8_t values\n\n"]
    pub fn furi_hal_subghz_load_patable(data: *const u8);
}
extern "C" {
    #[doc = "Write packet to FIFO\n\n# Arguments\n\n* `data` - bytes array\n* `size` - size\n\n"]
    pub fn furi_hal_subghz_write_packet(data: *const u8, size: u8);
}
extern "C" {
    #[doc = "Check if receive pipe is not empty\n\nReturns:\n\n* true if not empty\n\n"]
    pub fn furi_hal_subghz_rx_pipe_not_empty() -> bool;
}
extern "C" {
    #[doc = "Check if received data crc is valid\n\nReturns:\n\n* true if valid\n\n"]
    pub fn furi_hal_subghz_is_rx_data_crc_valid() -> bool;
}
extern "C" {
    #[doc = "Read packet from FIFO\n\n# Arguments\n\n* `data` - pointer\n* `size` - size\n\n"]
    pub fn furi_hal_subghz_read_packet(data: *mut u8, size: *mut u8);
}
extern "C" {
    #[doc = "Flush rx FIFO buffer\n\n"]
    pub fn furi_hal_subghz_flush_rx();
}
extern "C" {
    #[doc = "Flush tx FIFO buffer\n\n"]
    pub fn furi_hal_subghz_flush_tx();
}
extern "C" {
    #[doc = "Shutdown Issue SPWD command\n\n**Warning!**\n\n* registers content will be lost\n\n"]
    pub fn furi_hal_subghz_shutdown();
}
extern "C" {
    #[doc = "Reset Issue reset command\n\n**Warning!**\n\n* registers content will be lost\n\n"]
    pub fn furi_hal_subghz_reset();
}
extern "C" {
    #[doc = "Switch to Idle\n\n"]
    pub fn furi_hal_subghz_idle();
}
extern "C" {
    #[doc = "Switch to Receive\n\n"]
    pub fn furi_hal_subghz_rx();
}
extern "C" {
    #[doc = "Switch to Transmit\n\nReturns:\n\n* true if the transfer is allowed by belonging to the region\n\n"]
    pub fn furi_hal_subghz_tx() -> bool;
}
extern "C" {
    #[doc = "Get RSSI value in dBm\n\nReturns:\n\n* RSSI value\n\n"]
    pub fn furi_hal_subghz_get_rssi() -> f32;
}
extern "C" {
    #[doc = "Get LQI\n\nReturns:\n\n* LQI value\n\n"]
    pub fn furi_hal_subghz_get_lqi() -> u8;
}
extern "C" {
    #[doc = "Check if frequency is in valid range\n\nReturns:\n\n* true if frequency is valid, otherwise false\n\n# Arguments\n\n* `value` - frequency in Hz\n\n"]
    pub fn furi_hal_subghz_is_frequency_valid(value: u32) -> bool;
}
extern "C" {
    #[doc = "Set frequency and path This function automatically selects antenna matching network\n\nReturns:\n\n* real frequency in Hz\n\n# Arguments\n\n* `value` - frequency in Hz\n\n"]
    pub fn furi_hal_subghz_set_frequency_and_path(value: u32) -> u32;
}
extern "C" {
    #[doc = "Сheck if transmission is allowed on this frequency with your current config\n\nReturns:\n\n* true if allowed\n\n# Arguments\n\n* `value` - frequency in Hz\n\n"]
    pub fn furi_hal_subghz_is_tx_allowed(value: u32) -> bool;
}
extern "C" {
    #[doc = "Get the current rolling protocols counter ++/-- value\n\nReturns:\n\n* int8_t current value\n\n"]
    pub fn furi_hal_subghz_get_rolling_counter_mult() -> i8;
}
extern "C" {
    #[doc = "Set the current rolling protocols counter ++/-- value\n\n# Arguments\n\n* `mult` - int8_t = -1, -10, -100, 0, 1, 10, 100\n\n"]
    pub fn furi_hal_subghz_set_rolling_counter_mult(mult: i8);
}
extern "C" {
    #[doc = "Set frequency\n\nReturns:\n\n* real frequency in Hz\n\n# Arguments\n\n* `value` - frequency in Hz\n\n"]
    pub fn furi_hal_subghz_set_frequency(value: u32) -> u32;
}
extern "C" {
    #[doc = "Set path\n\n# Arguments\n\n* `path` - path to use\n\n"]
    pub fn furi_hal_subghz_set_path(path: FuriHalSubGhzPath);
}
#[doc = "Signal Timings Capture callback\n\n"]
pub type FuriHalSubGhzCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Enable signal timings capture Initializes GPIO and TIM2 for timings capture\n\n# Arguments\n\n* `callback` - FuriHalSubGhzCaptureCallback\n* `context` - callback context\n\n"]
    pub fn furi_hal_subghz_start_async_rx(
        callback: FuriHalSubGhzCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Disable signal timings capture Resets GPIO and TIM2\n\n"]
    pub fn furi_hal_subghz_stop_async_rx();
}
#[doc = "Async TX callback type\n\nReturns:\n\n* LevelDuration\n\n# Arguments\n\n* `context` - callback context\n\n"]
pub type FuriHalSubGhzAsyncTxCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
extern "C" {
    #[doc = "Start async TX Initializes GPIO, TIM2 and DMA1 for signal output\n\nReturns:\n\n* true if the transfer is allowed by belonging to the region\n\n# Arguments\n\n* `callback` - FuriHalSubGhzAsyncTxCallback\n* `context` - callback context\n\n"]
    pub fn furi_hal_subghz_start_async_tx(
        callback: FuriHalSubGhzAsyncTxCallback,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Wait for async transmission to complete\n\nReturns:\n\n* true if TX complete\n\n"]
    pub fn furi_hal_subghz_is_async_tx_complete() -> bool;
}
extern "C" {
    #[doc = "Stop async transmission and cleanup resources Resets GPIO, TIM2, and DMA1\n\n"]
    pub fn furi_hal_subghz_stop_async_tx();
}
extern "C" {
    pub fn furi_hal_subghz_set_ext_power_amp(enabled: bool);
}
extern "C" {
    pub fn furi_hal_subghz_get_ext_power_amp() -> bool;
}
pub type FuriHalIbuttonEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Start emulation timer\n\n# Arguments\n\n* `period` - timer period\n* `callback` - timer callback\n* `context` - callback context\n\n"]
    pub fn furi_hal_ibutton_emulate_start(
        period: u32,
        callback: FuriHalIbuttonEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Update emulation timer period\n\n# Arguments\n\n* `period` - new timer period\n\n"]
    pub fn furi_hal_ibutton_emulate_set_next(period: u32);
}
extern "C" {
    #[doc = "Stop emulation timer\n\n"]
    pub fn furi_hal_ibutton_emulate_stop();
}
extern "C" {
    #[doc = "Set the pin to normal mode (open collector), and sets it to float\n\n"]
    pub fn furi_hal_ibutton_pin_configure();
}
extern "C" {
    #[doc = "Sets the pin to analog mode, and sets it to float\n\n"]
    pub fn furi_hal_ibutton_pin_reset();
}
extern "C" {
    #[doc = "iButton write pin\n\n# Arguments\n\n* `state` - true / false\n\n"]
    pub fn furi_hal_ibutton_pin_write(state: bool);
}
extern "C" {
    #[doc = "Config rfid pins to reset state\n\n"]
    pub fn furi_hal_rfid_pins_reset();
}
extern "C" {
    #[doc = "Release rfid pull pin\n\n"]
    pub fn furi_hal_rfid_pin_pull_release();
}
extern "C" {
    #[doc = "Pulldown rfid pull pin\n\n"]
    pub fn furi_hal_rfid_pin_pull_pulldown();
}
extern "C" {
    #[doc = "Start read timer\n\n# Arguments\n\n* `freq` - timer frequency\n* `duty_cycle` - timer duty cycle, 0.0-1.0\n\n"]
    pub fn furi_hal_rfid_tim_read_start(freq: f32, duty_cycle: f32);
}
extern "C" {
    #[doc = "Pause read timer, to be able to continue later\n\n"]
    pub fn furi_hal_rfid_tim_read_pause();
}
extern "C" {
    #[doc = "Continue read timer\n\n"]
    pub fn furi_hal_rfid_tim_read_continue();
}
extern "C" {
    #[doc = "Stop read timer\n\n"]
    pub fn furi_hal_rfid_tim_read_stop();
}
pub type FuriHalRfidReadCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(level: bool, duration: u32, context: *mut core::ffi::c_void),
>;
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_start(
        callback: FuriHalRfidReadCaptureCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_read_capture_stop();
}
pub type FuriHalRfidDMACallback =
    ::core::option::Option<unsafe extern "C" fn(half: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_start(
        duration: *mut u32,
        pulse: *mut u32,
        length: usize,
        callback: FuriHalRfidDMACallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_rfid_tim_emulate_dma_stop();
}
extern "C" {
    #[doc = "Set read timer period\n\n# Arguments\n\n* `period` - overall duration\n\n"]
    pub fn furi_hal_rfid_set_read_period(period: u32);
}
extern "C" {
    #[doc = "Set read timer pulse\n\n# Arguments\n\n* `pulse` - duration of high level\n\n"]
    pub fn furi_hal_rfid_set_read_pulse(pulse: u32);
}
extern "C" {
    #[doc = "Start/Enable comparator\n\n"]
    pub fn furi_hal_rfid_comp_start();
}
extern "C" {
    #[doc = "Stop/Disable comparator\n\n"]
    pub fn furi_hal_rfid_comp_stop();
}
pub type FuriHalRfidCompCallback =
    ::core::option::Option<unsafe extern "C" fn(level: bool, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Set comparator callback\n\n"]
    pub fn furi_hal_rfid_comp_set_callback(
        callback: FuriHalRfidCompCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start/Enable Field Presence detect\n\n"]
    pub fn furi_hal_rfid_field_detect_start();
}
extern "C" {
    #[doc = "Stop/Disable Field Presence detect\n\n"]
    pub fn furi_hal_rfid_field_detect_stop();
}
extern "C" {
    #[doc = "Check Field Presence\n\nReturns:\n\n* true if field is present, false if not\n\n# Arguments\n\n* `frequency` - [Direction: In, Out] pointer to frequency value to be set if filed detected\n\n"]
    pub fn furi_hal_rfid_field_is_present(frequency: *mut u32) -> bool;
}
#[doc = "Oscillator has been started.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventOscOn: FuriHalNfcEvent = 1;
#[doc = "External field (carrier) has been detected.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventFieldOn: FuriHalNfcEvent = 2;
#[doc = "External field (carrier) has been lost.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventFieldOff: FuriHalNfcEvent = 4;
#[doc = "Reader has issued a wake-up command.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventListenerActive: FuriHalNfcEvent = 8;
#[doc = "Transmission has started.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventTxStart: FuriHalNfcEvent = 16;
#[doc = "Transmission has ended.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventTxEnd: FuriHalNfcEvent = 32;
#[doc = "Reception has started.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventRxStart: FuriHalNfcEvent = 64;
#[doc = "Reception has ended.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventRxEnd: FuriHalNfcEvent = 128;
#[doc = "A collision has occurred.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventCollision: FuriHalNfcEvent = 256;
#[doc = "Frame wait timer has expired.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventTimerFwtExpired: FuriHalNfcEvent = 512;
#[doc = "Transmission block timer has expired.\n\n"]
pub const FuriHalNfcEvent_FuriHalNfcEventTimerBlockTxExpired: FuriHalNfcEvent = 1024;
pub const FuriHalNfcEvent_FuriHalNfcEventTimeout: FuriHalNfcEvent = 2048;
pub const FuriHalNfcEvent_FuriHalNfcEventAbortRequest: FuriHalNfcEvent = 4096;
#[doc = "Enumeration of possible NFC HAL events.\n\n"]
pub type FuriHalNfcEvent = core::ffi::c_ushort;
#[doc = "No error has occurred.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorNone: FuriHalNfcError = 0;
#[doc = "The communication bus is busy.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorBusy: FuriHalNfcError = 1;
#[doc = "NFC hardware did not respond or responded unexpectedly.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorCommunication: FuriHalNfcError = 2;
#[doc = "Oscillator failed to start.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorOscillator: FuriHalNfcError = 3;
#[doc = "NFC hardware did not respond in time.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorCommunicationTimeout: FuriHalNfcError = 4;
#[doc = "Receive buffer was too small for the received data.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorBufferOverflow: FuriHalNfcError = 5;
#[doc = "Not enough data was received to parse a valid frame.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorIncompleteFrame: FuriHalNfcError = 6;
#[doc = "Cannot parse a frame due to unexpected/invalid data.\n\n"]
pub const FuriHalNfcError_FuriHalNfcErrorDataFormat: FuriHalNfcError = 7;
#[doc = "Enumeration of possible NFC HAL errors.\n\n"]
pub type FuriHalNfcError = core::ffi::c_uchar;
#[doc = "Configure NFC HAL to operate as a poller.\n\n"]
pub const FuriHalNfcMode_FuriHalNfcModePoller: FuriHalNfcMode = 0;
#[doc = "Configure NFC HAL to operate as a listener.\n\n"]
pub const FuriHalNfcMode_FuriHalNfcModeListener: FuriHalNfcMode = 1;
#[doc = "Special value equal to the operating modes count. Internal use.\n\n"]
pub const FuriHalNfcMode_FuriHalNfcModeNum: FuriHalNfcMode = 2;
#[doc = "Enumeration of possible NFC HAL operating modes.\n\n"]
pub type FuriHalNfcMode = core::ffi::c_uchar;
#[doc = "Configure NFC HAL to use the ISO14443 (type A) technology.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechIso14443a: FuriHalNfcTech = 0;
#[doc = "Configure NFC HAL to use the ISO14443 (type B) technology.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechIso14443b: FuriHalNfcTech = 1;
#[doc = "Configure NFC HAL to use the ISO15693 technology.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechIso15693: FuriHalNfcTech = 2;
#[doc = "Configure NFC HAL to use the FeliCa technology.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechFelica: FuriHalNfcTech = 3;
#[doc = "Special value equal to the supported technologies count. Internal use.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechNum: FuriHalNfcTech = 4;
#[doc = "Special value indicating the unconfigured state. Internal use.\n\n"]
pub const FuriHalNfcTech_FuriHalNfcTechInvalid: FuriHalNfcTech = 5;
#[doc = "Enumeration of supported NFC technologies.\n\n"]
pub type FuriHalNfcTech = core::ffi::c_uchar;
extern "C" {
    #[doc = "Initialise the NFC HAL and associated hardware.\n\nThis function is called automatically during the firmware initialisation, so there is no need to call it explicitly.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_init() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Check whether the NFC HAL was properly initialised and is ready.\n\nReturns:\n\n* FuriHalNfcErrorNone if ready, any other error code if not ready.\n\n"]
    pub fn furi_hal_nfc_is_hal_ready() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Exclusively take over the NFC HAL and associated hardware.\n\nThis function needs to be called whenever an interaction with the NFC HAL is to take place (usually once upon the application start).\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_acquire() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Release the exclusive lock and make the NFC HAL available for others.\n\nThis function needs to be called when the user code is done working with the NFC HAL (usually once upon application exit). It must be called from the same thread that has called furi_hal_nfc_acquire().\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_release() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Configure the NFC hardware to enter the low-power mode.\n\nThis function must be called each time when the user code is done working with the NFC HAL for the time being (e.g. waiting on user input).\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_low_power_mode_start() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Configure the NFC hardware to exit the low-power mode.\n\nThis function must be called each time when the user code begins working with the NFC HAL, as the default state is low-power mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_low_power_mode_stop() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Configure the NFC HAL to work in a particular mode.\n\nNot all technologies implement the listener operating mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `mode` - [Direction: In] required operating mode.\n* `tech` - [Direction: In] required technology configuration.\n\n"]
    pub fn furi_hal_nfc_set_mode(mode: FuriHalNfcMode, tech: FuriHalNfcTech) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Reset the NFC HAL to its default (unconfigured) state.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_reset_mode() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Enable field (carrier) detection by the NFC hardware.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_field_detect_start() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Disable field (carrier) detection by the NFC hardware.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_field_detect_stop() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Check if the reader field (carrier) was detected by the NFC hardware.\n\nReturns:\n\n* true if the field was detected, false otherwise.\n\n"]
    pub fn furi_hal_nfc_field_is_present() -> bool;
}
extern "C" {
    #[doc = "Enable field (carrier) generation by the NFC hardware.\n\nNo carrier modulation will occur unless a transmission is explicitly started.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_poller_field_on() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Wait for an NFC HAL event in poller mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `timeout_ms` - [Direction: In] time to wait (timeout) in milliseconds.\n\n"]
    pub fn furi_hal_nfc_poller_wait_event(timeout_ms: u32) -> FuriHalNfcEvent;
}
extern "C" {
    #[doc = "Wait for an NFC HAL event in listener mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `timeout_ms` - [Direction: In] time to wait (timeout) in milliseconds.\n\n"]
    pub fn furi_hal_nfc_listener_wait_event(timeout_ms: u32) -> FuriHalNfcEvent;
}
extern "C" {
    #[doc = "Transmit data in poller mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `tx_data` - [Direction: In] pointer to a byte array containing the data to be transmitted.\n* `tx_bits` - [Direction: In] transmit data size, in bits.\n\n"]
    pub fn furi_hal_nfc_poller_tx(tx_data: *const u8, tx_bits: usize) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Receive data in poller mode.\n\nThe receive buffer must be big enough to accomodate all of the expected data.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `rx_data[out]` - pointer to a byte array to be filled with received data.\n* `rx_data_size[in]` - maximum received data size, in bytes.\n* `rx_bits[out]` - pointer to the variable to hold received data size, in bits.\n\n"]
    pub fn furi_hal_nfc_poller_rx(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Transmit data in listener mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `tx_data` - [Direction: In] pointer to a byte array containing the data to be transmitted.\n* `tx_bits` - [Direction: In] transmit data size, in bits.\n\n"]
    pub fn furi_hal_nfc_listener_tx(tx_data: *const u8, tx_bits: usize) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Receive data in listener mode.\n\nThe receive buffer must be big enough to accomodate all of the expected data.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `rx_data[out]` - pointer to a byte array to be filled with received data.\n* `rx_data_size[in]` - maximum received data size, in bytes.\n* `rx_bits[out]` - pointer to the variable to hold received data size, in bits.\n\n"]
    pub fn furi_hal_nfc_listener_rx(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Go to sleep in listener mode.\n\nPuts the passive target logic into Sleep (Halt) state.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_listener_sleep() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Go to idle in listener mode.\n\nPuts the passive target logic into Sense (Idle) state.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_listener_idle() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Enable reception in listener mode.\n\nStarts hardware receivers and receive decoders.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_listener_enable_rx() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Reset communication.\n\nResets the communication state and stops all activities: transmission, reception, etc.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_trx_reset() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Enable generation of NFC HAL events.\n\n**Warning!**\n\n* This function must be called from the same thread from which the the furi_hal_nfc_*_wait_event() calls will be made.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_event_start() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Disable generation of NFC HAL events.\n\nUnlike furi_hal_nfc_event_start(), this function may be called from any thread.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_event_stop() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Manually emit the FuriHalNfcEventAbortRequest event.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n"]
    pub fn furi_hal_nfc_abort() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Start frame wait timeout timer.\n\n# Arguments\n\n* `time_fc` - [Direction: In] time to wait, in carrier cycles.\n\n"]
    pub fn furi_hal_nfc_timer_fwt_start(time_fc: u32);
}
extern "C" {
    #[doc = "Stop frame wait timeout timer.\n\n"]
    pub fn furi_hal_nfc_timer_fwt_stop();
}
extern "C" {
    #[doc = "Start block transmit (frame delay) timer.\n\n# Arguments\n\n* `time_fc` - [Direction: In] time to wait, in carrier cycles.\n\n"]
    pub fn furi_hal_nfc_timer_block_tx_start(time_fc: u32);
}
extern "C" {
    #[doc = "Start block transmit (frame delay) timer.\n\n# Arguments\n\n* `time_us` - [Direction: In] time to wait, in microseconds.\n\n"]
    pub fn furi_hal_nfc_timer_block_tx_start_us(time_us: u32);
}
extern "C" {
    #[doc = "Stop block transmit (frame delay) timer.\n\n"]
    pub fn furi_hal_nfc_timer_block_tx_stop();
}
extern "C" {
    #[doc = "Check whether block transmit (frame delay) timer is running.\n\nReturns:\n\n* true if timer is running, false otherwise.\n\n"]
    pub fn furi_hal_nfc_timer_block_tx_is_running() -> bool;
}
pub const FuriHalNfcaShortFrame_FuriHalNfcaShortFrameAllReq: FuriHalNfcaShortFrame = 0;
pub const FuriHalNfcaShortFrame_FuriHalNfcaShortFrameSensReq: FuriHalNfcaShortFrame = 1;
#[doc = "Enumeration of ISO14443 (Type A) short frame types.\n\n"]
pub type FuriHalNfcaShortFrame = core::ffi::c_uchar;
extern "C" {
    #[doc = "Transmit ISO14443 (Type A) short frame in poller mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `frame` - [Direction: In] short frame type to be transmitted.\n\n"]
    pub fn furi_hal_nfc_iso14443a_poller_trx_short_frame(
        frame: FuriHalNfcaShortFrame,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Transmit ISO14443 (Type A) SDD frame in poller mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `tx_data` - [Direction: In] pointer to a byte array containing the data to be transmitted.\n* `tx_bits` - [Direction: In] transmit data size, in bits.\n\n"]
    pub fn furi_hal_nfc_iso14443a_tx_sdd_frame(
        tx_data: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Receive ISO14443 (Type A) SDD frame in poller mode.\nThe receive buffer must be big enough to accomodate all of the expected data.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `rx_data[out]` - pointer to a byte array to be filled with received data.\n* `rx_data_size[in]` - maximum received data size, in bytes.\n* `rx_bits[out]` - pointer to the variable to hold received data size, in bits.\n\n"]
    pub fn furi_hal_nfc_iso14443a_rx_sdd_frame(
        rx_data: *mut u8,
        rx_data_size: usize,
        rx_bits: *mut usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Transmit ISO14443 (Type A) frame with custom parity bits in poller mode.\n\nSame as furi_hal_nfc_poller_tx(), but uses the parity bits provided by the user code instead of calculating them automatically.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `tx_data` - [Direction: In] pointer to a byte array containing the data to be transmitted.\n* `tx_bits` - [Direction: In] transmit data size, in bits.\n\n"]
    pub fn furi_hal_nfc_iso14443a_poller_tx_custom_parity(
        tx_data: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Set ISO14443 (Type A) collision resolution parameters in listener mode.\n\nConfigures the NFC hardware for automatic collision resolution.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `uid` - [Direction: In] pointer to a byte array containing the UID.\n* `uid_len` - [Direction: In] UID length in bytes (must be supported by the protocol).\n* `atqa` - [Direction: In] ATQA byte value.\n* `sak` - [Direction: In] SAK byte value.\n\n"]
    pub fn furi_hal_nfc_iso14443a_listener_set_col_res_data(
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Transmit ISO14443 (Type A) frame with custom parity bits in listener mode.\n\nReturns:\n\n* FuriHalNfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `tx_data` - [Direction: In] pointer to a byte array containing the data to be transmitted.\n* `tx_parity` - [Direction: In] pointer to a (bit-packed) byte array containing the parity to be transmitted.\n* `tx_bits` - [Direction: In] transmit data size, in bits.\n\n"]
    pub fn furi_hal_nfc_iso14443a_listener_tx_custom_parity(
        tx_data: *const u8,
        tx_parity: *const u8,
        tx_bits: usize,
    ) -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Send ISO15693 SOF in listener mode\n\nReturns:\n\n* FuriHalNfcError\n\n"]
    pub fn furi_hal_nfc_iso15693_listener_tx_sof() -> FuriHalNfcError;
}
extern "C" {
    #[doc = "Transfer execution to address\n\n# Arguments\n\n* `address` - [Direction: In] pointer to new executable\n\n"]
    pub fn furi_hal_switch(address: *mut core::ffi::c_void);
}
pub type Elf32_Addr = u32;
#[doc = "Interface for ELF loader to resolve symbols\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ElfApiInterface {
    pub api_version_major: u16,
    pub api_version_minor: u16,
    pub resolver_callback: ::core::option::Option<
        unsafe extern "C" fn(
            interface: *const ElfApiInterface,
            hash: u32,
            address: *mut Elf32_Addr,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_ElfApiInterface() {
    const UNINIT: ::core::mem::MaybeUninit<ElfApiInterface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ElfApiInterface>(),
        8usize,
        concat!("Size of: ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        ::core::mem::align_of::<ElfApiInterface>(),
        4usize,
        concat!("Alignment of ", stringify!(ElfApiInterface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version_minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(api_version_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolver_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ElfApiInterface),
            "::",
            stringify!(resolver_callback)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestBase {
    pub manifest_magic: u32,
    pub manifest_version: u32,
    pub api_version: FlipperApplicationManifestBase__bindgen_ty_1,
    pub hardware_target_id: u16,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union FlipperApplicationManifestBase__bindgen_ty_1 {
    pub __bindgen_anon_1: FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    pub version: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1 {
    pub minor: u16,
    pub major: u16,
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(major)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase__bindgen_ty_1),
            "::",
            stringify!(version)
        )
    );
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestBase() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestBase>(),
        14usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestBase>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manifest_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(manifest_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).api_version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(api_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hardware_target_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestBase),
            "::",
            stringify!(hardware_target_id)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct FlipperApplicationManifestV1 {
    pub base: FlipperApplicationManifestBase,
    pub stack_size: u16,
    pub app_version: u32,
    pub name: [core::ffi::c_char; 32usize],
    pub has_icon: core::ffi::c_char,
    pub icon: [core::ffi::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_FlipperApplicationManifestV1() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperApplicationManifestV1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperApplicationManifestV1>(),
        85usize,
        concat!("Size of: ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperApplicationManifestV1>(),
        1usize,
        concat!("Alignment of ", stringify!(FlipperApplicationManifestV1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app_version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(app_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_icon) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(has_icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperApplicationManifestV1),
            "::",
            stringify!(icon)
        )
    );
}
pub type FlipperApplicationManifest = FlipperApplicationManifestV1;
extern "C" {
    #[doc = "Check if manifest is valid\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `manifest` - \n\n"]
    pub fn flipper_application_manifest_is_valid(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
extern "C" {
    #[doc = "Check if API Version declared in manifest is older than firmware ELF API interface\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `manifest` - The manifest\n* `api_interface` - The api interface\n\n"]
    pub fn flipper_application_manifest_is_too_old(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
extern "C" {
    #[doc = "Check if API Version declared in manifest is newer than firmware ELF API interface\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `manifest` - The manifest\n* `api_interface` - The api interface\n\n"]
    pub fn flipper_application_manifest_is_too_new(
        manifest: *const FlipperApplicationManifest,
        api_interface: *const ElfApiInterface,
    ) -> bool;
}
extern "C" {
    #[doc = "Check if application is compatible with current hardware\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `manifest` - \n\n"]
    pub fn flipper_application_manifest_is_target_compatible(
        manifest: *const FlipperApplicationManifest,
    ) -> bool;
}
#[doc = "Read access\n\n"]
pub const FS_AccessMode_FSAM_READ: FS_AccessMode = 1;
#[doc = "Write access\n\n"]
pub const FS_AccessMode_FSAM_WRITE: FS_AccessMode = 2;
#[doc = "Read and write access\n\n"]
pub const FS_AccessMode_FSAM_READ_WRITE: FS_AccessMode = 3;
#[doc = "Access mode flags\n\n"]
pub type FS_AccessMode = core::ffi::c_uchar;
#[doc = "Open file, fail if file doesn't exist\n\n"]
pub const FS_OpenMode_FSOM_OPEN_EXISTING: FS_OpenMode = 1;
#[doc = "Open file. Create new file if not exist\n\n"]
pub const FS_OpenMode_FSOM_OPEN_ALWAYS: FS_OpenMode = 2;
#[doc = "Open file. Create new file if not exist. Set R/W pointer to EOF\n\n"]
pub const FS_OpenMode_FSOM_OPEN_APPEND: FS_OpenMode = 4;
#[doc = "Creates a new file. Fails if the file is exist\n\n"]
pub const FS_OpenMode_FSOM_CREATE_NEW: FS_OpenMode = 8;
#[doc = "Creates a new file. If file exist, truncate to zero size\n\n"]
pub const FS_OpenMode_FSOM_CREATE_ALWAYS: FS_OpenMode = 16;
#[doc = "Open mode flags\n\n"]
pub type FS_OpenMode = core::ffi::c_uchar;
#[doc = "No error\n\n"]
pub const FS_Error_FSE_OK: FS_Error = 0;
#[doc = "FS not ready\n\n"]
pub const FS_Error_FSE_NOT_READY: FS_Error = 1;
#[doc = "File/Dir already exist\n\n"]
pub const FS_Error_FSE_EXIST: FS_Error = 2;
#[doc = "File/Dir does not exist\n\n"]
pub const FS_Error_FSE_NOT_EXIST: FS_Error = 3;
#[doc = "Invalid API parameter\n\n"]
pub const FS_Error_FSE_INVALID_PARAMETER: FS_Error = 4;
#[doc = "Access denied\n\n"]
pub const FS_Error_FSE_DENIED: FS_Error = 5;
#[doc = "Invalid name/path\n\n"]
pub const FS_Error_FSE_INVALID_NAME: FS_Error = 6;
#[doc = "Internal error\n\n"]
pub const FS_Error_FSE_INTERNAL: FS_Error = 7;
#[doc = "Function not implemented\n\n"]
pub const FS_Error_FSE_NOT_IMPLEMENTED: FS_Error = 8;
#[doc = "File/Dir already opened\n\n"]
pub const FS_Error_FSE_ALREADY_OPEN: FS_Error = 9;
#[doc = "API errors enumeration\n\n"]
pub type FS_Error = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    _unused: [u8; 0],
}
#[doc = "Structure that hold file info\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo {
    #[doc = "flags from FS_Flags enum\n\n"]
    pub flags: u8,
    #[doc = "file size\n\n"]
    pub size: u64,
}
#[test]
fn bindgen_test_layout_FileInfo() {
    const UNINIT: ::core::mem::MaybeUninit<FileInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FileInfo>(),
        16usize,
        concat!("Size of: ", stringify!(FileInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<FileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(FileInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FileInfo),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = "Gets the error text from FS_Error\n\nReturns:\n\n* const char* error text\n\n# Arguments\n\n* `error_id` - error id\n\n"]
    pub fn filesystem_api_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Checks if file info is directory\n\nReturns:\n\n* bool is directory\n\n# Arguments\n\n* `file_info` - file info pointer\n\n"]
    pub fn file_info_is_dir(file_info: *const FileInfo) -> bool;
}
pub const SDFsType_FST_UNKNOWN: SDFsType = 0;
pub const SDFsType_FST_FAT12: SDFsType = 1;
pub const SDFsType_FST_FAT16: SDFsType = 2;
pub const SDFsType_FST_FAT32: SDFsType = 3;
pub const SDFsType_FST_EXFAT: SDFsType = 4;
pub type SDFsType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDInfo {
    pub fs_type: SDFsType,
    pub kb_total: u32,
    pub kb_free: u32,
    pub cluster_size: u16,
    pub sector_size: u16,
    pub label: [core::ffi::c_char; 34usize],
    pub manufacturer_id: u8,
    pub oem_id: [core::ffi::c_char; 3usize],
    pub product_name: [core::ffi::c_char; 6usize],
    pub product_revision_major: u8,
    pub product_revision_minor: u8,
    pub product_serial_number: u32,
    pub manufacturing_month: u8,
    pub manufacturing_year: u16,
}
#[test]
fn bindgen_test_layout_SDInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDInfo>(),
        72usize,
        concat!("Size of: ", stringify!(SDInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SDInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(fs_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_total) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kb_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(kb_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(cluster_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_size) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(sector_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer_id) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oem_id) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(oem_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_name) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_major) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_revision_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_revision_minor) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_revision_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_serial_number) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(product_serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_month) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturing_month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturing_year) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(SDInfo),
            "::",
            stringify!(manufacturing_year)
        )
    );
}
extern "C" {
    pub fn sd_api_get_fs_type_text(fs_type: SDFsType) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Storage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocates and initializes a file descriptor\n\nReturns:\n\n* File*\n\n"]
    pub fn storage_file_alloc(storage: *mut Storage) -> *mut File;
}
extern "C" {
    #[doc = "Frees the file descriptor. Closes the file if it was open.\n\n"]
    pub fn storage_file_free(file: *mut File);
}
extern "C" {
    #[doc = "Get storage pubsub. Storage will send StorageEvent messages.\n\nReturns:\n\n* FuriPubSub*\n\n# Arguments\n\n* `storage` - \n\n"]
    pub fn storage_get_pubsub(storage: *mut Storage) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = "Opens an existing file or create a new one.\n\nReturns:\n\n* success flag. You need to close the file even if the open operation failed.\n\n# Arguments\n\n* `file` - pointer to file object.\n* `path` - path to file\n* `access_mode` - access mode from FS_AccessMode\n* `open_mode` - open mode from FS_OpenMode\n\n"]
    pub fn storage_file_open(
        file: *mut File,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = "Close the file.\n\nReturns:\n\n* success flag\n\n# Arguments\n\n* `file` - pointer to a file object, the file object will be freed.\n\n"]
    pub fn storage_file_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Tells if the file is open\n\nReturns:\n\n* bool true if file is open\n\n# Arguments\n\n* `file` - pointer to a file object\n\n"]
    pub fn storage_file_is_open(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Tells if the file is a directory\n\nReturns:\n\n* bool true if file is a directory\n\n# Arguments\n\n* `file` - pointer to a file object\n\n"]
    pub fn storage_file_is_dir(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Reads bytes from a file into a buffer\n\nReturns:\n\n* uint16_t how many bytes were actually read\n\n# Arguments\n\n* `file` - pointer to file object.\n* `buff` - pointer to a buffer, for reading\n* `bytes_to_read` - how many bytes to read. Must be less than or equal to the size of the buffer.\n\n"]
    pub fn storage_file_read(
        file: *mut File,
        buff: *mut core::ffi::c_void,
        bytes_to_read: u16,
    ) -> u16;
}
extern "C" {
    #[doc = "Writes bytes from a buffer to a file\n\nReturns:\n\n* uint16_t how many bytes were actually written\n\n# Arguments\n\n* `file` - pointer to file object.\n* `buff` - pointer to buffer, for writing\n* `bytes_to_write` - how many bytes to write. Must be less than or equal to the size of the buffer.\n\n"]
    pub fn storage_file_write(
        file: *mut File,
        buff: *const core::ffi::c_void,
        bytes_to_write: u16,
    ) -> u16;
}
extern "C" {
    #[doc = "Moves the r/w pointer\n\nReturns:\n\n* success flag\n\n# Arguments\n\n* `file` - pointer to file object.\n* `offset` - offset to move the r/w pointer\n* `from_start` - set an offset from the start or from the current position\n\n"]
    pub fn storage_file_seek(file: *mut File, offset: u32, from_start: bool) -> bool;
}
extern "C" {
    #[doc = "Gets the position of the r/w pointer\n\nReturns:\n\n* uint64_t position of the r/w pointer\n\n# Arguments\n\n* `file` - pointer to file object.\n\n"]
    pub fn storage_file_tell(file: *mut File) -> u64;
}
extern "C" {
    #[doc = "Expand the file (allocate space for it)\n\nReturns:\n\n* success flag\n\n# Arguments\n\n* `file` - pointer to file object.\n* `size` - how many bytes to allocate\n\n"]
    pub fn storage_file_expand(file: *mut File, size: u64) -> bool;
}
extern "C" {
    #[doc = "Truncates the file size to the current position of the r/w pointer\n\nReturns:\n\n* bool success flag\n\n# Arguments\n\n* `file` - pointer to file object.\n\n"]
    pub fn storage_file_truncate(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Gets the size of the file\n\nReturns:\n\n* uint64_t size of the file\n\n# Arguments\n\n* `file` - pointer to file object.\n\n"]
    pub fn storage_file_size(file: *mut File) -> u64;
}
extern "C" {
    #[doc = "Writes file cache to storage\n\nReturns:\n\n* bool success flag\n\n# Arguments\n\n* `file` - pointer to file object.\n\n"]
    pub fn storage_file_sync(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Checks that the r/w pointer is at the end of the file\n\nReturns:\n\n* bool success flag\n\n# Arguments\n\n* `file` - pointer to file object.\n\n"]
    pub fn storage_file_eof(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Check that file exists\n\nReturns:\n\n* true if file exists\n\n# Arguments\n\n* `storage` - \n* `path` - \n\n"]
    pub fn storage_file_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Copy data from one opened file to another opened file Size bytes will be copied from current position of source file to current position of destination file\n\nReturns:\n\n* bool success flag\n\n# Arguments\n\n* `source` - source file\n* `destination` - destination file\n* `size` - size of data to copy\n\n"]
    pub fn storage_file_copy_to_file(source: *mut File, destination: *mut File, size: u32) -> bool;
}
extern "C" {
    #[doc = "Opens a directory to get objects from it\n\nReturns:\n\n* bool success flag. You need to close the directory even if the open operation failed.\n\n# Arguments\n\n* `app` - pointer to the api\n* `file` - pointer to file object.\n* `path` - path to directory\n\n"]
    pub fn storage_dir_open(file: *mut File, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Close the directory. Also free file handle structure and point it to the NULL.\n\nReturns:\n\n* bool success flag\n\n# Arguments\n\n* `file` - pointer to a file object.\n\n"]
    pub fn storage_dir_close(file: *mut File) -> bool;
}
extern "C" {
    #[doc = "Reads the next object in the directory\n\nReturns:\n\n* success flag (if the next object does not exist, it also returns false and sets the file error id to FSE_NOT_EXIST)\n\n# Arguments\n\n* `file` - pointer to file object.\n* `fileinfo` - pointer to the read FileInfo, may be NULL\n* `name` - pointer to name buffer, may be NULL\n* `name_length` - name buffer length\n\n"]
    pub fn storage_dir_read(
        file: *mut File,
        fileinfo: *mut FileInfo,
        name: *mut core::ffi::c_char,
        name_length: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Check that dir exists\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `storage` - \n* `path` - \n\n"]
    pub fn storage_dir_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Retrieves unix timestamp of last access\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `storage` - The storage instance\n* `path` - path to file/directory\n* `timestamp` - the timestamp pointer\n\n"]
    pub fn storage_common_timestamp(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        timestamp: *mut u32,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Retrieves information about a file/directory\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `path` - path to file/directory\n* `fileinfo` - pointer to the read FileInfo, may be NULL\n\n"]
    pub fn storage_common_stat(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Removes a file/directory from the repository, the directory must be empty and the file/directory must not be open\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `path` - \n\n"]
    pub fn storage_common_remove(storage: *mut Storage, path: *const core::ffi::c_char)
        -> FS_Error;
}
extern "C" {
    #[doc = "Renames file/directory, file/directory must not be open\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `old_path` - old path\n* `new_path` - new path\n\n"]
    pub fn storage_common_rename(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Moves file/directory, file/directory must not be open, will overwrite existing destination\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `old_path` - old path\n* `new_path` - new path\n\n"]
    pub fn storage_common_move(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Copy file, file must not be open\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `old_path` - old path\n* `new_path` - new path\n\n"]
    pub fn storage_common_copy(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Copy one folder contents into another with rename of all conflicting files\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `old_path` - old path\n* `new_path` - new path\n\n"]
    pub fn storage_common_merge(
        storage: *mut Storage,
        old_path: *const core::ffi::c_char,
        new_path: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Creates a directory\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `path` - directory path\n\n"]
    pub fn storage_common_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = "Gets general information about the storage\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `app` - pointer to the api\n* `fs_path` - the path to the storage of interest\n* `total_space` - pointer to total space record, will be filled\n* `free_space` - pointer to free space record, will be filled\n\n"]
    pub fn storage_common_fs_info(
        storage: *mut Storage,
        fs_path: *const core::ffi::c_char,
        total_space: *mut u64,
        free_space: *mut u64,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Parse aliases in path and replace them with real path Also will create special folders if they are not exist\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `storage` - \n* `path` - \n\n"]
    pub fn storage_common_resolve_path_and_ensure_app_directory(
        storage: *mut Storage,
        path: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Move content of one folder to another, with rename of all conflicting files. Source folder will be deleted if the migration is successful.\n\nReturns:\n\n* FS_Error\n\n# Arguments\n\n* `storage` - \n* `source` - \n* `dest` - \n\n"]
    pub fn storage_common_migrate(
        storage: *mut Storage,
        source: *const core::ffi::c_char,
        dest: *const core::ffi::c_char,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Check that file or dir exists\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `storage` - \n* `path` - \n\n"]
    pub fn storage_common_exists(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Retrieves the error text from the error id\n\nReturns:\n\n* const char* error text\n\n# Arguments\n\n* `error_id` - error id\n\n"]
    pub fn storage_error_get_desc(error_id: FS_Error) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Retrieves the error id from the file object\n\nReturns:\n\n* FS_Error error id\n\n# Arguments\n\n* `file` - pointer to file object. Pointer must not point to NULL. YOU CANNOT RETRIEVE THE ERROR ID IF THE FILE HAS BEEN CLOSED\n\n"]
    pub fn storage_file_get_error(file: *mut File) -> FS_Error;
}
extern "C" {
    #[doc = "Retrieves the error text from the file object\n\nReturns:\n\n* const char* error text\n\n# Arguments\n\n* `file` - pointer to file object. Pointer must not point to NULL. YOU CANNOT RETRIEVE THE ERROR TEXT IF THE FILE HAS BEEN CLOSED\n\n"]
    pub fn storage_file_get_error_desc(file: *mut File) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Formats SD Card\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n\n"]
    pub fn storage_sd_format(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = "Will unmount the SD card. Will return FSE_NOT_READY if the SD card is not mounted. Will return FSE_DENIED if there are open files on the SD card.\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n\n"]
    pub fn storage_sd_unmount(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = "Will mount the SD card\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n\n"]
    pub fn storage_sd_mount(api: *mut Storage) -> FS_Error;
}
extern "C" {
    #[doc = "Retrieves SD card information\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n* `info` - pointer to the info\n\n"]
    pub fn storage_sd_info(api: *mut Storage, info: *mut SDInfo) -> FS_Error;
}
extern "C" {
    #[doc = "Retrieves SD card status\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n\n"]
    pub fn storage_sd_status(api: *mut Storage) -> FS_Error;
}
#[doc = "Internal LFS Functions\n\n"]
pub type Storage_name_converter =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut FuriString)>;
extern "C" {
    #[doc = "Backs up internal storage to a tar archive\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n* `dstname` - destination archive path\n\n"]
    pub fn storage_int_backup(api: *mut Storage, dstname: *const core::ffi::c_char) -> FS_Error;
}
extern "C" {
    #[doc = "Restores internal storage from a tar archive\n\nReturns:\n\n* FS_Error operation result\n\n# Arguments\n\n* `api` - pointer to the api\n* `dstname` - archive path\n* `converter` - pointer to filename conversion function, may be NULL\n\n"]
    pub fn storage_int_restore(
        api: *mut Storage,
        dstname: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> FS_Error;
}
extern "C" {
    #[doc = "Removes a file/directory, the directory must be empty and the file/directory must not be open\n\nReturns:\n\n* true on success or if file/dir is not exist\n\n# Arguments\n\n* `storage` - pointer to the api\n* `path` - \n\n"]
    pub fn storage_simply_remove(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Recursively removes a file/directory, the directory can be not empty\n\nReturns:\n\n* true on success or if file/dir is not exist\n\n# Arguments\n\n* `storage` - pointer to the api\n* `path` - \n\n"]
    pub fn storage_simply_remove_recursive(
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Creates a directory\n\nReturns:\n\n* true on success or if directory is already exist\n\n# Arguments\n\n* `storage` - \n* `path` - \n\n"]
    pub fn storage_simply_mkdir(storage: *mut Storage, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Get next free filename.\n\n# Arguments\n\n* `storage` - \n* `dirname` - \n* `filename` - \n* `fileextension` - \n* `nextfilename` - return name\n* `max_len` - max len name\n\n"]
    pub fn storage_get_next_filename(
        storage: *mut Storage,
        dirname: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        fileextension: *const core::ffi::c_char,
        nextfilename: *mut FuriString,
        max_len: u8,
    );
}
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusSuccess:
    FlipperApplicationPreloadStatus = 0;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusUnspecifiedError:
    FlipperApplicationPreloadStatus = 1;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidFile:
    FlipperApplicationPreloadStatus = 2;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusInvalidManifest:
    FlipperApplicationPreloadStatus = 3;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusApiTooOld:
    FlipperApplicationPreloadStatus = 4;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusApiTooNew:
    FlipperApplicationPreloadStatus = 5;
pub const FlipperApplicationPreloadStatus_FlipperApplicationPreloadStatusTargetMismatch:
    FlipperApplicationPreloadStatus = 6;
pub type FlipperApplicationPreloadStatus = core::ffi::c_uchar;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusSuccess:
    FlipperApplicationLoadStatus = 0;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusUnspecifiedError:
    FlipperApplicationLoadStatus = 1;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusNoFreeMemory:
    FlipperApplicationLoadStatus = 2;
pub const FlipperApplicationLoadStatus_FlipperApplicationLoadStatusMissingImports:
    FlipperApplicationLoadStatus = 3;
pub type FlipperApplicationLoadStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = "Get text description of preload status\n\nReturns:\n\n* String pointer to description\n\n# Arguments\n\n* `status` - Status code\n\n"]
    pub fn flipper_application_preload_status_to_string(
        status: FlipperApplicationPreloadStatus,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get text description of load status\n\nReturns:\n\n* String pointer to description\n\n# Arguments\n\n* `status` - Status code\n\n"]
    pub fn flipper_application_load_status_to_string(
        status: FlipperApplicationLoadStatus,
    ) -> *const core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperApplication {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Initialize FlipperApplication object\n\nReturns:\n\n* Application instance\n\n# Arguments\n\n* `storage` - Storage instance\n* `api_interface` - ELF API interface to use for pre-loading and symbol resolving\n\n"]
    pub fn flipper_application_alloc(
        storage: *mut Storage,
        api_interface: *const ElfApiInterface,
    ) -> *mut FlipperApplication;
}
extern "C" {
    #[doc = "Destroy FlipperApplication object\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_free(app: *mut FlipperApplication);
}
extern "C" {
    #[doc = "Validate elf file and load application metadata\n\nReturns:\n\n* Preload result code\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_preload(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = "Validate elf file and load application manifest\n\nReturns:\n\n* Preload result code\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_preload_manifest(
        app: *mut FlipperApplication,
        path: *const core::ffi::c_char,
    ) -> FlipperApplicationPreloadStatus;
}
extern "C" {
    #[doc = "Get pointer to application manifest for preloaded application\n\nReturns:\n\n* Pointer to application manifest\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_get_manifest(
        app: *mut FlipperApplication,
    ) -> *const FlipperApplicationManifest;
}
extern "C" {
    #[doc = "Load sections and process relocations for already pre-loaded application\n\nReturns:\n\n* Load result code\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_map_to_memory(
        app: *mut FlipperApplication,
    ) -> FlipperApplicationLoadStatus;
}
extern "C" {
    #[doc = "Allocate application thread at entry point address, using app name and stack size from metadata. Returned thread isn't started yet. Can be only called once for application instance.\n\nReturns:\n\n* Created thread\n\n# Arguments\n\n* `app` - Applicaiton pointer\n* `args` - Args to pass to app's entry point\n\n"]
    pub fn flipper_application_alloc_thread(
        app: *mut FlipperApplication,
        args: *const core::ffi::c_char,
    ) -> *mut FuriThread;
}
extern "C" {
    #[doc = "Check if application is a plugin (not a runnable standalone app)\n\nReturns:\n\n* true if application is a plugin, false otherwise\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_is_plugin(app: *mut FlipperApplication) -> bool;
}
#[doc = "An object that describes a plugin - must be returned by plugin's entry point\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperAppPluginDescriptor {
    pub appid: *const core::ffi::c_char,
    pub ep_api_version: u32,
    pub entry_point: *const core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_FlipperAppPluginDescriptor() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperAppPluginDescriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperAppPluginDescriptor>(),
        12usize,
        concat!("Size of: ", stringify!(FlipperAppPluginDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperAppPluginDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(FlipperAppPluginDescriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperAppPluginDescriptor),
            "::",
            stringify!(appid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ep_api_version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperAppPluginDescriptor),
            "::",
            stringify!(ep_api_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry_point) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperAppPluginDescriptor),
            "::",
            stringify!(entry_point)
        )
    );
}
extern "C" {
    #[doc = "Get plugin descriptor for preloaded plugin\n\nReturns:\n\n* Pointer to plugin descriptor\n\n# Arguments\n\n* `app` - Application pointer\n\n"]
    pub fn flipper_application_plugin_get_descriptor(
        app: *mut FlipperApplication,
    ) -> *const FlipperAppPluginDescriptor;
}
extern "C" {
    #[doc = "Load name and icon from FAP file.\n\nReturns:\n\n* true if icon and name were loaded successfully.\n\n# Arguments\n\n* `path` - Path to FAP file.\n* `storage` - Storage instance.\n* `icon_ptr` - Icon pointer.\n* `item_name` - Application name.\n\n"]
    pub fn flipper_application_load_name_and_icon(
        path: *mut FuriString,
        storage: *mut Storage,
        icon_ptr: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool;
}
pub type SubGhzBegin =
    ::core::option::Option<unsafe extern "C" fn(conf: *mut SubGhzDeviceConf) -> bool>;
pub type SubGhzEnd = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzIsConnect = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzReset = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzSleep = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzIdle = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzLoadPreset =
    ::core::option::Option<unsafe extern "C" fn(preset: FuriHalSubGhzPreset, preset_data: *mut u8)>;
pub type SubGhzSetFrequency = ::core::option::Option<unsafe extern "C" fn(frequency: u32) -> u32>;
pub type SubGhzIsFrequencyValid =
    ::core::option::Option<unsafe extern "C" fn(frequency: u32) -> bool>;
pub type SubGhzSetAsyncMirrorPin =
    ::core::option::Option<unsafe extern "C" fn(gpio: *const GpioPin)>;
pub type SubGhzGetDataGpio = ::core::option::Option<unsafe extern "C" fn() -> *const GpioPin>;
pub type SubGhzSetTx = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzFlushTx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzStartAsyncTx = ::core::option::Option<
    unsafe extern "C" fn(callback: *mut core::ffi::c_void, context: *mut core::ffi::c_void) -> bool,
>;
pub type SubGhzIsAsyncCompleteTx = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzStopAsyncTx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzSetRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzFlushRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzStartAsyncRx = ::core::option::Option<
    unsafe extern "C" fn(callback: *mut core::ffi::c_void, context: *mut core::ffi::c_void),
>;
pub type SubGhzStopAsyncRx = ::core::option::Option<unsafe extern "C" fn()>;
pub type SubGhzGetRSSI = ::core::option::Option<unsafe extern "C" fn() -> f32>;
pub type SubGhzGetLQI = ::core::option::Option<unsafe extern "C" fn() -> u8>;
pub type SubGhzRxPipeNotEmpty = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzRxIsDataCrcValid = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type SubGhzReadPacket =
    ::core::option::Option<unsafe extern "C" fn(data: *mut u8, size: *mut u8)>;
pub type SubGhzWritePacket =
    ::core::option::Option<unsafe extern "C" fn(data: *const u8, size: u8)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceInterconnect {
    pub begin: SubGhzBegin,
    pub end: SubGhzEnd,
    pub is_connect: SubGhzIsConnect,
    pub reset: SubGhzReset,
    pub sleep: SubGhzSleep,
    pub idle: SubGhzIdle,
    pub load_preset: SubGhzLoadPreset,
    pub set_frequency: SubGhzSetFrequency,
    pub is_frequency_valid: SubGhzIsFrequencyValid,
    pub set_async_mirror_pin: SubGhzSetAsyncMirrorPin,
    pub get_data_gpio: SubGhzGetDataGpio,
    pub set_tx: SubGhzSetTx,
    pub flush_tx: SubGhzFlushTx,
    pub start_async_tx: SubGhzStartAsyncTx,
    pub is_async_complete_tx: SubGhzIsAsyncCompleteTx,
    pub stop_async_tx: SubGhzStopAsyncTx,
    pub set_rx: SubGhzSetRx,
    pub flush_rx: SubGhzFlushRx,
    pub start_async_rx: SubGhzStartAsyncRx,
    pub stop_async_rx: SubGhzStopAsyncRx,
    pub get_rssi: SubGhzGetRSSI,
    pub get_lqi: SubGhzGetLQI,
    pub rx_pipe_not_empty: SubGhzRxPipeNotEmpty,
    pub is_rx_data_crc_valid: SubGhzRxIsDataCrcValid,
    pub read_packet: SubGhzReadPacket,
    pub write_packet: SubGhzWritePacket,
}
#[test]
fn bindgen_test_layout_SubGhzDeviceInterconnect() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzDeviceInterconnect> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzDeviceInterconnect>(),
        104usize,
        concat!("Size of: ", stringify!(SubGhzDeviceInterconnect))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzDeviceInterconnect>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzDeviceInterconnect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_connect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(is_connect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sleep) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(sleep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).idle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(idle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_preset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(load_preset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_frequency) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(set_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_frequency_valid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(is_frequency_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_async_mirror_pin) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(set_async_mirror_pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data_gpio) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(get_data_gpio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_tx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(set_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush_tx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(flush_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_async_tx) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(start_async_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_async_complete_tx) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(is_async_complete_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_async_tx) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(stop_async_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_rx) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(set_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush_rx) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(flush_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_async_rx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(start_async_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_async_rx) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(stop_async_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_rssi) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(get_rssi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_lqi) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(get_lqi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_pipe_not_empty) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(rx_pipe_not_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_rx_data_crc_valid) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(is_rx_data_crc_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_packet) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_packet) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceInterconnect),
            "::",
            stringify!(write_packet)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDevice {
    pub name: *const core::ffi::c_char,
    pub interconnect: *const SubGhzDeviceInterconnect,
}
#[test]
fn bindgen_test_layout_SubGhzDevice() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzDevice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzDevice>(),
        8usize,
        concat!("Size of: ", stringify!(SubGhzDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzDevice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDevice),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interconnect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDevice),
            "::",
            stringify!(interconnect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzDeviceConf {
    pub ver: u8,
    pub extended_range: bool,
    pub power_amp: bool,
}
#[test]
fn bindgen_test_layout_SubGhzDeviceConf() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzDeviceConf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzDeviceConf>(),
        3usize,
        concat!("Size of: ", stringify!(SubGhzDeviceConf))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzDeviceConf>(),
        1usize,
        concat!("Alignment of ", stringify!(SubGhzDeviceConf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceConf),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_range) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceConf),
            "::",
            stringify!(extended_range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).power_amp) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzDeviceConf),
            "::",
            stringify!(power_amp)
        )
    );
}
pub const SceneManagerEventType_SceneManagerEventTypeCustom: SceneManagerEventType = 0;
pub const SceneManagerEventType_SceneManagerEventTypeBack: SceneManagerEventType = 1;
pub const SceneManagerEventType_SceneManagerEventTypeTick: SceneManagerEventType = 2;
#[doc = "Scene Manager events type\n\n"]
pub type SceneManagerEventType = core::ffi::c_uchar;
#[doc = "Scene Manager event\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerEvent {
    pub type_: SceneManagerEventType,
    pub event: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SceneManagerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerEvent),
            "::",
            stringify!(event)
        )
    );
}
#[doc = "Prototype for Scene on_enter handler\n\n"]
pub type AppSceneOnEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Prototype for Scene on_event handler\n\n"]
pub type AppSceneOnEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: SceneManagerEvent) -> bool,
>;
#[doc = "Prototype for Scene on_exit handler\n\n"]
pub type AppSceneOnExitCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Scene Manager configuration structure Contains array of Scene handlers\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManagerHandlers {
    pub on_enter_handlers: *const AppSceneOnEnterCallback,
    pub on_event_handlers: *const AppSceneOnEventCallback,
    pub on_exit_handlers: *const AppSceneOnExitCallback,
    pub scene_num: u32,
}
#[test]
fn bindgen_test_layout_SceneManagerHandlers() {
    const UNINIT: ::core::mem::MaybeUninit<SceneManagerHandlers> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SceneManagerHandlers>(),
        16usize,
        concat!("Size of: ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        ::core::mem::align_of::<SceneManagerHandlers>(),
        4usize,
        concat!("Alignment of ", stringify!(SceneManagerHandlers))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_enter_handlers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_enter_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_event_handlers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_event_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_exit_handlers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(on_exit_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scene_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SceneManagerHandlers),
            "::",
            stringify!(scene_num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SceneManager {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Set Scene state\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_id` - Scene ID\n* `state` - Scene new state\n\n"]
    pub fn scene_manager_set_scene_state(
        scene_manager: *mut SceneManager,
        scene_id: u32,
        state: u32,
    );
}
extern "C" {
    #[doc = "Get Scene state\n\nReturns:\n\n* Scene state\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_id` - Scene ID\n\n"]
    pub fn scene_manager_get_scene_state(scene_manager: *const SceneManager, scene_id: u32) -> u32;
}
extern "C" {
    #[doc = "Scene Manager allocation and configuration\nScene Manager allocates all scenes internally\n\nReturns:\n\n* SceneManager instance\n\n# Arguments\n\n* `app_scene_handlers` - SceneManagerHandlers instance\n* `context` - context to be set on Scene handlers calls\n\n"]
    pub fn scene_manager_alloc(
        app_scene_handlers: *const SceneManagerHandlers,
        context: *mut core::ffi::c_void,
    ) -> *mut SceneManager;
}
extern "C" {
    #[doc = "Free Scene Manager with allocated Scenes\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n\n"]
    pub fn scene_manager_free(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = "Custom event handler\nCalls Scene event handler with Custom event parameter\n\nReturns:\n\n* true if event was consumed, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `custom_event` - Custom event code\n\n"]
    pub fn scene_manager_handle_custom_event(
        scene_manager: *mut SceneManager,
        custom_event: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Back event handler\nCalls Scene event handler with Back event parameter\n\nReturns:\n\n* true if event was consumed, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n\n"]
    pub fn scene_manager_handle_back_event(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = "Tick event handler\nCalls Scene event handler with Tick event parameter\n\nReturns:\n\n* true if event was consumed, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n\n"]
    pub fn scene_manager_handle_tick_event(scene_manager: *mut SceneManager);
}
extern "C" {
    #[doc = "Add and run next Scene\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `next_scene_id` - next Scene ID\n\n"]
    pub fn scene_manager_next_scene(scene_manager: *mut SceneManager, next_scene_id: u32);
}
extern "C" {
    #[doc = "Run previous Scene\n\nReturns:\n\n* true if previous scene was found, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n\n"]
    pub fn scene_manager_previous_scene(scene_manager: *mut SceneManager) -> bool;
}
extern "C" {
    #[doc = "Search previous Scene\n\nReturns:\n\n* true if previous scene was found, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_id` - Scene ID\n\n"]
    pub fn scene_manager_has_previous_scene(
        scene_manager: *const SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Search and switch to previous Scene\n\nReturns:\n\n* true if previous scene was found, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_id` - Scene ID\n\n"]
    pub fn scene_manager_search_and_switch_to_previous_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Search and switch to previous Scene, multiple choice\n\nReturns:\n\n* true if one of previous scenes was found, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_ids` - Array of scene IDs\n* `scene_ids_size` - Array of scene IDs size\n\n"]
    pub fn scene_manager_search_and_switch_to_previous_scene_one_of(
        scene_manager: *mut SceneManager,
        scene_ids: *const u32,
        scene_ids_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Clear Scene stack and switch to another Scene\n\nReturns:\n\n* true if previous scene was found, false otherwise\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n* `scene_id` - Scene ID\n\n"]
    pub fn scene_manager_search_and_switch_to_another_scene(
        scene_manager: *mut SceneManager,
        scene_id: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Exit from current scene\n\n# Arguments\n\n* `scene_manager` - SceneManager instance\n\n"]
    pub fn scene_manager_stop(scene_manager: *mut SceneManager);
}
#[doc = "Press event, emitted after debounce\n\n"]
pub const InputType_InputTypePress: InputType = 0;
#[doc = "Release event, emitted after debounce\n\n"]
pub const InputType_InputTypeRelease: InputType = 1;
#[doc = "Short event, emitted after InputTypeRelease done within INPUT_LONG_PRESS interval\n\n"]
pub const InputType_InputTypeShort: InputType = 2;
#[doc = "Long event, emitted after INPUT_LONG_PRESS_COUNTS interval, asynchronous to InputTypeRelease\n\n"]
pub const InputType_InputTypeLong: InputType = 3;
#[doc = "Repeat event, emitted with INPUT_LONG_PRESS_COUNTS period after InputTypeLong event\n\n"]
pub const InputType_InputTypeRepeat: InputType = 4;
#[doc = "Special value for exceptional\n\n"]
pub const InputType_InputTypeMAX: InputType = 5;
#[doc = "Input Types Some of them are physical events and some logical\n\n"]
pub type InputType = core::ffi::c_uchar;
#[doc = "Input Event, dispatches with FuriPubSub\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct InputEvent {
    pub __bindgen_anon_1: InputEvent__bindgen_ty_1,
    pub key: InputKey,
    pub type_: InputType,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union InputEvent__bindgen_ty_1 {
    pub sequence: u32,
    pub __bindgen_anon_1: InputEvent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct InputEvent__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_InputEvent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<InputEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(InputEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<InputEvent__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(InputEvent__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl InputEvent__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sequence_source(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_sequence_source(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sequence_counter(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_sequence_counter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sequence_source: u8,
        sequence_counter: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let sequence_source: u8 = unsafe { ::core::mem::transmute(sequence_source) };
            sequence_source as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let sequence_counter: u32 = unsafe { ::core::mem::transmute(sequence_counter) };
            sequence_counter as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_InputEvent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<InputEvent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputEvent__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(InputEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<InputEvent__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(InputEvent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent__bindgen_ty_1),
            "::",
            stringify!(sequence)
        )
    );
}
#[test]
fn bindgen_test_layout_InputEvent() {
    const UNINIT: ::core::mem::MaybeUninit<InputEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InputEvent>(),
        8usize,
        concat!("Size of: ", stringify!(InputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<InputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(InputEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(InputEvent),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = "Get human readable input key name\n\nReturns:\n\n* string\n\n# Arguments\n\n* `key` - - InputKey\n\n"]
    pub fn input_get_key_name(key: InputKey) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get human readable input type name\n\nReturns:\n\n* string\n\n# Arguments\n\n* `type` - - InputType\n\n"]
    pub fn input_get_type_name(type_: InputType) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get icon width\n\nReturns:\n\n* width in pixels\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to Icon data\n\n"]
    pub fn icon_get_width(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = "Get icon height\n\nReturns:\n\n* height in pixels\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to Icon data\n\n"]
    pub fn icon_get_height(instance: *const Icon) -> u8;
}
extern "C" {
    #[doc = "Get Icon XBM bitmap data\n\nReturns:\n\n* pointer to XBM bitmap data\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to Icon data\n\n"]
    pub fn icon_get_data(instance: *const Icon) -> *const u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IconAnimation {
    _unused: [u8; 0],
}
#[doc = "Icon Animation Callback. Used for update notification\n\n"]
pub type IconAnimationCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut IconAnimation, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Allocate icon animation instance with const icon data.\nalways returns Icon or stops system if not enough memory\n\nReturns:\n\n* IconAnimation instance\n\n# Arguments\n\n* `icon` - [Direction: In] pointer to Icon data\n\n"]
    pub fn icon_animation_alloc(icon: *const Icon) -> *mut IconAnimation;
}
extern "C" {
    #[doc = "Release icon animation instance\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_free(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = "Set IconAnimation update callback\nNormally you do not need to use this function, use view_tie_icon_animation instead.\n\n# Arguments\n\n* `instance` - IconAnimation instance\n* `callback` - [Direction: In] IconAnimationCallback\n* `context` - callback context\n\n"]
    pub fn icon_animation_set_update_callback(
        instance: *mut IconAnimation,
        callback: IconAnimationCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Get icon animation width\n\nReturns:\n\n* width in pixels\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_get_width(instance: *const IconAnimation) -> u8;
}
extern "C" {
    #[doc = "Get icon animation height\n\nReturns:\n\n* height in pixels\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_get_height(instance: *const IconAnimation) -> u8;
}
extern "C" {
    #[doc = "Start icon animation\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_start(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = "Stop icon animation\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_stop(instance: *mut IconAnimation);
}
extern "C" {
    #[doc = "Returns true if current frame is a last one\n\nReturns:\n\n* true if last frame\n\n# Arguments\n\n* `instance` - IconAnimation instance\n\n"]
    pub fn icon_animation_is_last_frame(instance: *const IconAnimation) -> bool;
}
pub const Color_ColorWhite: Color = 0;
pub const Color_ColorBlack: Color = 1;
pub const Color_ColorXOR: Color = 2;
#[doc = "Color enumeration\n\n"]
pub type Color = core::ffi::c_uchar;
pub const Font_FontPrimary: Font = 0;
pub const Font_FontSecondary: Font = 1;
pub const Font_FontKeyboard: Font = 2;
pub const Font_FontBigNumbers: Font = 3;
pub const Font_FontBatteryPercent: Font = 4;
pub const Font_FontScummRomanOutline: Font = 5;
pub const Font_FontScummRoman: Font = 6;
pub const Font_FontEurocorp: Font = 7;
pub const Font_FontTotalNumber: Font = 8;
#[doc = "Fonts enumeration\n\n"]
pub type Font = core::ffi::c_uchar;
pub const Align_AlignLeft: Align = 0;
pub const Align_AlignRight: Align = 1;
pub const Align_AlignTop: Align = 2;
pub const Align_AlignBottom: Align = 3;
pub const Align_AlignCenter: Align = 4;
#[doc = "Alignment enumeration\n\n"]
pub type Align = core::ffi::c_uchar;
pub const CanvasOrientation_CanvasOrientationHorizontal: CanvasOrientation = 0;
pub const CanvasOrientation_CanvasOrientationHorizontalFlip: CanvasOrientation = 1;
pub const CanvasOrientation_CanvasOrientationVertical: CanvasOrientation = 2;
pub const CanvasOrientation_CanvasOrientationVerticalFlip: CanvasOrientation = 3;
#[doc = "Canvas Orientation\n\n"]
pub type CanvasOrientation = core::ffi::c_uchar;
pub const CanvasDirection_CanvasDirectionLeftToRight: CanvasDirection = 0;
pub const CanvasDirection_CanvasDirectionTopToBottom: CanvasDirection = 1;
pub const CanvasDirection_CanvasDirectionRightToLeft: CanvasDirection = 2;
pub const CanvasDirection_CanvasDirectionBottomToTop: CanvasDirection = 3;
#[doc = "Font Direction\n\n"]
pub type CanvasDirection = core::ffi::c_uchar;
#[doc = "Font parameters\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CanvasFontParameters {
    pub leading_default: u8,
    pub leading_min: u8,
    pub height: u8,
    pub descender: u8,
}
#[test]
fn bindgen_test_layout_CanvasFontParameters() {
    const UNINIT: ::core::mem::MaybeUninit<CanvasFontParameters> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CanvasFontParameters>(),
        4usize,
        concat!("Size of: ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        ::core::mem::align_of::<CanvasFontParameters>(),
        1usize,
        concat!("Alignment of ", stringify!(CanvasFontParameters))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_default) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leading_min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(leading_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CanvasFontParameters),
            "::",
            stringify!(descender)
        )
    );
}
pub const IconRotation_IconRotation0: IconRotation = 0;
pub const IconRotation_IconRotation90: IconRotation = 1;
pub const IconRotation_IconRotation180: IconRotation = 2;
pub const IconRotation_IconRotation270: IconRotation = 3;
#[doc = "Icon rotation\n\n"]
pub type IconRotation = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Canvas {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Reset canvas drawing tools configuration\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_reset(canvas: *mut Canvas);
}
extern "C" {
    #[doc = "Commit canvas. Send buffer to display\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_commit(canvas: *mut Canvas);
}
extern "C" {
    #[doc = "Get Canvas width\n\nReturns:\n\n* width in pixels.\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_width(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = "Get Canvas height\n\nReturns:\n\n* height in pixels.\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_height(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = "Get current font height\n\nReturns:\n\n* height in pixels.\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_current_font_height(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = "Get current font width\n\nReturns:\n\n* width in pixels.\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_current_font_width(canvas: *const Canvas) -> u8;
}
extern "C" {
    #[doc = "Get font parameters\n\nReturns:\n\n* pointer to CanvasFontParameters structure\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `font` - Font\n\n"]
    pub fn canvas_get_font_params(canvas: *const Canvas, font: Font)
        -> *const CanvasFontParameters;
}
extern "C" {
    #[doc = "Clear canvas\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_clear(canvas: *mut Canvas);
}
extern "C" {
    #[doc = "Set drawing color\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `color` - Color\n\n"]
    pub fn canvas_set_color(canvas: *mut Canvas, color: Color);
}
extern "C" {
    #[doc = "Set font swap Argument String Rotation Description\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `dir` - Direction font\n\n"]
    pub fn canvas_set_font_direction(canvas: *mut Canvas, dir: CanvasDirection);
}
extern "C" {
    #[doc = "Invert drawing color\n\n# Arguments\n\n* `canvas` - Canvas instance\n\n"]
    pub fn canvas_invert_color(canvas: *mut Canvas);
}
extern "C" {
    #[doc = "Set drawing font\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `font` - Font\n\n"]
    pub fn canvas_set_font(canvas: *mut Canvas, font: Font);
}
extern "C" {
    #[doc = "Set custom drawing font\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `font` - Pointer to u8g2 const uint8_t* font array\n\n"]
    pub fn canvas_set_custom_u8g2_font(canvas: *mut Canvas, font: *const u8);
}
extern "C" {
    #[doc = "Draw string at position of baseline defined by x, y.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - anchor point x coordinate\n* `y` - anchor point y coordinate\n* `str` - C-string\n\n"]
    pub fn canvas_draw_str(canvas: *mut Canvas, x: u8, y: u8, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Draw aligned string defined by x, y.\nAlign calculated from position of baseline, string width and ascent (height of the glyphs above the baseline)\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - anchor point x coordinate\n* `y` - anchor point y coordinate\n* `horizontal` - horizontal alignment\n* `vertical` - vertical alignment\n* `str` - C-string\n\n"]
    pub fn canvas_draw_str_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        str_: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Get string width\n\nReturns:\n\n* width in pixels.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `str` - C-string\n\n"]
    pub fn canvas_string_width(canvas: *mut Canvas, str_: *const core::ffi::c_char) -> u16;
}
extern "C" {
    #[doc = "Get glyph width\n\nReturns:\n\n* width in pixels\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `symbol` - [Direction: In] character\n\n"]
    pub fn canvas_glyph_width(canvas: *mut Canvas, symbol: core::ffi::c_char) -> u8;
}
extern "C" {
    #[doc = "Draw bitmap picture at position defined by x,y.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - width of bitmap\n* `height` - height of bitmap\n* `compressed_bitmap_data` - compressed bitmap data\n\n"]
    pub fn canvas_draw_bitmap(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        compressed_bitmap_data: *const u8,
    );
}
extern "C" {
    #[doc = "Draw icon at position defined by x,y with rotation and flip.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `icon` - Icon instance\n* `flip` - IconFlip\n* `rotation` - IconRotation\n\n"]
    pub fn canvas_draw_icon_ex(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        icon: *const Icon,
        rotation: IconRotation,
    );
}
extern "C" {
    #[doc = "Draw animation at position defined by x,y.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `icon_animation` - IconAnimation instance\n\n"]
    pub fn canvas_draw_icon_animation(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        icon_animation: *mut IconAnimation,
    );
}
extern "C" {
    #[doc = "Draw icon at position defined by x,y.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `icon` - Icon instance\n\n"]
    pub fn canvas_draw_icon(canvas: *mut Canvas, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = "Draw XBM bitmap\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `w` - bitmap width\n* `h` - bitmap height\n* `bitmap` - pointer to XBM bitmap data\n\n"]
    pub fn canvas_draw_xbm(canvas: *mut Canvas, x: u8, y: u8, w: u8, h: u8, bitmap: *const u8);
}
extern "C" {
    #[doc = "Draw dot at x,y\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n\n"]
    pub fn canvas_draw_dot(canvas: *mut Canvas, x: u8, y: u8);
}
extern "C" {
    #[doc = "Draw box of width, height at x,y\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - box width\n* `height` - box height\n\n"]
    pub fn canvas_draw_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw frame of width, height at x,y\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - frame width\n* `height` - frame height\n\n"]
    pub fn canvas_draw_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw line from x1,y1 to x2,y2\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x1` - x1 coordinate\n* `y1` - y1 coordinate\n* `x2` - x2 coordinate\n* `y2` - y2 coordinate\n\n"]
    pub fn canvas_draw_line(canvas: *mut Canvas, x1: u8, y1: u8, x2: u8, y2: u8);
}
extern "C" {
    #[doc = "Draw circle at x,y with radius r\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `r` - radius\n\n"]
    pub fn canvas_draw_circle(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = "Draw disc at x,y with radius r\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `r` - radius\n\n"]
    pub fn canvas_draw_disc(canvas: *mut Canvas, x: u8, y: u8, r: u8);
}
extern "C" {
    #[doc = "Draw triangle with given base and height lengths and their intersection coordinate\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate of base and height intersection\n* `y` - y coordinate of base and height intersection\n* `base` - length of triangle side\n* `height` - length of triangle height\n* `dir` - CanvasDirection triangle orientation\n\n"]
    pub fn canvas_draw_triangle(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        base: u8,
        height: u8,
        dir: CanvasDirection,
    );
}
extern "C" {
    #[doc = "Draw glyph\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `ch` - character\n\n"]
    pub fn canvas_draw_glyph(canvas: *mut Canvas, x: u8, y: u8, ch: u16);
}
extern "C" {
    #[doc = "Set transparency mode\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `alpha` - transparency mode\n\n"]
    pub fn canvas_set_bitmap_mode(canvas: *mut Canvas, alpha: bool);
}
extern "C" {
    #[doc = "Draw rounded-corner frame of width, height at x,y, with round value radius\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - frame width\n* `height` - frame height\n* `radius` - frame corner radius\n\n"]
    pub fn canvas_draw_rframe(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
    #[doc = "Draw rounded-corner box of width, height at x,y, with round value radius\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - box width\n* `height` - box height\n* `radius` - box corner radius\n\n"]
    pub fn canvas_draw_rbox(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8, radius: u8);
}
extern "C" {
    pub fn canvas_draw_icon_bitmap(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        w: i16,
        h: i16,
        icon: *const Icon,
    );
}
pub const ViewOrientation_ViewOrientationHorizontal: ViewOrientation = 0;
pub const ViewOrientation_ViewOrientationHorizontalFlip: ViewOrientation = 1;
pub const ViewOrientation_ViewOrientationVertical: ViewOrientation = 2;
pub const ViewOrientation_ViewOrientationVerticalFlip: ViewOrientation = 3;
pub type ViewOrientation = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct View {
    _unused: [u8; 0],
}
#[doc = "View Draw callback\n\n**Warning!**\n\n* called from GUI thread\n\n# Arguments\n\n* `canvas,` - pointer to canvas\n* `view_model,` - pointer to context\n\n"]
pub type ViewDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, model: *mut core::ffi::c_void),
>;
#[doc = "View Input callback\n\n**Warning!**\n\n* called from GUI thread\n\nReturns:\n\n* true if event handled, false if event ignored\n\n# Arguments\n\n* `event,` - pointer to input event data\n* `context,` - pointer to context\n\n"]
pub type ViewInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = "View Custom callback\n\nReturns:\n\n* true if event handled, false if event ignored\n\n# Arguments\n\n* `event,` - number of custom event\n* `context,` - pointer to context\n\n"]
pub type ViewCustomCallback = ::core::option::Option<
    unsafe extern "C" fn(event: u32, context: *mut core::ffi::c_void) -> bool,
>;
#[doc = "View navigation callback\n\n**Warning!**\n\n* called from GUI thread\n\nReturns:\n\n* next view id\n\n# Arguments\n\n* `context,` - pointer to context\n\n"]
pub type ViewNavigationCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> u32>;
#[doc = "View callback\n\n**Warning!**\n\n* called from GUI thread\n\n# Arguments\n\n* `context,` - pointer to context\n\n"]
pub type ViewCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "View Update Callback Called upon model change, need to be propagated to GUI throw ViewPort update\n\n**Warning!**\n\n* called from GUI thread\n\n# Arguments\n\n* `view,` - pointer to view\n* `context,` - pointer to context\n\n"]
pub type ViewUpdateCallback =
    ::core::option::Option<unsafe extern "C" fn(view: *mut View, context: *mut core::ffi::c_void)>;
#[doc = "Model is not allocated\n\n"]
pub const ViewModelType_ViewModelTypeNone: ViewModelType = 0;
#[doc = "Model consist of atomic types and/or partial update is not critical for rendering. Lock free.\n\n"]
pub const ViewModelType_ViewModelTypeLockFree: ViewModelType = 1;
#[doc = "Model access is guarded with mutex. Locking gui thread.\n\n"]
pub const ViewModelType_ViewModelTypeLocking: ViewModelType = 2;
#[doc = "View model types\n\n"]
pub type ViewModelType = core::ffi::c_uchar;
extern "C" {
    #[doc = "Allocate and init View\n\nReturns:\n\n* View instance\n\n"]
    pub fn view_alloc() -> *mut View;
}
extern "C" {
    #[doc = "Free View\n\n# Arguments\n\n* `view` - instance\n\n"]
    pub fn view_free(view: *mut View);
}
extern "C" {
    #[doc = "Tie IconAnimation with View\n\n# Arguments\n\n* `view` - View instance\n* `icon_animation` - IconAnimation instance\n\n"]
    pub fn view_tie_icon_animation(view: *mut View, icon_animation: *mut IconAnimation);
}
extern "C" {
    #[doc = "Set View Draw callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - draw callback\n\n"]
    pub fn view_set_draw_callback(view: *mut View, callback: ViewDrawCallback);
}
extern "C" {
    #[doc = "Set View Input callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - input callback\n\n"]
    pub fn view_set_input_callback(view: *mut View, callback: ViewInputCallback);
}
extern "C" {
    #[doc = "Set View Custom callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - input callback\n\n"]
    pub fn view_set_custom_callback(view: *mut View, callback: ViewCustomCallback);
}
extern "C" {
    #[doc = "Set Navigation Previous callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - input callback\n\n"]
    pub fn view_set_previous_callback(view: *mut View, callback: ViewNavigationCallback);
}
extern "C" {
    #[doc = "Set Enter callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - callback\n\n"]
    pub fn view_set_enter_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = "Set Exit callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - callback\n\n"]
    pub fn view_set_exit_callback(view: *mut View, callback: ViewCallback);
}
extern "C" {
    #[doc = "Set Update callback\n\n# Arguments\n\n* `view` - View instance\n* `callback` - callback\n\n"]
    pub fn view_set_update_callback(view: *mut View, callback: ViewUpdateCallback);
}
extern "C" {
    #[doc = "Set View Draw callback\n\n# Arguments\n\n* `view` - View instance\n* `context` - context for callbacks\n\n"]
    pub fn view_set_update_callback_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set View Draw callback\n\n# Arguments\n\n* `view` - View instance\n* `context` - context for callbacks\n\n"]
    pub fn view_set_context(view: *mut View, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set View Orientation\n\n# Arguments\n\n* `view` - View instance\n* `orientation` - either vertical or horizontal\n\n"]
    pub fn view_set_orientation(view: *mut View, orientation: ViewOrientation);
}
extern "C" {
    #[doc = "Allocate view model.\n\n# Arguments\n\n* `view` - View instance\n* `type` - View Model Type\n* `size` - size\n\n"]
    pub fn view_allocate_model(view: *mut View, type_: ViewModelType, size: usize);
}
extern "C" {
    #[doc = "Free view model data memory.\n\n# Arguments\n\n* `view` - View instance\n\n"]
    pub fn view_free_model(view: *mut View);
}
extern "C" {
    #[doc = "Get view model data\n\n**Warning!**\n\n* Don't forget to commit model changes\n\nReturns:\n\n* pointer to model data\n\n# Arguments\n\n* `view` - View instance\n\n"]
    pub fn view_get_model(view: *mut View) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Commit view model\n\n# Arguments\n\n* `view` - View instance\n* `update` - true if you want to emit view update, false otherwise\n\n"]
    pub fn view_commit_model(view: *mut View, update: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewPort {
    _unused: [u8; 0],
}
pub const ViewPortOrientation_ViewPortOrientationHorizontal: ViewPortOrientation = 0;
pub const ViewPortOrientation_ViewPortOrientationHorizontalFlip: ViewPortOrientation = 1;
pub const ViewPortOrientation_ViewPortOrientationVertical: ViewPortOrientation = 2;
pub const ViewPortOrientation_ViewPortOrientationVerticalFlip: ViewPortOrientation = 3;
#[doc = "Special value, don't use it\n\n"]
pub const ViewPortOrientation_ViewPortOrientationMAX: ViewPortOrientation = 4;
pub type ViewPortOrientation = core::ffi::c_uchar;
#[doc = "ViewPort Draw callback\n\n**Warning!**\n\n* called from GUI thread\n\n"]
pub type ViewPortDrawCallback = ::core::option::Option<
    unsafe extern "C" fn(canvas: *mut Canvas, context: *mut core::ffi::c_void),
>;
#[doc = "ViewPort Input callback\n\n**Warning!**\n\n* called from GUI thread\n\n"]
pub type ViewPortInputCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *mut InputEvent, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "ViewPort allocator\nalways returns view_port or stops system if not enough memory.\n\nReturns:\n\n* ViewPort instance\n\n"]
    pub fn view_port_alloc() -> *mut ViewPort;
}
extern "C" {
    #[doc = "ViewPort deallocator\nEnsure that view_port was unregistered in GUI system before use.\n\n# Arguments\n\n* `view_port` - ViewPort instance\n\n"]
    pub fn view_port_free(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = "Set view_port width.\nWill be used to limit canvas drawing area and autolayout feature.\n\n# Arguments\n\n* `view_port` - ViewPort instance\n* `width` - wanted width, 0 - auto.\n\n"]
    pub fn view_port_set_width(view_port: *mut ViewPort, width: u8);
}
extern "C" {
    pub fn view_port_get_width(view_port: *const ViewPort) -> u8;
}
extern "C" {
    #[doc = "Set view_port height.\nWill be used to limit canvas drawing area and autolayout feature.\n\n# Arguments\n\n* `view_port` - ViewPort instance\n* `height` - wanted height, 0 - auto.\n\n"]
    pub fn view_port_set_height(view_port: *mut ViewPort, height: u8);
}
extern "C" {
    pub fn view_port_get_height(view_port: *const ViewPort) -> u8;
}
extern "C" {
    #[doc = "Enable or disable view_port rendering.\n\n**Warning!**\n\n* automatically dispatches update event\n\n# Arguments\n\n* `view_port` - ViewPort instance\n* `enabled` - Indicates if enabled\n\n"]
    pub fn view_port_enabled_set(view_port: *mut ViewPort, enabled: bool);
}
extern "C" {
    pub fn view_port_is_enabled(view_port: *const ViewPort) -> bool;
}
extern "C" {
    #[doc = "ViewPort event callbacks\n\n# Arguments\n\n* `view_port` - ViewPort instance\n* `callback` - appropriate callback function\n* `context` - context to pass to callback\n\n"]
    pub fn view_port_draw_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortDrawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn view_port_input_callback_set(
        view_port: *mut ViewPort,
        callback: ViewPortInputCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Emit update signal to GUI system.\nRendering will happen later after GUI system process signal.\n\n# Arguments\n\n* `view_port` - ViewPort instance\n\n"]
    pub fn view_port_update(view_port: *mut ViewPort);
}
extern "C" {
    #[doc = "Set ViewPort orientation.\n\n# Arguments\n\n* `view_port` - ViewPort instance\n* `orientation` - display orientation, horizontal or vertical.\n\n"]
    pub fn view_port_set_orientation(view_port: *mut ViewPort, orientation: ViewPortOrientation);
}
extern "C" {
    pub fn view_port_get_orientation(view_port: *const ViewPort) -> ViewPortOrientation;
}
#[doc = "Desktop layer for internal use. Like fullscreen but with status bar\n\n"]
pub const GuiLayer_GuiLayerDesktop: GuiLayer = 0;
#[doc = "Window layer, status bar is shown\n\n"]
pub const GuiLayer_GuiLayerWindow: GuiLayer = 1;
#[doc = "Status bar left-side layer, auto-layout\n\n"]
pub const GuiLayer_GuiLayerStatusBarLeft: GuiLayer = 2;
#[doc = "Status bar right-side layer, auto-layout\n\n"]
pub const GuiLayer_GuiLayerStatusBarRight: GuiLayer = 3;
#[doc = "Fullscreen layer, no status bar\n\n"]
pub const GuiLayer_GuiLayerFullscreen: GuiLayer = 4;
#[doc = "Don't use or move, special value\n\n"]
pub const GuiLayer_GuiLayerMAX: GuiLayer = 5;
#[doc = "Gui layers\n\n"]
pub type GuiLayer = core::ffi::c_uchar;
#[doc = "Gui Canvas Commit Callback\n\n"]
pub type GuiCanvasCommitCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut u8,
        size: usize,
        orientation: CanvasOrientation,
        context: *mut core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gui {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Add view_port to view_port tree\n\n# Arguments\n\n* `gui` - Gui instance\n* `view_port` - ViewPort instance\n* `layer` - [Direction: In] GuiLayer where to place view_port\n\n# Notes\n\n* thread safe\n\n"]
    pub fn gui_add_view_port(gui: *mut Gui, view_port: *mut ViewPort, layer: GuiLayer);
}
extern "C" {
    #[doc = "Remove view_port from rendering tree\n\n# Arguments\n\n* `gui` - Gui instance\n* `view_port` - ViewPort instance\n\n# Notes\n\n* thread safe\n\n"]
    pub fn gui_remove_view_port(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = "Send ViewPort to the front\nPlaces selected ViewPort to the top of the drawing stack\n\n# Arguments\n\n* `gui` - Gui instance\n* `view_port` - ViewPort instance\n\n"]
    pub fn gui_view_port_send_to_front(gui: *mut Gui, view_port: *mut ViewPort);
}
extern "C" {
    #[doc = "Add gui canvas commit callback\nThis callback will be called upon Canvas commit Callback dispatched from GUI thread and is time critical\n\n# Arguments\n\n* `gui` - Gui instance\n* `callback` - GuiCanvasCommitCallback\n* `context` - GuiCanvasCommitCallback context\n\n"]
    pub fn gui_add_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Remove gui canvas commit callback\n\n# Arguments\n\n* `gui` - Gui instance\n* `callback` - GuiCanvasCommitCallback\n* `context` - GuiCanvasCommitCallback context\n\n"]
    pub fn gui_remove_framebuffer_callback(
        gui: *mut Gui,
        callback: GuiCanvasCommitCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Get gui canvas frame buffer size\n\nReturns:\n\n* size_t size of frame buffer in bytes\n\n# Arguments\n\n* `gui` - Gui instance\n\n"]
    pub fn gui_get_framebuffer_size(gui: *const Gui) -> usize;
}
extern "C" {
    #[doc = "Set hidden statusbar\nHide the statusbar (stacks if called multiple times).\n\n# Arguments\n\n* `gui` - Gui instance\n* `hinned` - bool, true if hidden\n\n"]
    pub fn gui_set_hide_statusbar(gui: *mut Gui, hidden: bool);
}
extern "C" {
    #[doc = "Set lockdown mode\nWhen lockdown mode is enabled, only GuiLayerDesktop is shown. This feature prevents services from showing sensitive information when flipper is locked.\n\n# Arguments\n\n* `gui` - Gui instance\n* `lockdown` - bool, true if enabled\n\n"]
    pub fn gui_set_lockdown(gui: *mut Gui, lockdown: bool);
}
extern "C" {
    #[doc = "Acquire Direct Draw lock and get Canvas instance\nThis method return Canvas instance for use in monopoly mode. Direct draw lock disables input and draw call dispatch functions in GUI service. No other applications or services will be able to draw until gui_direct_draw_release call.\n\nReturns:\n\n* Canvas instance\n\n# Arguments\n\n* `gui` - The graphical user interface\n\n"]
    pub fn gui_direct_draw_acquire(gui: *mut Gui) -> *mut Canvas;
}
extern "C" {
    #[doc = "Release Direct Draw Lock\nRelease Direct Draw Lock, enables Input and Draw call processing. Canvas acquired in gui_direct_draw_acquire will become invalid after this call.\n\n# Arguments\n\n* `gui` - Gui instance\n\n"]
    pub fn gui_direct_draw_release(gui: *mut Gui);
}
#[doc = "Desktop layer: fullscreen with status bar on top of it. For internal usage.\n\n"]
pub const ViewDispatcherType_ViewDispatcherTypeDesktop: ViewDispatcherType = 0;
#[doc = "Window layer: with status bar\n\n"]
pub const ViewDispatcherType_ViewDispatcherTypeWindow: ViewDispatcherType = 1;
#[doc = "Fullscreen layer: without status bar\n\n"]
pub const ViewDispatcherType_ViewDispatcherTypeFullscreen: ViewDispatcherType = 2;
#[doc = "ViewDispatcher view_port placement\n\n"]
pub type ViewDispatcherType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewDispatcher {
    _unused: [u8; 0],
}
#[doc = "Prototype for custom event callback\n\n"]
pub type ViewDispatcherCustomEventCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, event: u32) -> bool,
>;
#[doc = "Prototype for navigation event callback\n\n"]
pub type ViewDispatcherNavigationEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> bool>;
#[doc = "Prototype for tick event callback\n\n"]
pub type ViewDispatcherTickEventCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Allocate ViewDispatcher instance\n\nReturns:\n\n* pointer to ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_alloc() -> *mut ViewDispatcher;
}
extern "C" {
    #[doc = "Free ViewDispatcher instance\n\n# Arguments\n\n* `view_dispatcher` - pointer to ViewDispatcher\n\n"]
    pub fn view_dispatcher_free(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Enable queue support\nIf queue enabled all input and custom events will be dispatched throw internal queue\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_enable_queue(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Send custom event\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `event` - [Direction: In] The event\n\n"]
    pub fn view_dispatcher_send_custom_event(view_dispatcher: *mut ViewDispatcher, event: u32);
}
extern "C" {
    #[doc = "Set custom event handler\nCalled on Custom Event, if it is not consumed by view\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `callback` - ViewDispatcherCustomEventCallback instance\n\n"]
    pub fn view_dispatcher_set_custom_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherCustomEventCallback,
    );
}
extern "C" {
    #[doc = "Set navigation event handler\nCalled on Input Short Back Event, if it is not consumed by view\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `callback` - ViewDispatcherNavigationEventCallback instance\n\n"]
    pub fn view_dispatcher_set_navigation_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherNavigationEventCallback,
    );
}
extern "C" {
    #[doc = "Set tick event handler\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `callback` - ViewDispatcherTickEventCallback\n* `tick_period` - callback call period\n\n"]
    pub fn view_dispatcher_set_tick_event_callback(
        view_dispatcher: *mut ViewDispatcher,
        callback: ViewDispatcherTickEventCallback,
        tick_period: u32,
    );
}
extern "C" {
    #[doc = "Set event callback context\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `context` - pointer to context\n\n"]
    pub fn view_dispatcher_set_event_callback_context(
        view_dispatcher: *mut ViewDispatcher,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Run ViewDispatcher\nUse only after queue enabled\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_run(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Stop ViewDispatcher\nUse only after queue enabled\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_stop(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Add view to ViewDispatcher\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `view_id` - View id to register\n* `view` - View instance\n\n"]
    pub fn view_dispatcher_add_view(
        view_dispatcher: *mut ViewDispatcher,
        view_id: u32,
        view: *mut View,
    );
}
extern "C" {
    #[doc = "Remove view from ViewDispatcher\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `view_id` - View id to remove\n\n"]
    pub fn view_dispatcher_remove_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = "Switch to View\n\n**Warning!**\n\n* switching may be delayed till input events complementarity reached\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `view_id` - View id to register\n\n"]
    pub fn view_dispatcher_switch_to_view(view_dispatcher: *mut ViewDispatcher, view_id: u32);
}
extern "C" {
    #[doc = "Send ViewPort of this ViewDispatcher instance to front\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_send_to_front(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Send ViewPort of this ViewDispatcher instance to back\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n\n"]
    pub fn view_dispatcher_send_to_back(view_dispatcher: *mut ViewDispatcher);
}
extern "C" {
    #[doc = "Attach ViewDispatcher to GUI\n\n# Arguments\n\n* `view_dispatcher` - ViewDispatcher instance\n* `gui` - GUI instance to attach to\n* `type` - [Direction: In] The type\n\n"]
    pub fn view_dispatcher_attach_to_gui(
        view_dispatcher: *mut ViewDispatcher,
        gui: *mut Gui,
        type_: ViewDispatcherType,
    );
}
extern "C" {
    pub fn process_favorite_launch(p: *mut *mut core::ffi::c_char) -> bool;
}
extern "C" {
    pub fn favorite_timeout_callback(_ctx: *mut core::ffi::c_void);
}
extern "C" {
    pub fn favorite_timeout_run(
        view_dispatcher: *mut ViewDispatcher,
        scene_manager: *mut SceneManager,
    );
}
pub const FlipperInternalApplicationFlag_FlipperInternalApplicationFlagDefault:
    FlipperInternalApplicationFlag = 0;
pub const FlipperInternalApplicationFlag_FlipperInternalApplicationFlagInsomniaSafe:
    FlipperInternalApplicationFlag = 1;
pub type FlipperInternalApplicationFlag = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperInternalApplication {
    pub app: FuriThreadCallback,
    pub name: *const core::ffi::c_char,
    pub appid: *const core::ffi::c_char,
    pub stack_size: usize,
    pub icon: *const Icon,
    pub flags: FlipperInternalApplicationFlag,
}
#[test]
fn bindgen_test_layout_FlipperInternalApplication() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperInternalApplication> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperInternalApplication>(),
        24usize,
        concat!("Size of: ", stringify!(FlipperInternalApplication))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperInternalApplication>(),
        4usize,
        concat!("Alignment of ", stringify!(FlipperInternalApplication))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).app) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(app)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(appid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperInternalApplication),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperExternalApplication {
    pub name: *const core::ffi::c_char,
    pub icon: *const Icon,
    pub path: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_FlipperExternalApplication() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperExternalApplication> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperExternalApplication>(),
        12usize,
        concat!("Size of: ", stringify!(FlipperExternalApplication))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperExternalApplication>(),
        4usize,
        concat!("Alignment of ", stringify!(FlipperExternalApplication))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperExternalApplication),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperExternalApplication),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperExternalApplication),
            "::",
            stringify!(path)
        )
    );
}
extern "C" {
    pub static FLIPPER_APPS: [FlipperInternalApplication; 0usize];
}
extern "C" {
    pub static FLIPPER_APPS_COUNT: usize;
}
extern "C" {
    pub static FLIPPER_SETTINGS_APPS: [FlipperInternalApplication; 0usize];
}
extern "C" {
    pub static FLIPPER_SETTINGS_APPS_COUNT: usize;
}
extern "C" {
    pub static FLIPPER_EXTERNAL_APPS: [FlipperExternalApplication; 0usize];
}
extern "C" {
    pub static FLIPPER_EXTERNAL_APPS_COUNT: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bt {
    _unused: [u8; 0],
}
pub const BtStatus_BtStatusUnavailable: BtStatus = 0;
pub const BtStatus_BtStatusOff: BtStatus = 1;
pub const BtStatus_BtStatusAdvertising: BtStatus = 2;
pub const BtStatus_BtStatusConnected: BtStatus = 3;
pub type BtStatus = core::ffi::c_uchar;
pub const BtProfile_BtProfileSerial: BtProfile = 0;
pub const BtProfile_BtProfileHidKeyboard: BtProfile = 1;
pub type BtProfile = core::ffi::c_uchar;
pub type BtStatusChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(status: BtStatus, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Change BLE Profile\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `bt` - Bt instance\n* `profile` - BtProfile\n\n# Notes\n\n* Call of this function leads to 2nd core restart\n\n"]
    pub fn bt_set_profile(bt: *mut Bt, profile: BtProfile) -> bool;
}
extern "C" {
    #[doc = "Disconnect from Central\n\n# Arguments\n\n* `bt` - Bt instance\n\n"]
    pub fn bt_disconnect(bt: *mut Bt);
}
extern "C" {
    #[doc = "Set callback for Bluetooth status change notification\n\n# Arguments\n\n* `bt` - Bt instance\n* `callback` - BtStatusChangedCallback instance\n* `context` - pointer to context\n\n"]
    pub fn bt_set_status_changed_callback(
        bt: *mut Bt,
        callback: BtStatusChangedCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Forget bonded devices\n\n# Arguments\n\n* `bt` - Bt instance\n\n# Notes\n\n* Leads to wipe ble key storage and deleting bt.keys\n\n"]
    pub fn bt_forget_bonded_devices(bt: *mut Bt);
}
extern "C" {
    #[doc = "Set keys storage file path\n\n# Arguments\n\n* `bt` - Bt instance\n* `keys_storage_path` - Path to file with saved keys\n\n"]
    pub fn bt_keys_storage_set_storage_path(
        bt: *mut Bt,
        keys_storage_path: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Set default keys storage file path\n\n# Arguments\n\n* `bt` - Bt instance\n\n"]
    pub fn bt_keys_storage_set_default_path(bt: *mut Bt);
}
extern "C" {
    pub fn bt_set_profile_adv_name(bt: *mut Bt, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn bt_get_profile_adv_name(bt: *mut Bt) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn bt_set_profile_mac_address(bt: *mut Bt, mac: *const u8);
}
extern "C" {
    pub fn bt_get_profile_mac_address(bt: *mut Bt) -> *const u8;
}
extern "C" {
    pub fn bt_remote_rssi(bt: *mut Bt, rssi: *mut u8) -> bool;
}
extern "C" {
    pub fn bt_set_profile_pairing_method(bt: *mut Bt, pairing_method: GapPairing);
}
extern "C" {
    pub fn bt_get_profile_pairing_method(bt: *mut Bt) -> GapPairing;
}
extern "C" {
    #[doc = "Stop saving new peer key to flash (in .bt.keys file)\n\n"]
    pub fn bt_disable_peer_key_update(bt: *mut Bt);
}
extern "C" {
    #[doc = "Enable saving peer key to internal flash (enable by default)\n\n# Notes\n\n* This function should be called if bt_disable_peer_key_update was called before\n\n"]
    pub fn bt_enable_peer_key_update(bt: *mut Bt);
}
extern "C" {
    #[doc = "(Probably bad) way of opening the RPC connection, everywhereTM\n\n"]
    pub fn bt_open_rpc_connection(bt: *mut Bt);
}
extern "C" {
    #[doc = "Closing the RPC connection, everywhereTM\n\n"]
    pub fn bt_close_rpc_connection(bt: *mut Bt);
}
#[doc = "Default, loader lock is used\n\n"]
pub const CliCommandFlag_CliCommandFlagDefault: CliCommandFlag = 0;
pub const CliCommandFlag_CliCommandFlagParallelSafe: CliCommandFlag = 1;
#[doc = "Safe to run with insomnia mode on\n\n"]
pub const CliCommandFlag_CliCommandFlagInsomniaSafe: CliCommandFlag = 2;
pub type CliCommandFlag = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cli {
    _unused: [u8; 0],
}
#[doc = "Cli callback function pointer. Implement this interface and use add_cli_command\n\n# Arguments\n\n* `args` - string with what was passed after command\n* `context` - pointer to whatever you gave us on cli_add_command\n\n"]
pub type CliCallback = ::core::option::Option<
    unsafe extern "C" fn(cli: *mut Cli, args: *mut FuriString, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Add cli command Registers you command callback\n\n# Arguments\n\n* `cli` - pointer to cli instance\n* `name` - command name\n* `flags` - CliCommandFlag\n* `callback` - callback function\n* `context` - pointer to whatever we need to pass to callback\n\n"]
    pub fn cli_add_command(
        cli: *mut Cli,
        name: *const core::ffi::c_char,
        flags: CliCommandFlag,
        callback: CliCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Print unified cmd usage tip\n\n# Arguments\n\n* `cmd` - cmd name\n* `usage` - usage tip\n* `arg` - arg passed by user\n\n"]
    pub fn cli_print_usage(
        cmd: *const core::ffi::c_char,
        usage: *const core::ffi::c_char,
        arg: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Delete cli command\n\n# Arguments\n\n* `cli` - pointer to cli instance\n* `name` - command name\n\n"]
    pub fn cli_delete_command(cli: *mut Cli, name: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Read from terminal\n\nReturns:\n\n* bytes read\n\n# Arguments\n\n* `cli` - Cli instance\n* `buffer` - pointer to buffer\n* `size` - size of buffer in bytes\n\n"]
    pub fn cli_read(cli: *mut Cli, buffer: *mut u8, size: usize) -> usize;
}
extern "C" {
    #[doc = "Non-blocking read from terminal\n\nReturns:\n\n* bytes read\n\n# Arguments\n\n* `cli` - Cli instance\n* `buffer` - pointer to buffer\n* `size` - size of buffer in bytes\n* `timeout` - timeout value in ms\n\n"]
    pub fn cli_read_timeout(cli: *mut Cli, buffer: *mut u8, size: usize, timeout: u32) -> usize;
}
extern "C" {
    #[doc = "Non-blocking check for interrupt command received\n\nReturns:\n\n* true if received\n\n# Arguments\n\n* `cli` - Cli instance\n\n"]
    pub fn cli_cmd_interrupt_received(cli: *mut Cli) -> bool;
}
extern "C" {
    #[doc = "Write to terminal Do it only from inside of cli call.\n\n# Arguments\n\n* `cli` - Cli instance\n* `buffer` - pointer to buffer\n* `size` - size of buffer in bytes\n\n"]
    pub fn cli_write(cli: *mut Cli, buffer: *const u8, size: usize);
}
extern "C" {
    #[doc = "Read character\n\nReturns:\n\n* char\n\n# Arguments\n\n* `cli` - Cli instance\n\n"]
    pub fn cli_getc(cli: *mut Cli) -> core::ffi::c_char;
}
extern "C" {
    #[doc = "New line Send new ine sequence\n\n"]
    pub fn cli_nl();
}
extern "C" {
    pub fn cli_session_open(cli: *mut Cli, session: *mut core::ffi::c_void);
}
extern "C" {
    pub fn cli_session_close(cli: *mut Cli);
}
extern "C" {
    pub fn cli_is_connected(cli: *mut Cli) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CliSession {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut cli_vcp: CliSession;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileBrowser {
    _unused: [u8; 0],
}
pub type FileBrowserCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type FileBrowserLoadItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        path: *mut FuriString,
        context: *mut core::ffi::c_void,
        icon: *mut *mut u8,
        item_name: *mut FuriString,
    ) -> bool,
>;
extern "C" {
    pub fn file_browser_alloc(result_path: *mut FuriString) -> *mut FileBrowser;
}
extern "C" {
    pub fn file_browser_free(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_get_view(browser: *mut FileBrowser) -> *mut View;
}
extern "C" {
    pub fn file_browser_configure(
        browser: *mut FileBrowser,
        extension: *const core::ffi::c_char,
        base_path: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
        file_icon: *const Icon,
        hide_ext: bool,
    );
}
extern "C" {
    pub fn file_browser_start(browser: *mut FileBrowser, path: *mut FuriString);
}
extern "C" {
    pub fn file_browser_stop(browser: *mut FileBrowser);
}
extern "C" {
    pub fn file_browser_set_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_set_item_callback(
        browser: *mut FileBrowser,
        callback: FileBrowserLoadItemCallback,
        context: *mut core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsApp {
    _unused: [u8; 0],
}
#[doc = "File browser dialog extra options. This can be default-initialized using {@link dialog_file_browser_set_basic_options}.\n\n# Arguments\n\n* `extension` - file extension to be offered for selection\n* `base_path` - root folder path for navigation with back key\n* `skip_assets` - true - do not show assets folders\n* `hide_dot_files` - true - hide dot files\n* `icon` - file icon pointer, NULL for default icon\n* `hide_ext` - true - hide extensions for files\n* `item_loader_callback` - callback function for providing custom icon & entry name\n* `hide_ext` - callback context\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogsFileBrowserOptions {
    pub extension: *const core::ffi::c_char,
    pub base_path: *const core::ffi::c_char,
    pub skip_assets: bool,
    pub hide_dot_files: bool,
    pub icon: *const Icon,
    pub hide_ext: bool,
    pub item_loader_callback: FileBrowserLoadItemCallback,
    pub item_loader_context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_DialogsFileBrowserOptions() {
    const UNINIT: ::core::mem::MaybeUninit<DialogsFileBrowserOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DialogsFileBrowserOptions>(),
        28usize,
        concat!("Size of: ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<DialogsFileBrowserOptions>(),
        4usize,
        concat!("Alignment of ", stringify!(DialogsFileBrowserOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(base_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_assets) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(skip_assets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_dot_files) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(hide_dot_files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_ext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(hide_ext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_callback) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_loader_context) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DialogsFileBrowserOptions),
            "::",
            stringify!(item_loader_context)
        )
    );
}
extern "C" {
    #[doc = "Initialize file browser dialog options and set default values. This is guaranteed to initialize all fields so it is safe to pass pointer to uninitialized ```\n options} and assume that the data behind it becomes fully initialized after the call.\n\n# Arguments\n\n* `options` - pointer to options structure\n* `extension` - file extension to filter\n* `icon` - file icon pointer, NULL for default icon\n\n"]
    pub fn dialog_file_browser_set_basic_options(
        options: *mut DialogsFileBrowserOptions,
        extension: *const core::ffi::c_char,
        icon: *const Icon,
    );
}
extern "C" {
    #[doc = "Shows and processes the file browser dialog\n\nReturns:\n\n* bool whether a file was selected\n\n# Arguments\n\n* `context` - api pointer\n* `result_path` - selected file path string pointer\n* `path` - preselected file path string pointer\n* `options` - file browser dialog extra options, may be null\n\n"]
    pub fn dialog_file_browser_show(
        context: *mut DialogsApp,
        result_path: *mut FuriString,
        path: *mut FuriString,
        options: *const DialogsFileBrowserOptions,
    ) -> bool;
}
pub const DialogMessageButton_DialogMessageButtonBack: DialogMessageButton = 0;
pub const DialogMessageButton_DialogMessageButtonLeft: DialogMessageButton = 1;
pub const DialogMessageButton_DialogMessageButtonCenter: DialogMessageButton = 2;
pub const DialogMessageButton_DialogMessageButtonRight: DialogMessageButton = 3;
#[doc = "Message result type\n\n"]
pub type DialogMessageButton = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogMessage {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate and fill message\n\nReturns:\n\n* DialogMessage*\n\n"]
    pub fn dialog_message_alloc() -> *mut DialogMessage;
}
extern "C" {
    #[doc = "Free message struct\n\n# Arguments\n\n* `message` - message pointer\n\n"]
    pub fn dialog_message_free(message: *mut DialogMessage);
}
extern "C" {
    #[doc = "Set message text\n\n# Arguments\n\n* `message` - message pointer\n* `text` - text, can be NULL if you don't want to display the text\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal alignment\n* `vertical` - vertical alignment\n\n"]
    pub fn dialog_message_set_text(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set message header\n\n# Arguments\n\n* `message` - message pointer\n* `text` - text, can be NULL if you don't want to display the header\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal alignment\n* `vertical` - vertical alignment\n\n"]
    pub fn dialog_message_set_header(
        message: *mut DialogMessage,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set message icon\n\n# Arguments\n\n* `message` - message pointer\n* `icon` - icon pointer, can be NULL if you don't want to display the icon\n* `x` - x position\n* `y` - y position\n\n"]
    pub fn dialog_message_set_icon(message: *mut DialogMessage, icon: *const Icon, x: u8, y: u8);
}
extern "C" {
    #[doc = "Set message buttons text, button text can be NULL if you don't want to display and process some buttons\n\n# Arguments\n\n* `message` - message pointer\n* `left` - left button text, can be NULL if you don't want to display the left button\n* `center` - center button text, can be NULL if you don't want to display the center button\n* `right` - right button text, can be NULL if you don't want to display the right button\n\n"]
    pub fn dialog_message_set_buttons(
        message: *mut DialogMessage,
        left: *const core::ffi::c_char,
        center: *const core::ffi::c_char,
        right: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Show message from filled struct\n\nReturns:\n\n* DialogMessageButton type\n\n# Arguments\n\n* `context` - api pointer\n* `message` - message struct pointer to be shown\n\n"]
    pub fn dialog_message_show(
        context: *mut DialogsApp,
        message: *const DialogMessage,
    ) -> DialogMessageButton;
}
extern "C" {
    #[doc = "Show SD error message (with question sign)\n\n# Arguments\n\n* `context` - \n* `error_text` - \n\n"]
    pub fn dialog_message_show_storage_error(
        context: *mut DialogsApp,
        error_text: *const core::ffi::c_char,
    );
}
pub const DolphinApp_DolphinAppSubGhz: DolphinApp = 0;
pub const DolphinApp_DolphinAppRfid: DolphinApp = 1;
pub const DolphinApp_DolphinAppNfc: DolphinApp = 2;
pub const DolphinApp_DolphinAppIr: DolphinApp = 3;
pub const DolphinApp_DolphinAppIbutton: DolphinApp = 4;
pub const DolphinApp_DolphinAppBadKb: DolphinApp = 5;
pub const DolphinApp_DolphinAppPlugin: DolphinApp = 6;
pub const DolphinApp_DolphinAppMAX: DolphinApp = 7;
pub type DolphinApp = core::ffi::c_uchar;
pub const DolphinDeed_DolphinDeedSubGhzReceiverInfo: DolphinDeed = 0;
pub const DolphinDeed_DolphinDeedSubGhzSave: DolphinDeed = 1;
pub const DolphinDeed_DolphinDeedSubGhzRawRec: DolphinDeed = 2;
pub const DolphinDeed_DolphinDeedSubGhzAddManually: DolphinDeed = 3;
pub const DolphinDeed_DolphinDeedSubGhzSend: DolphinDeed = 4;
pub const DolphinDeed_DolphinDeedSubGhzFrequencyAnalyzer: DolphinDeed = 5;
pub const DolphinDeed_DolphinDeedRfidRead: DolphinDeed = 6;
pub const DolphinDeed_DolphinDeedRfidReadSuccess: DolphinDeed = 7;
pub const DolphinDeed_DolphinDeedRfidSave: DolphinDeed = 8;
pub const DolphinDeed_DolphinDeedRfidEmulate: DolphinDeed = 9;
pub const DolphinDeed_DolphinDeedRfidAdd: DolphinDeed = 10;
pub const DolphinDeed_DolphinDeedNfcRead: DolphinDeed = 11;
pub const DolphinDeed_DolphinDeedNfcReadSuccess: DolphinDeed = 12;
pub const DolphinDeed_DolphinDeedNfcSave: DolphinDeed = 13;
pub const DolphinDeed_DolphinDeedNfcDetectReader: DolphinDeed = 14;
pub const DolphinDeed_DolphinDeedNfcEmulate: DolphinDeed = 15;
pub const DolphinDeed_DolphinDeedNfcMfcAdd: DolphinDeed = 16;
pub const DolphinDeed_DolphinDeedNfcAddSave: DolphinDeed = 17;
pub const DolphinDeed_DolphinDeedNfcAddEmulate: DolphinDeed = 18;
pub const DolphinDeed_DolphinDeedIrSend: DolphinDeed = 19;
pub const DolphinDeed_DolphinDeedIrLearnSuccess: DolphinDeed = 20;
pub const DolphinDeed_DolphinDeedIrSave: DolphinDeed = 21;
pub const DolphinDeed_DolphinDeedIbuttonRead: DolphinDeed = 22;
pub const DolphinDeed_DolphinDeedIbuttonReadSuccess: DolphinDeed = 23;
pub const DolphinDeed_DolphinDeedIbuttonSave: DolphinDeed = 24;
pub const DolphinDeed_DolphinDeedIbuttonEmulate: DolphinDeed = 25;
pub const DolphinDeed_DolphinDeedIbuttonAdd: DolphinDeed = 26;
pub const DolphinDeed_DolphinDeedBadKbPlayScript: DolphinDeed = 27;
pub const DolphinDeed_DolphinDeedU2fAuthorized: DolphinDeed = 28;
pub const DolphinDeed_DolphinDeedGpioUartBridge: DolphinDeed = 29;
pub const DolphinDeed_DolphinDeedPluginStart: DolphinDeed = 30;
pub const DolphinDeed_DolphinDeedPluginGameStart: DolphinDeed = 31;
pub const DolphinDeed_DolphinDeedPluginGameWin: DolphinDeed = 32;
pub const DolphinDeed_DolphinDeedPluginInternalStart: DolphinDeed = 33;
pub const DolphinDeed_DolphinDeedMAX: DolphinDeed = 34;
pub const DolphinDeed_DolphinDeedTestLeft: DolphinDeed = 35;
pub const DolphinDeed_DolphinDeedTestRight: DolphinDeed = 36;
pub type DolphinDeed = core::ffi::c_uchar;
extern "C" {
    pub fn dolphin_deed_get_app(deed: DolphinDeed) -> DolphinApp;
}
extern "C" {
    pub fn dolphin_deed_get_app_limit(app: DolphinApp) -> u8;
}
extern "C" {
    pub fn dolphin_deed_get_weight(deed: DolphinDeed) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dolphin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinStats {
    pub icounter: u32,
    pub butthurt: u32,
    pub timestamp: u64,
    pub level: u8,
    pub level_up_is_pending: bool,
}
#[test]
fn bindgen_test_layout_DolphinStats() {
    const UNINIT: ::core::mem::MaybeUninit<DolphinStats> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DolphinStats>(),
        24usize,
        concat!("Size of: ", stringify!(DolphinStats))
    );
    assert_eq!(
        ::core::mem::align_of::<DolphinStats>(),
        8usize,
        concat!("Alignment of ", stringify!(DolphinStats))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(icounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(butthurt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level_up_is_pending) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStats),
            "::",
            stringify!(level_up_is_pending)
        )
    );
}
extern "C" {
    #[doc = "Deed complete notification. Call it on deed completion. See dolphin_deed.h for available deeds. In futures it will become part of assets. Thread safe, async\n\n"]
    pub fn dolphin_deed(deed: DolphinDeed);
}
extern "C" {
    #[doc = "Retrieve dolphin stats Thread safe, blocking\n\n"]
    pub fn dolphin_stats(dolphin: *mut Dolphin) -> DolphinStats;
}
extern "C" {
    #[doc = "Flush dolphin queue and save state Thread safe, blocking\n\n"]
    pub fn dolphin_flush(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_upgrade_level(dolphin: *mut Dolphin);
}
extern "C" {
    pub fn dolphin_get_pubsub(dolphin: *mut Dolphin) -> *mut FuriPubSub;
}
extern "C" {
    pub static DOLPHIN_LEVELS: [u32; 0usize];
}
extern "C" {
    pub static DOLPHIN_LEVEL_COUNT: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinStoreData {
    pub icounter_daily_limit: [u8; 7usize],
    pub butthurt_daily_limit: u8,
    pub flags: u32,
    pub icounter: u32,
    pub butthurt: i32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_DolphinStoreData() {
    const UNINIT: ::core::mem::MaybeUninit<DolphinStoreData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DolphinStoreData>(),
        32usize,
        concat!("Size of: ", stringify!(DolphinStoreData))
    );
    assert_eq!(
        ::core::mem::align_of::<DolphinStoreData>(),
        8usize,
        concat!("Alignment of ", stringify!(DolphinStoreData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icounter_daily_limit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(icounter_daily_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt_daily_limit) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(butthurt_daily_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icounter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(icounter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(butthurt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinStoreData),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DolphinState {
    pub data: DolphinStoreData,
    pub dirty: bool,
}
#[test]
fn bindgen_test_layout_DolphinState() {
    const UNINIT: ::core::mem::MaybeUninit<DolphinState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DolphinState>(),
        40usize,
        concat!("Size of: ", stringify!(DolphinState))
    );
    assert_eq!(
        ::core::mem::align_of::<DolphinState>(),
        8usize,
        concat!("Alignment of ", stringify!(DolphinState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinState),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DolphinState),
            "::",
            stringify!(dirty)
        )
    );
}
extern "C" {
    pub fn dolphin_state_alloc() -> *mut DolphinState;
}
extern "C" {
    pub fn dolphin_state_free(dolphin_state: *mut DolphinState);
}
extern "C" {
    pub fn dolphin_state_save(dolphin_state: *mut DolphinState) -> bool;
}
extern "C" {
    pub fn dolphin_state_load(dolphin_state: *mut DolphinState) -> bool;
}
extern "C" {
    pub fn dolphin_state_clear_limits(dolphin_state: *mut DolphinState);
}
extern "C" {
    pub fn dolphin_state_timestamp() -> u64;
}
extern "C" {
    pub fn dolphin_state_on_deed(dolphin_state: *mut DolphinState, deed: DolphinDeed);
}
extern "C" {
    pub fn dolphin_state_butthurted(dolphin_state: *mut DolphinState);
}
extern "C" {
    pub fn dolphin_state_xp_to_levelup(icounter: u32) -> u32;
}
extern "C" {
    pub fn dolphin_state_xp_above_last_levelup(icounter: u32) -> u32;
}
extern "C" {
    pub fn dolphin_state_is_levelup(icounter: u32) -> bool;
}
extern "C" {
    pub fn dolphin_state_increase_level(dolphin_state: *mut DolphinState);
}
extern "C" {
    pub fn dolphin_get_level(icounter: u32) -> u8;
}
extern "C" {
    #[doc = "Draw progress bar.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - progress bar position on X axis\n* `y` - progress bar position on Y axis\n* `width` - progress bar width\n* `progress` - progress (0.0 - 1.0)\n\n"]
    pub fn elements_progress_bar(canvas: *mut Canvas, x: u8, y: u8, width: u8, progress: f32);
}
extern "C" {
    #[doc = "Draw progress bar with text.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - progress bar position on X axis\n* `y` - progress bar position on Y axis\n* `width` - progress bar width\n* `progress` - progress (0.0 - 1.0)\n* `text` - text to draw\n\n"]
    pub fn elements_progress_bar_with_text(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        progress: f32,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Draw scrollbar on canvas at specific position.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - scrollbar position on X axis\n* `y` - scrollbar position on Y axis\n* `height` - scrollbar height\n* `pos` - current element\n* `total` - total elements\n\n"]
    pub fn elements_scrollbar_pos(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        height: u8,
        pos: u16,
        total: u16,
    );
}
extern "C" {
    #[doc = "Draw horizontal scrollbar on canvas at specific position.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - scrollbar position on X axis\n* `y` - scrollbar position on Y axis\n* `width` - scrollbar width\n* `pos` - current element\n* `total` - total elements\n\n"]
    pub fn elements_scrollbar_horizontal(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        pos: u16,
        total: u16,
    );
}
extern "C" {
    #[doc = "Draw scrollbar on canvas.\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `pos` - current element of total elements\n* `total` - total elements\n\n# Notes\n\n* width 3px, height equal to canvas height\n\n"]
    pub fn elements_scrollbar(canvas: *mut Canvas, pos: u16, total: u16);
}
extern "C" {
    #[doc = "Draw rounded frame\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `width,` - height frame width and height\n\n"]
    pub fn elements_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw button in left corner\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `str` - button text\n\n"]
    pub fn elements_button_left(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Draw button in right corner\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `str` - button text\n\n"]
    pub fn elements_button_right(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Draw button in center\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `str` - button text\n\n"]
    pub fn elements_button_center(canvas: *mut Canvas, str_: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Draw aligned multiline text\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y coordinates based on align param\n* `horizontal,` - vertical alignment of multiline text\n* `text` - string (possible multiline)\n\n"]
    pub fn elements_multiline_text_aligned(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Draw multiline text\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `text` - string (possible multiline)\n\n"]
    pub fn elements_multiline_text(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Draw framed multiline text\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `text` - string (possible multiline)\n\n"]
    pub fn elements_multiline_text_framed(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Draw slightly rounded frame\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `width,` - height size of frame\n\n"]
    pub fn elements_slightly_rounded_frame(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
    );
}
extern "C" {
    #[doc = "Draw slightly rounded box\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `width,` - height size of box\n\n"]
    pub fn elements_slightly_rounded_box(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw bold rounded frame\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x,` - y top left corner coordinates\n* `width,` - height size of frame\n\n"]
    pub fn elements_bold_rounded_frame(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw bubble frame for text\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - left x coordinates\n* `y` - top y coordinate\n* `width` - bubble width\n* `height` - bubble height\n\n"]
    pub fn elements_bubble(canvas: *mut Canvas, x: u8, y: u8, width: u8, height: u8);
}
extern "C" {
    #[doc = "Draw bubble frame for text with corner\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - left x coordinates\n* `y` - top y coordinate\n* `width` - bubble width\n* `height` - bubble height\n* `horizontal` - horizontal aligning\n* `vertical` - aligning\n\n"]
    pub fn elements_bubble_str(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        text: *const core::ffi::c_char,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Trim string buffer to fit width in pixels\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `string` - string to trim\n* `width` - max width\n\n"]
    pub fn elements_string_fit_width(canvas: *mut Canvas, string: *mut FuriString, width: u8);
}
extern "C" {
    #[doc = "Draw scrollable text line\n\n# Arguments\n\n* `canvas` - The canvas\n* `x` - [Direction: In] X coordinate\n* `y` - [Direction: In] Y coordinate\n* `width` - [Direction: In] The width\n* `string` - The string\n* `scroll` - [Direction: In] The scroll counter: 0 - no scroll, any other number - scroll. Just count up, everything else will be calculated on the inside.\n* `ellipsis` - [Direction: In] The ellipsis flag: true to add ellipse\n* `centered` - [Direction: In] The centered flag: true to center text on x and y\n\n"]
    pub fn elements_scrollable_text_line_str(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        string: *const core::ffi::c_char,
        scroll: usize,
        ellipsis: bool,
        centered: bool,
    );
}
extern "C" {
    pub fn elements_scrollable_text_line(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        string: *mut FuriString,
        scroll: usize,
        ellipsis: bool,
    );
}
extern "C" {
    pub fn elements_scrollable_text_line_centered(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        string: *mut FuriString,
        scroll: usize,
        ellipsis: bool,
        centered: bool,
    );
}
extern "C" {
    #[doc = "Draw text box element\n\n# Arguments\n\n* `canvas` - Canvas instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - width to fit text\n* `height` - height to fit text\n* `horizontal` - Align instance\n* `vertical` - Align instance\n* `text` - [Direction: In] Formatted text. The following formats are available:\n  * text\\e#\"* - bold font is used\n  * text\\e*\"* - monospaced font is used\n  * text\\e!\"* - white text on black background\n* `strip_to_dots` - Strip text to ... if does not fit to width\n\n"]
    pub fn elements_text_box(
        canvas: *mut Canvas,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Icon {
    pub width: u8,
    pub height: u8,
    pub frame_count: u8,
    pub frame_rate: u8,
    pub frames: *const *const u8,
    pub original: *mut Icon,
}
#[test]
fn bindgen_test_layout_Icon() {
    const UNINIT: ::core::mem::MaybeUninit<Icon> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Icon>(),
        12usize,
        concat!("Size of: ", stringify!(Icon))
    );
    assert_eq!(
        ::core::mem::align_of::<Icon>(),
        4usize,
        concat!("Alignment of ", stringify!(Icon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frame_rate) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frames) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(frames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).original) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Icon),
            "::",
            stringify!(original)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonMenuItem {
    _unused: [u8; 0],
}
#[doc = "Callback for any button menu actions\n\n"]
pub type ButtonMenuItemCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, index: i32, type_: InputType),
>;
pub const ButtonMenuItemType_ButtonMenuItemTypeCommon: ButtonMenuItemType = 0;
pub const ButtonMenuItemType_ButtonMenuItemTypeControl: ButtonMenuItemType = 1;
#[doc = "Type of button. Difference in drawing buttons.\n\n"]
pub type ButtonMenuItemType = core::ffi::c_uchar;
extern "C" {
    #[doc = "Get button menu view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n\n"]
    pub fn button_menu_get_view(button_menu: *mut ButtonMenu) -> *mut View;
}
extern "C" {
    #[doc = "Clean button menu\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n\n"]
    pub fn button_menu_reset(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = "Add item to button menu instance\n\nReturns:\n\n* pointer to just-created item\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n* `label` - text inside new button\n* `index` - value to distinct between buttons inside ButtonMenuItemCallback\n* `callback` - The callback\n* `type` - type of button to create. Differ by button drawing. Control buttons have no frames, and have more squared borders.\n* `callback_context` - The callback context\n\n"]
    pub fn button_menu_add_item(
        button_menu: *mut ButtonMenu,
        label: *const core::ffi::c_char,
        index: i32,
        callback: ButtonMenuItemCallback,
        type_: ButtonMenuItemType,
        callback_context: *mut core::ffi::c_void,
    ) -> *mut ButtonMenuItem;
}
extern "C" {
    #[doc = "Allocate and initialize new instance of ButtonMenu model\n\nReturns:\n\n* just-created ButtonMenu model\n\n"]
    pub fn button_menu_alloc() -> *mut ButtonMenu;
}
extern "C" {
    #[doc = "Free ButtonMenu element\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n\n"]
    pub fn button_menu_free(button_menu: *mut ButtonMenu);
}
extern "C" {
    #[doc = "Set ButtonMenu header on top of canvas\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n* `header` - header on the top of button menu\n\n"]
    pub fn button_menu_set_header(button_menu: *mut ButtonMenu, header: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set selected item\n\n# Arguments\n\n* `button_menu` - ButtonMenu instance\n* `index` - index of ButtonMenu to be selected\n\n"]
    pub fn button_menu_set_selected_item(button_menu: *mut ButtonMenu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ButtonPanel {
    _unused: [u8; 0],
}
#[doc = "Callback type to call for handling selecting button_panel items\n\n"]
pub type ButtonItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = "Allocate new button_panel module.\n\nReturns:\n\n* ButtonPanel instance\n\n"]
    pub fn button_panel_alloc() -> *mut ButtonPanel;
}
extern "C" {
    #[doc = "Free button_panel module.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n\n"]
    pub fn button_panel_free(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = "Free items from button_panel module. Preallocated matrix stays unchanged.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n\n"]
    pub fn button_panel_reset(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = "Resets selected_item_x and selected_item_y.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n\n"]
    pub fn button_panel_reset_selection(button_panel: *mut ButtonPanel);
}
extern "C" {
    #[doc = "Reserve space for adding items.\nOne does not simply use button_panel_add_item() without this function. It should be allocated space for it first.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n* `reserve_x` - number of columns in button_panel\n* `reserve_y` - number of rows in button_panel\n\n"]
    pub fn button_panel_reserve(button_panel: *mut ButtonPanel, reserve_x: usize, reserve_y: usize);
}
extern "C" {
    #[doc = "Add item to button_panel module.\nHave to set element in bounds of allocated size by X and by Y.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n* `index` - value to pass to callback\n* `matrix_place_x` - coordinates by x-axis on virtual grid, it is only used for navigation\n* `matrix_place_y` - coordinates by y-axis on virtual grid, it is only used for navigation\n* `x` - x-coordinate to draw icon on\n* `y` - y-coordinate to draw icon on\n* `icon_name` - name of the icon to draw\n* `icon_name_selected` - name of the icon to draw when current element is selected\n* `callback` - function to call when specific element is selected (pressed Ok on selected item)\n* `callback_context` - context to pass to callback\n\n"]
    pub fn button_panel_add_item(
        button_panel: *mut ButtonPanel,
        index: u32,
        matrix_place_x: u16,
        matrix_place_y: u16,
        x: u16,
        y: u16,
        icon_name: *const Icon,
        icon_name_selected: *const Icon,
        callback: ButtonItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Get button_panel view.\n\nReturns:\n\n* acquired view\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n\n"]
    pub fn button_panel_get_view(button_panel: *mut ButtonPanel) -> *mut View;
}
extern "C" {
    #[doc = "Add label to button_panel module.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n* `x` - x-coordinate to place label\n* `y` - y-coordinate to place label\n* `font` - font to write label with\n* `label_str` - string label to write\n\n"]
    pub fn button_panel_add_label(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        font: Font,
        label_str: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Add a non-button icon to button_panel module.\n\n# Arguments\n\n* `button_panel` - ButtonPanel instance\n* `x` - x-coordinate to place icon\n* `y` - y-coordinate to place icon\n* `icon_name` - name of the icon to draw\n\n"]
    pub fn button_panel_add_icon(
        button_panel: *mut ButtonPanel,
        x: u16,
        y: u16,
        icon_name: *const Icon,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteInput {
    _unused: [u8; 0],
}
#[doc = "callback that is executed on save button press\n\n"]
pub type ByteInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "callback that is executed when byte buffer is changed\n\n"]
pub type ByteChangedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Allocate and initialize byte input. This byte input is used to enter bytes.\n\nReturns:\n\n* ByteInput instance pointer\n\n"]
    pub fn byte_input_alloc() -> *mut ByteInput;
}
extern "C" {
    #[doc = "Deinitialize and free byte input\n\n# Arguments\n\n* `byte_input` - Byte input instance\n\n"]
    pub fn byte_input_free(byte_input: *mut ByteInput);
}
extern "C" {
    #[doc = "Get byte input view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `byte_input` - byte input instance\n\n"]
    pub fn byte_input_get_view(byte_input: *mut ByteInput) -> *mut View;
}
extern "C" {
    #[doc = "Set byte input result callback\n\n# Arguments\n\n* `byte_input` - byte input instance\n* `input_callback` - input callback fn\n* `changed_callback` - changed callback fn\n* `callback_context` - callback context\n* `bytes` - buffer to use\n* `bytes_count` - buffer length\n\n"]
    pub fn byte_input_set_result_callback(
        byte_input: *mut ByteInput,
        input_callback: ByteInputCallback,
        changed_callback: ByteChangedCallback,
        callback_context: *mut core::ffi::c_void,
        bytes: *mut u8,
        bytes_count: u8,
    );
}
extern "C" {
    #[doc = "Set byte input header text\n\n# Arguments\n\n* `byte_input` - byte input instance\n* `text` - text to be shown\n\n"]
    pub fn byte_input_set_header_text(byte_input: *mut ByteInput, text: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DialogEx {
    _unused: [u8; 0],
}
pub const DialogExResult_DialogExResultLeft: DialogExResult = 0;
pub const DialogExResult_DialogExResultCenter: DialogExResult = 1;
pub const DialogExResult_DialogExResultRight: DialogExResult = 2;
pub const DialogExResult_DialogExPressLeft: DialogExResult = 3;
pub const DialogExResult_DialogExPressCenter: DialogExResult = 4;
pub const DialogExResult_DialogExPressRight: DialogExResult = 5;
pub const DialogExResult_DialogExReleaseLeft: DialogExResult = 6;
pub const DialogExResult_DialogExReleaseCenter: DialogExResult = 7;
pub const DialogExResult_DialogExReleaseRight: DialogExResult = 8;
#[doc = "DialogEx result\n\n"]
pub type DialogExResult = core::ffi::c_uchar;
#[doc = "DialogEx result callback type\n\n**Warning!**\n\n* comes from GUI thread\n\n"]
pub type DialogExResultCallback = ::core::option::Option<
    unsafe extern "C" fn(result: DialogExResult, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Allocate and initialize dialog\nThis dialog used to ask simple questions\n\nReturns:\n\n* DialogEx instance\n\n"]
    pub fn dialog_ex_alloc() -> *mut DialogEx;
}
extern "C" {
    #[doc = "Deinitialize and free dialog\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n\n"]
    pub fn dialog_ex_free(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = "Get dialog view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n\n"]
    pub fn dialog_ex_get_view(dialog_ex: *mut DialogEx) -> *mut View;
}
extern "C" {
    #[doc = "Set dialog result callback\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `callback` - result callback function\n\n"]
    pub fn dialog_ex_set_result_callback(
        dialog_ex: *mut DialogEx,
        callback: DialogExResultCallback,
    );
}
extern "C" {
    #[doc = "Set dialog context\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `context` - context pointer, will be passed to result callback\n\n"]
    pub fn dialog_ex_set_context(dialog_ex: *mut DialogEx, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set dialog header text\nIf text is null, dialog header will not be rendered\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `text` - text to be shown, can be multiline\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal text alignment\n* `vertical` - vertical text alignment\n\n"]
    pub fn dialog_ex_set_header(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set dialog text\nIf text is null, dialog text will not be rendered\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `text` - text to be shown, can be multiline\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal text alignment\n* `vertical` - vertical text alignment\n\n"]
    pub fn dialog_ex_set_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set dialog icon\nIf x or y is negative, dialog icon will not be rendered\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `x` - x position\n* `y` - y position\n* `icon` - The icon\n* `name` - icon to be shown\n\n"]
    pub fn dialog_ex_set_icon(dialog_ex: *mut DialogEx, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = "Set left button text\nIf text is null, left button will not be rendered and processed\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `text` - text to be shown\n\n"]
    pub fn dialog_ex_set_left_button_text(dialog_ex: *mut DialogEx, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set center button text\nIf text is null, center button will not be rendered and processed\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `text` - text to be shown\n\n"]
    pub fn dialog_ex_set_center_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Set right button text\nIf text is null, right button will not be rendered and processed\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n* `text` - text to be shown\n\n"]
    pub fn dialog_ex_set_right_button_text(
        dialog_ex: *mut DialogEx,
        text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Clean dialog\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n\n"]
    pub fn dialog_ex_reset(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = "Enable press/release events\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n\n"]
    pub fn dialog_ex_enable_extended_events(dialog_ex: *mut DialogEx);
}
extern "C" {
    #[doc = "Disable press/release events\n\n# Arguments\n\n* `dialog_ex` - DialogEx instance\n\n"]
    pub fn dialog_ex_disable_extended_events(dialog_ex: *mut DialogEx);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyScreen {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate and initialize empty screen\nThis empty screen used to ask simple questions like Yes/\n\nReturns:\n\n* EmptyScreen instance\n\n"]
    pub fn empty_screen_alloc() -> *mut EmptyScreen;
}
extern "C" {
    #[doc = "Deinitialize and free empty screen\n\n# Arguments\n\n* `empty_screen` - Empty screen instance\n\n"]
    pub fn empty_screen_free(empty_screen: *mut EmptyScreen);
}
extern "C" {
    #[doc = "Get empty screen view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `empty_screen` - Empty screen instance\n\n"]
    pub fn empty_screen_get_view(empty_screen: *mut EmptyScreen) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BrowserWorker {
    _unused: [u8; 0],
}
pub type BrowserWorkerFolderOpenCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_cnt: u32,
        file_idx: i32,
        is_root: bool,
    ),
>;
pub type BrowserWorkerListLoadCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, list_load_offset: u32),
>;
pub type BrowserWorkerListItemCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        item_path: *mut FuriString,
        is_folder: bool,
        is_last: bool,
    ),
>;
pub type BrowserWorkerLongLoadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn file_browser_worker_alloc(
        path: *mut FuriString,
        base_path: *const core::ffi::c_char,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    ) -> *mut BrowserWorker;
}
extern "C" {
    pub fn file_browser_worker_free(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_set_callback_context(
        browser: *mut BrowserWorker,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn file_browser_worker_set_folder_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerFolderOpenCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_list_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_item_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerListItemCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_long_load_callback(
        browser: *mut BrowserWorker,
        cb: BrowserWorkerLongLoadCallback,
    );
}
extern "C" {
    pub fn file_browser_worker_set_config(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        filter_ext: *const core::ffi::c_char,
        skip_assets: bool,
        hide_dot_files: bool,
    );
}
extern "C" {
    pub fn file_browser_worker_get_filter_ext(
        browser: *mut BrowserWorker,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn file_browser_worker_set_filter_ext(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        filter_ext: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn file_browser_worker_folder_enter(
        browser: *mut BrowserWorker,
        path: *mut FuriString,
        item_idx: i32,
    );
}
extern "C" {
    pub fn file_browser_worker_is_in_start_folder(browser: *mut BrowserWorker) -> bool;
}
extern "C" {
    pub fn file_browser_worker_folder_exit(browser: *mut BrowserWorker);
}
extern "C" {
    pub fn file_browser_worker_folder_refresh(browser: *mut BrowserWorker, item_idx: i32);
}
extern "C" {
    pub fn file_browser_worker_folder_refresh_sel(
        browser: *mut BrowserWorker,
        item_name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn file_browser_worker_load(browser: *mut BrowserWorker, offset: u32, count: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loading {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate and initialize\nThis View used to show system is doing some processing\n\nReturns:\n\n* Loading View instance\n\n"]
    pub fn loading_alloc() -> *mut Loading;
}
extern "C" {
    #[doc = "Deinitialize and free Loading View\n\n# Arguments\n\n* `instance` - Loading instance\n\n"]
    pub fn loading_free(instance: *mut Loading);
}
extern "C" {
    #[doc = "Get Loading view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `instance` - Loading instance\n\n"]
    pub fn loading_get_view(instance: *mut Loading) -> *mut View;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Menu {
    _unused: [u8; 0],
}
#[doc = "Menu Item Callback\n\n"]
pub type MenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = "Menu allocation and initialization\n\nReturns:\n\n* Menu instance\n\n"]
    pub fn menu_alloc() -> *mut Menu;
}
extern "C" {
    #[doc = "Free menu\n\n# Arguments\n\n* `menu` - Menu instance\n\n"]
    pub fn menu_free(menu: *mut Menu);
}
extern "C" {
    #[doc = "Get Menu view\n\nReturns:\n\n* View instance\n\n# Arguments\n\n* `menu` - Menu instance\n\n"]
    pub fn menu_get_view(menu: *mut Menu) -> *mut View;
}
extern "C" {
    #[doc = "Add item to menu\n\n# Arguments\n\n* `menu` - Menu instance\n* `label` - menu item string label\n* `icon` - IconAnimation instance\n* `index` - menu item index\n* `callback` - MenuItemCallback instance\n* `context` - pointer to context\n\n"]
    pub fn menu_add_item(
        menu: *mut Menu,
        label: *const core::ffi::c_char,
        icon: *const Icon,
        index: u32,
        callback: MenuItemCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Clean menu\n\n# Arguments\n\n* `menu` - Menu instance\n\n# Notes\n\n* this function does not free menu instance\n\n"]
    pub fn menu_reset(menu: *mut Menu);
}
extern "C" {
    #[doc = "Set current menu item\n\n# Arguments\n\n* `menu` - Menu instance\n* `index` - The index\n\n"]
    pub fn menu_set_selected_item(menu: *mut Menu, index: u32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Popup {
    _unused: [u8; 0],
}
#[doc = "Popup result callback type\n\n**Warning!**\n\n* comes from GUI thread\n\n"]
pub type PopupCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Allocate and initialize popup\nThis popup used to ask simple questions like Yes/\n\nReturns:\n\n* Popup instance\n\n"]
    pub fn popup_alloc() -> *mut Popup;
}
extern "C" {
    #[doc = "Deinitialize and free popup\n\n# Arguments\n\n* `popup` - Popup instance\n\n"]
    pub fn popup_free(popup: *mut Popup);
}
extern "C" {
    #[doc = "Get popup view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `popup` - Popup instance\n\n"]
    pub fn popup_get_view(popup: *mut Popup) -> *mut View;
}
extern "C" {
    #[doc = "Set popup callback function\n\n# Arguments\n\n* `popup` - Popup instance\n* `callback` - PopupCallback\n\n"]
    pub fn popup_set_callback(popup: *mut Popup, callback: PopupCallback);
}
extern "C" {
    #[doc = "Set popup context\n\n# Arguments\n\n* `popup` - Popup instance\n* `context` - context pointer, will be passed to result callback\n\n"]
    pub fn popup_set_context(popup: *mut Popup, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set popup header text\nIf text is null, popup header will not be rendered\n\n# Arguments\n\n* `popup` - Popup instance\n* `text` - text to be shown, can be multiline\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal alignment\n* `vertical` - vertical alignment\n\n"]
    pub fn popup_set_header(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set popup text\nIf text is null, popup text will not be rendered\n\n# Arguments\n\n* `popup` - Popup instance\n* `text` - text to be shown, can be multiline\n* `x` - x position\n* `y` - y position\n* `horizontal` - horizontal alignment\n* `vertical` - vertical alignment\n\n"]
    pub fn popup_set_text(
        popup: *mut Popup,
        text: *const core::ffi::c_char,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
    );
}
extern "C" {
    #[doc = "Set popup icon\nIf icon position is negative, popup icon will not be rendered\n\n# Arguments\n\n* `popup` - Popup instance\n* `x` - x position\n* `y` - y position\n* `icon` - pointer to Icon data\n\n"]
    pub fn popup_set_icon(popup: *mut Popup, x: u8, y: u8, icon: *const Icon);
}
extern "C" {
    #[doc = "Set popup timeout\n\n# Arguments\n\n* `popup` - Popup instance\n* `timeout_in_ms` - popup timeout value in milliseconds\n\n"]
    pub fn popup_set_timeout(popup: *mut Popup, timeout_in_ms: u32);
}
extern "C" {
    #[doc = "Enable popup timeout\n\n# Arguments\n\n* `popup` - Popup instance\n\n"]
    pub fn popup_enable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = "Disable popup timeout\n\n# Arguments\n\n* `popup` - Popup instance\n\n"]
    pub fn popup_disable_timeout(popup: *mut Popup);
}
extern "C" {
    #[doc = "Reset popup instance state\n\n# Arguments\n\n* `popup` - Popup instance\n\n"]
    pub fn popup_reset(popup: *mut Popup);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Submenu {
    _unused: [u8; 0],
}
pub type SubmenuItemCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = "Allocate and initialize submenu\nThis submenu is used to select one option\n\nReturns:\n\n* Submenu instance\n\n"]
    pub fn submenu_alloc() -> *mut Submenu;
}
extern "C" {
    #[doc = "Deinitialize and free submenu\n\n# Arguments\n\n* `submenu` - Submenu instance\n\n"]
    pub fn submenu_free(submenu: *mut Submenu);
}
extern "C" {
    #[doc = "Get submenu view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `submenu` - Submenu instance\n\n"]
    pub fn submenu_get_view(submenu: *mut Submenu) -> *mut View;
}
extern "C" {
    #[doc = "Add item to submenu\n\n# Arguments\n\n* `submenu` - Submenu instance\n* `label` - menu item label\n* `index` - menu item index, used for callback, may be the same with other items\n* `callback` - menu item callback\n* `callback_context` - menu item callback context\n\n"]
    pub fn submenu_add_item(
        submenu: *mut Submenu,
        label: *const core::ffi::c_char,
        index: u32,
        callback: SubmenuItemCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Add lockable item to submenu\n\n# Arguments\n\n* `submenu` - Submenu instance\n* `label` - menu item label\n* `index` - menu item index, used for callback, may be the same with other items\n* `callback` - menu item callback\n* `callback_context` - menu item callback context\n* `locked` - menu item locked status\n* `locked_message` - menu item locked message\n\n"]
    pub fn submenu_add_lockable_item(
        submenu: *mut Submenu,
        label: *const core::ffi::c_char,
        index: u32,
        callback: SubmenuItemCallback,
        callback_context: *mut core::ffi::c_void,
        locked: bool,
        locked_message: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Remove all items from submenu\n\n# Arguments\n\n* `submenu` - Submenu instance\n\n"]
    pub fn submenu_reset(submenu: *mut Submenu);
}
extern "C" {
    #[doc = "Set submenu item selector\n\n# Arguments\n\n* `submenu` - Submenu instance\n* `index` - The index\n\n"]
    pub fn submenu_set_selected_item(submenu: *mut Submenu, index: u32);
}
extern "C" {
    #[doc = "Set optional header for submenu Must be called before adding items OR after adding items but also call set_selected_item() after set_header()\n\n# Arguments\n\n* `submenu` - Submenu instance\n* `header` - header to set\n\n"]
    pub fn submenu_set_header(submenu: *mut Submenu, header: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set Orientation\n\n# Arguments\n\n* `submenu` - Submenu instance\n* `orientation` - either vertical or horizontal\n\n"]
    pub fn submenu_set_orientation(submenu: *mut Submenu, orientation: ViewOrientation);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextBox {
    _unused: [u8; 0],
}
pub const TextBoxFont_TextBoxFontText: TextBoxFont = 0;
pub const TextBoxFont_TextBoxFontHex: TextBoxFont = 1;
pub type TextBoxFont = core::ffi::c_uchar;
pub const TextBoxFocus_TextBoxFocusStart: TextBoxFocus = 0;
pub const TextBoxFocus_TextBoxFocusEnd: TextBoxFocus = 1;
pub type TextBoxFocus = core::ffi::c_uchar;
extern "C" {
    #[doc = "Allocate and initialize text_box\n\nReturns:\n\n* TextBox instance\n\n"]
    pub fn text_box_alloc() -> *mut TextBox;
}
extern "C" {
    #[doc = "Deinitialize and free text_box\n\n# Arguments\n\n* `text_box` - text_box instance\n\n"]
    pub fn text_box_free(text_box: *mut TextBox);
}
extern "C" {
    #[doc = "Get text_box view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `text_box` - TextBox instance\n\n"]
    pub fn text_box_get_view(text_box: *mut TextBox) -> *mut View;
}
extern "C" {
    #[doc = "Clean text_box\n\n# Arguments\n\n* `text_box` - TextBox instance\n\n"]
    pub fn text_box_reset(text_box: *mut TextBox);
}
extern "C" {
    #[doc = "Set text for text_box\n\n# Arguments\n\n* `text_box` - TextBox instance\n* `text` - text to set\n\n"]
    pub fn text_box_set_text(text_box: *mut TextBox, text: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set TextBox font\n\n# Arguments\n\n* `text_box` - TextBox instance\n* `font` - TextBoxFont instance\n\n"]
    pub fn text_box_set_font(text_box: *mut TextBox, font: TextBoxFont);
}
extern "C" {
    #[doc = "Set TextBox focus\n\n# Arguments\n\n* `text_box` - TextBox instance\n* `focus` - TextBoxFocus instance\n\n# Notes\n\n* Use to display from start or from end\n\n"]
    pub fn text_box_set_focus(text_box: *mut TextBox, focus: TextBoxFocus);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ValidatorIsFile {
    _unused: [u8; 0],
}
extern "C" {
    pub fn validator_is_file_alloc_init(
        app_path_folder: *const core::ffi::c_char,
        app_extension: *const core::ffi::c_char,
        current_name: *const core::ffi::c_char,
    ) -> *mut ValidatorIsFile;
}
extern "C" {
    pub fn validator_is_file_free(instance: *mut ValidatorIsFile);
}
extern "C" {
    pub fn validator_is_file_callback(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextInput {
    _unused: [u8; 0],
}
pub type TextInputCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type TextInputValidatorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        text: *const core::ffi::c_char,
        error: *mut FuriString,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = "Allocate and initialize text input\nThis text input is used to enter string\n\nReturns:\n\n* TextInput instance\n\n"]
    pub fn text_input_alloc() -> *mut TextInput;
}
extern "C" {
    #[doc = "Deinitialize and free text input\n\n# Arguments\n\n* `text_input` - TextInput instance\n\n"]
    pub fn text_input_free(text_input: *mut TextInput);
}
extern "C" {
    #[doc = "Clean text input view Note: this function does not free memory\n\n# Arguments\n\n* `text_input` - Text input instance\n\n"]
    pub fn text_input_reset(text_input: *mut TextInput);
}
extern "C" {
    #[doc = "Get text input view\n\nReturns:\n\n* View instance that can be used for embedding\n\n# Arguments\n\n* `text_input` - TextInput instance\n\n"]
    pub fn text_input_get_view(text_input: *mut TextInput) -> *mut View;
}
extern "C" {
    #[doc = "Set text input result callback\n\n# Arguments\n\n* `text_input` - TextInput instance\n* `callback` - callback fn\n* `callback_context` - callback context\n* `text_buffer` - pointer to YOUR text buffer, that we going to modify\n* `text_buffer_size` - YOUR text buffer size in bytes. Max string length will be text_buffer_size-1.\n* `clear_default_text` - clear text from text_buffer on first OK event\n\n"]
    pub fn text_input_set_result_callback(
        text_input: *mut TextInput,
        callback: TextInputCallback,
        callback_context: *mut core::ffi::c_void,
        text_buffer: *mut core::ffi::c_char,
        text_buffer_size: usize,
        clear_default_text: bool,
    );
}
extern "C" {
    pub fn text_input_set_validator(
        text_input: *mut TextInput,
        callback: TextInputValidatorCallback,
        callback_context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn text_input_set_minimum_length(text_input: *mut TextInput, minimum_length: usize);
}
extern "C" {
    pub fn text_input_add_extra_symbol(text_input: *mut TextInput, symbol: core::ffi::c_char);
}
extern "C" {
    pub fn text_input_add_illegal_symbols(text_input: *mut TextInput);
}
extern "C" {
    pub fn text_input_get_validator_callback(
        text_input: *mut TextInput,
    ) -> TextInputValidatorCallback;
}
extern "C" {
    pub fn text_input_get_validator_callback_context(
        text_input: *mut TextInput,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Set text input header text\n\n# Arguments\n\n* `text_input` - TextInput instance\n* `text` - text to be shown\n\n"]
    pub fn text_input_set_header_text(text_input: *mut TextInput, text: *const core::ffi::c_char);
}
extern "C" {
    pub fn text_input_insert_character(text_input: *mut TextInput, c: core::ffi::c_char) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItemList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VariableItem {
    _unused: [u8; 0],
}
pub type VariableItemChangeCallback =
    ::core::option::Option<unsafe extern "C" fn(item: *mut VariableItem)>;
pub type VariableItemListEnterCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, index: u32)>;
extern "C" {
    #[doc = "Allocate and initialize VariableItemList\n\nReturns:\n\n* VariableItemList*\n\n"]
    pub fn variable_item_list_alloc() -> *mut VariableItemList;
}
extern "C" {
    #[doc = "Deinitialize and free VariableItemList\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n\n"]
    pub fn variable_item_list_free(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = "Clear all elements from list\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n\n"]
    pub fn variable_item_list_reset(variable_item_list: *mut VariableItemList);
}
extern "C" {
    #[doc = "Get VariableItemList View instance\n\nReturns:\n\n* View instance\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n\n"]
    pub fn variable_item_list_get_view(variable_item_list: *mut VariableItemList) -> *mut View;
}
extern "C" {
    #[doc = "Add item to VariableItemList\n\nReturns:\n\n* VariableItem* item instance\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n* `label` - item name\n* `values_count` - item values count\n* `change_callback` - called on value change in gui\n* `context` - item context\n\n"]
    pub fn variable_item_list_add(
        variable_item_list: *mut VariableItemList,
        label: *const core::ffi::c_char,
        values_count: u8,
        change_callback: VariableItemChangeCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut VariableItem;
}
extern "C" {
    #[doc = "Set enter callback\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n* `callback` - VariableItemListEnterCallback instance\n* `context` - pointer to context\n\n"]
    pub fn variable_item_list_set_enter_callback(
        variable_item_list: *mut VariableItemList,
        callback: VariableItemListEnterCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn variable_item_list_set_selected_item(
        variable_item_list: *mut VariableItemList,
        index: u8,
    );
}
extern "C" {
    pub fn variable_item_list_get_selected_item_index(
        variable_item_list: *mut VariableItemList,
    ) -> u8;
}
extern "C" {
    #[doc = "Set optional header for variable item list Must be called before adding items OR after adding items but also call set_selected_item() after set_header()\n\n# Arguments\n\n* `variable_item_list` - VariableItemList instance\n* `header` - header to set\n\n"]
    pub fn variable_item_list_set_header(
        variable_item_list: *mut VariableItemList,
        header: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Set item current selected index\n\n# Arguments\n\n* `item` - VariableItem* instance\n* `current_value_index` - The current value index\n\n"]
    pub fn variable_item_set_current_value_index(item: *mut VariableItem, current_value_index: u8);
}
extern "C" {
    #[doc = "Set number of values for item\n\n# Arguments\n\n* `item` - VariableItem* instance\n* `values_count` - The new values count\n\n"]
    pub fn variable_item_set_values_count(item: *mut VariableItem, values_count: u8);
}
extern "C" {
    #[doc = "Set number of values for item\n\n# Arguments\n\n* `item` - VariableItem* instance\n* `label` - The new label text\n\n"]
    pub fn variable_item_set_item_label(item: *mut VariableItem, label: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Set item current selected text\n\n# Arguments\n\n* `item` - VariableItem* instance\n* `current_value_text` - The current value text\n\n"]
    pub fn variable_item_set_current_value_text(
        item: *mut VariableItem,
        current_value_text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Set item locked state and text\n\n# Arguments\n\n* `item` - VariableItem* instance\n* `locked` - Is item locked boolean\n* `locked_message` - The locked message text\n\n"]
    pub fn variable_item_set_locked(
        item: *mut VariableItem,
        locked: bool,
        locked_message: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Get item current selected index\n\nReturns:\n\n* uint8_t current selected index\n\n# Arguments\n\n* `item` - VariableItem* instance\n\n"]
    pub fn variable_item_get_current_value_index(item: *mut VariableItem) -> u8;
}
extern "C" {
    #[doc = "Get item context\n\nReturns:\n\n* void* item context\n\n# Arguments\n\n* `item` - VariableItem* instance\n\n"]
    pub fn variable_item_get_context(item: *mut VariableItem) -> *mut core::ffi::c_void;
}
pub const GuiButtonType_GuiButtonTypeLeft: GuiButtonType = 0;
pub const GuiButtonType_GuiButtonTypeCenter: GuiButtonType = 1;
pub const GuiButtonType_GuiButtonTypeRight: GuiButtonType = 2;
pub type GuiButtonType = core::ffi::c_uchar;
pub type ButtonCallback = ::core::option::Option<
    unsafe extern "C" fn(result: GuiButtonType, type_: InputType, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Widget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WidgetElement {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate Widget that holds Widget Elements\n\nReturns:\n\n* Widget instance\n\n"]
    pub fn widget_alloc() -> *mut Widget;
}
extern "C" {
    #[doc = "Free Widget\n\n# Arguments\n\n* `widget` - Widget instance\n\n# Notes\n\n* this function free allocated Widget Elements\n\n"]
    pub fn widget_free(widget: *mut Widget);
}
extern "C" {
    #[doc = "Reset Widget\n\n# Arguments\n\n* `widget` - Widget instance\n\n"]
    pub fn widget_reset(widget: *mut Widget);
}
extern "C" {
    #[doc = "Get Widget view\n\nReturns:\n\n* View instance\n\n# Arguments\n\n* `widget` - Widget instance\n\n"]
    pub fn widget_get_view(widget: *mut Widget) -> *mut View;
}
extern "C" {
    #[doc = "Add Multi String Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `horizontal` - Align instance\n* `vertical` - Align instance\n* `font` - Font instance\n* `text` - [Direction: In] The text\n\n"]
    pub fn widget_add_string_multiline_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add String Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `horizontal` - Align instance\n* `vertical` - Align instance\n* `font` - Font instance\n* `text` - [Direction: In] The text\n\n"]
    pub fn widget_add_string_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        horizontal: Align,
        vertical: Align,
        font: Font,
        text: *const core::ffi::c_char,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add Text Box Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - width to fit text\n* `height` - height to fit text\n* `horizontal` - Align instance\n* `vertical` - Align instance\n* `text` - [Direction: In] Formatted text. The following formats are available:\n  * text\\e#\"* - bold font is used\n  * text\\e*\"* - monospaced font is used\n  * text\\e!\"* - white text on black background\n* `strip_to_dots` - Strip text to ... if does not fit to width\n\n"]
    pub fn widget_add_text_box_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        horizontal: Align,
        vertical: Align,
        text: *const core::ffi::c_char,
        strip_to_dots: bool,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add Text Scroll Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - x coordinate\n* `y` - y coordinate\n* `width` - width to fit text\n* `height` - height to fit text\n* `text` - [Direction: In] Formatted text. Default format: align left, Secondary font. The following formats are available:\n  * \n    * text\"* - sets bold font before until next '\\n' symbol\n    * text\\e*\"* - sets monospaced font before until next '\\n' symbol\n    * text\"* - sets center horizontal align until the next '\\n' symbol\n    * text\"* - sets right horizontal align until the next '\\n' symbol\n\n"]
    pub fn widget_add_text_scroll_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        text: *const core::ffi::c_char,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add Button Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `button_type` - GuiButtonType instance\n* `text` - text on allocated button\n* `callback` - ButtonCallback instance\n* `context` - pointer to context\n\n"]
    pub fn widget_add_button_element(
        widget: *mut Widget,
        button_type: GuiButtonType,
        text: *const core::ffi::c_char,
        callback: ButtonCallback,
        context: *mut core::ffi::c_void,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add Icon Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - top left x coordinate\n* `y` - top left y coordinate\n* `icon` - Icon instance\n\n"]
    pub fn widget_add_icon_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        icon: *const Icon,
    ) -> *mut WidgetElement;
}
extern "C" {
    #[doc = "Add Frame Element\n\n# Arguments\n\n* `widget` - Widget instance\n* `x` - top left x coordinate\n* `y` - top left y coordinate\n* `width` - frame width\n* `height` - frame height\n* `radius` - frame radius\n\n"]
    pub fn widget_add_frame_element(
        widget: *mut Widget,
        x: u8,
        y: u8,
        width: u8,
        height: u8,
        radius: u8,
    ) -> *mut WidgetElement;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ViewStack {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate and init ViewStack\n\nReturns:\n\n* ViewStack instance\n\n"]
    pub fn view_stack_alloc() -> *mut ViewStack;
}
extern "C" {
    #[doc = "Free ViewStack instance\n\n# Arguments\n\n* `view_stack` - instance\n\n"]
    pub fn view_stack_free(view_stack: *mut ViewStack);
}
extern "C" {
    #[doc = "Get View of ViewStack. Should this View to any view manager such as ViewDispatcher or ViewHolder.\n\n# Arguments\n\n* `view_stack` - instance\n\n"]
    pub fn view_stack_get_view(view_stack: *mut ViewStack) -> *mut View;
}
extern "C" {
    #[doc = "Add View to ViewStack. Adds View on top of ViewStack.\n\n# Arguments\n\n* `view_stack` - instance\n\n"]
    pub fn view_stack_add_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
    #[doc = "Remove any View in ViewStack. If no View to remove found - ignore.\n\n# Arguments\n\n* `view_stack` - instance\n\n"]
    pub fn view_stack_remove_view(view_stack: *mut ViewStack, view: *mut View);
}
extern "C" {
    pub static firmware_api_interface: *const ElfApiInterface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Loader {
    _unused: [u8; 0],
}
pub const LoaderStatus_LoaderStatusOk: LoaderStatus = 0;
pub const LoaderStatus_LoaderStatusErrorAppStarted: LoaderStatus = 1;
pub const LoaderStatus_LoaderStatusErrorUnknownApp: LoaderStatus = 2;
pub const LoaderStatus_LoaderStatusErrorInternal: LoaderStatus = 3;
pub type LoaderStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = "Start application\n\nReturns:\n\n* LoaderStatus\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n* `name` - [Direction: In] application name or id\n* `args` - [Direction: In] application arguments\n* `error_message` - [Direction: In, Out] detailed error message, can be NULL\n\n"]
    pub fn loader_start(
        instance: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
        error_message: *mut FuriString,
    ) -> LoaderStatus;
}
extern "C" {
    #[doc = "Start application with GUI error message\n\nReturns:\n\n* LoaderStatus\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n* `name` - [Direction: In] application name or id\n* `args` - [Direction: In] application arguments\n\n"]
    pub fn loader_start_with_gui_error(
        loader: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    ) -> LoaderStatus;
}
extern "C" {
    #[doc = "Start application detached with GUI error message\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n* `name` - [Direction: In] application name\n* `args` - [Direction: In] application arguments\n\n"]
    pub fn loader_start_detached_with_gui_error(
        loader: *mut Loader,
        name: *const core::ffi::c_char,
        args: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Lock application start\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_lock(instance: *mut Loader) -> bool;
}
extern "C" {
    #[doc = "Unlock application start\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_unlock(instance: *mut Loader);
}
extern "C" {
    #[doc = "Check if loader is locked\n\nReturns:\n\n* true if locked\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_is_locked(instance: *mut Loader) -> bool;
}
extern "C" {
    #[doc = "Show loader menu\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_show_menu(instance: *mut Loader);
}
extern "C" {
    #[doc = "Show settings menu\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_show_settings(instance: *mut Loader);
}
extern "C" {
    #[doc = "Get loader pubsub\n\nReturns:\n\n* FuriPubSub*\n\n# Arguments\n\n* `instance` - [Direction: In] loader instance\n\n"]
    pub fn loader_get_pubsub(instance: *mut Loader) -> *mut FuriPubSub;
}
#[doc = "Metric measurement units\n\n"]
pub const LocaleMeasurementUnits_LocaleMeasurementUnitsMetric: LocaleMeasurementUnits = 0;
#[doc = "Imperial measurement units\n\n"]
pub const LocaleMeasurementUnits_LocaleMeasurementUnitsImperial: LocaleMeasurementUnits = 1;
pub type LocaleMeasurementUnits = core::ffi::c_uchar;
#[doc = "24-hour format\n\n"]
pub const LocaleTimeFormat_LocaleTimeFormat24h: LocaleTimeFormat = 0;
#[doc = "12-hour format\n\n"]
pub const LocaleTimeFormat_LocaleTimeFormat12h: LocaleTimeFormat = 1;
pub type LocaleTimeFormat = core::ffi::c_uchar;
#[doc = "Day/Month/Year\n\n"]
pub const LocaleDateFormat_LocaleDateFormatDMY: LocaleDateFormat = 0;
#[doc = "Month/Day/Year\n\n"]
pub const LocaleDateFormat_LocaleDateFormatMDY: LocaleDateFormat = 1;
#[doc = "Year/Month/Day\n\n"]
pub const LocaleDateFormat_LocaleDateFormatYMD: LocaleDateFormat = 2;
pub type LocaleDateFormat = core::ffi::c_uchar;
extern "C" {
    #[doc = "Get Locale measurement units\n\nReturns:\n\n* The locale measurement units.\n\n"]
    pub fn locale_get_measurement_unit() -> LocaleMeasurementUnits;
}
extern "C" {
    #[doc = "Set locale measurement units\n\n# Arguments\n\n* `format` - [Direction: In] The locale measurements units\n\n"]
    pub fn locale_set_measurement_unit(format: LocaleMeasurementUnits);
}
extern "C" {
    #[doc = "Convert Fahrenheit to Celsius\n\nReturns:\n\n* The Temperature in Celsius\n\n# Arguments\n\n* `temp_f` - [Direction: In] The Temperature in Fahrenheit\n\n"]
    pub fn locale_fahrenheit_to_celsius(temp_f: f32) -> f32;
}
extern "C" {
    #[doc = "Convert Celsius to Fahrenheit\n\nReturns:\n\n* The Temperature in Fahrenheit\n\n# Arguments\n\n* `temp_c` - [Direction: In] The Temperature in Celsius\n\n"]
    pub fn locale_celsius_to_fahrenheit(temp_c: f32) -> f32;
}
extern "C" {
    #[doc = "Get Locale time format\n\nReturns:\n\n* The locale time format.\n\n"]
    pub fn locale_get_time_format() -> LocaleTimeFormat;
}
extern "C" {
    #[doc = "Set Locale Time Format\n\n# Arguments\n\n* `format` - [Direction: In] The Locale Time Format\n\n"]
    pub fn locale_set_time_format(format: LocaleTimeFormat);
}
extern "C" {
    #[doc = "Format time to furi string\n\n# Arguments\n\n* `out_str` - [Direction: In, Out] The FuriString to store formatted time\n* `datetime` - [Direction: In] Pointer to the datetime\n* `format` - [Direction: In] The Locale Time Format\n* `show_seconds` - [Direction: In] The show seconds flag\n\n"]
    pub fn locale_format_time(
        out_str: *mut FuriString,
        datetime: *const FuriHalRtcDateTime,
        format: LocaleTimeFormat,
        show_seconds: bool,
    );
}
extern "C" {
    #[doc = "Get Locale DateFormat\n\nReturns:\n\n* The Locale DateFormat.\n\n"]
    pub fn locale_get_date_format() -> LocaleDateFormat;
}
extern "C" {
    #[doc = "Set Locale DateFormat\n\n# Arguments\n\n* `format` - [Direction: In] The Locale DateFormat\n\n"]
    pub fn locale_set_date_format(format: LocaleDateFormat);
}
extern "C" {
    #[doc = "Format date to furi string\n\n# Arguments\n\n* `out_str` - [Direction: In, Out] The FuriString to store formatted date\n* `datetime` - [Direction: In] Pointer to the datetime\n* `format` - [Direction: In] The format\n* `separator` - [Direction: In] The separator\n\n"]
    pub fn locale_format_date(
        out_str: *mut FuriString,
        datetime: *const FuriHalRtcDateTime,
        format: LocaleDateFormat,
        separator: *const core::ffi::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationApp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataSound {
    pub frequency: f32,
    pub volume: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataSound() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataSound> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataSound>(),
        8usize,
        concat!("Size of: ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataSound>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataSound))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).volume) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataSound),
            "::",
            stringify!(volume)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLed {
    pub value: u8,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLed() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLed> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLed>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLed))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLed),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataVibro {
    pub on: bool,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataVibro() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataVibro> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Size of: ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataVibro>(),
        1usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataVibro))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataVibro),
            "::",
            stringify!(on)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataDelay {
    pub length: u32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataDelay() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataDelay> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Size of: ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataDelay>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataDelay))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataDelay),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataForcedSettings {
    pub speaker_volume: f32,
    pub vibro: bool,
    pub display_brightness: f32,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataForcedSettings() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataForcedSettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataForcedSettings>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataForcedSettings>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NotificationMessageDataForcedSettings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).speaker_volume) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(speaker_volume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_brightness) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataForcedSettings),
            "::",
            stringify!(display_brightness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotificationMessageDataLedBlink {
    pub on_time: u16,
    pub period: u16,
    pub color: Light,
}
#[test]
fn bindgen_test_layout_NotificationMessageDataLedBlink() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageDataLedBlink> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageDataLedBlink>(),
        6usize,
        concat!("Size of: ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageDataLedBlink>(),
        2usize,
        concat!("Alignment of ", stringify!(NotificationMessageDataLedBlink))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(on_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageDataLedBlink),
            "::",
            stringify!(color)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NotificationMessageData {
    pub sound: NotificationMessageDataSound,
    pub led: NotificationMessageDataLed,
    pub led_blink: NotificationMessageDataLedBlink,
    pub vibro: NotificationMessageDataVibro,
    pub delay: NotificationMessageDataDelay,
    pub forced_settings: NotificationMessageDataForcedSettings,
}
#[test]
fn bindgen_test_layout_NotificationMessageData() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessageData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessageData>(),
        12usize,
        concat!("Size of: ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessageData>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessageData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sound) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(sound)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led_blink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(led_blink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vibro) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(vibro)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).forced_settings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessageData),
            "::",
            stringify!(forced_settings)
        )
    );
}
pub const NotificationMessageType_NotificationMessageTypeVibro: NotificationMessageType = 0;
pub const NotificationMessageType_NotificationMessageTypeSoundOn: NotificationMessageType = 1;
pub const NotificationMessageType_NotificationMessageTypeSoundOff: NotificationMessageType = 2;
pub const NotificationMessageType_NotificationMessageTypeLedRed: NotificationMessageType = 3;
pub const NotificationMessageType_NotificationMessageTypeLedGreen: NotificationMessageType = 4;
pub const NotificationMessageType_NotificationMessageTypeLedBlue: NotificationMessageType = 5;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStart: NotificationMessageType = 6;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkStop: NotificationMessageType = 7;
pub const NotificationMessageType_NotificationMessageTypeLedBlinkColor: NotificationMessageType = 8;
pub const NotificationMessageType_NotificationMessageTypeDelay: NotificationMessageType = 9;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklight:
    NotificationMessageType = 10;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceOn:
    NotificationMessageType = 11;
pub const NotificationMessageType_NotificationMessageTypeLedDisplayBacklightEnforceAuto:
    NotificationMessageType = 12;
pub const NotificationMessageType_NotificationMessageTypeDoNotReset: NotificationMessageType = 13;
pub const NotificationMessageType_NotificationMessageTypeForceSpeakerVolumeSetting:
    NotificationMessageType = 14;
pub const NotificationMessageType_NotificationMessageTypeForceVibroSetting:
    NotificationMessageType = 15;
pub const NotificationMessageType_NotificationMessageTypeForceDisplayBrightnessSetting:
    NotificationMessageType = 16;
pub const NotificationMessageType_NotificationMessageTypeLedBrightnessSettingApply:
    NotificationMessageType = 17;
pub const NotificationMessageType_NotificationMessageTypeLcdContrastUpdate:
    NotificationMessageType = 18;
pub type NotificationMessageType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NotificationMessage {
    pub type_: NotificationMessageType,
    pub data: NotificationMessageData,
}
#[test]
fn bindgen_test_layout_NotificationMessage() {
    const UNINIT: ::core::mem::MaybeUninit<NotificationMessage> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotificationMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NotificationMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<NotificationMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(NotificationMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NotificationMessage),
            "::",
            stringify!(data)
        )
    );
}
pub type NotificationSequence = [*const NotificationMessage; 0usize];
extern "C" {
    pub fn notification_message(app: *mut NotificationApp, sequence: *const NotificationSequence);
}
extern "C" {
    pub fn notification_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = "Send internal (apply to permanent layer) notification message. Think twice before use.\n\n# Arguments\n\n* `app` - notification record content\n* `sequence` - notification sequence\n\n"]
    pub fn notification_internal_message(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    #[doc = "Send internal (apply to permanent layer) notification message and wait for notification end. Think twice before use.\n\n# Arguments\n\n* `app` - notification record content\n* `sequence` - notification sequence\n\n"]
    pub fn notification_internal_message_block(
        app: *mut NotificationApp,
        sequence: *const NotificationSequence,
    );
}
extern "C" {
    pub static message_click: NotificationMessage;
}
extern "C" {
    pub static message_note_c0: NotificationMessage;
}
extern "C" {
    pub static message_note_cs0: NotificationMessage;
}
extern "C" {
    pub static message_note_d0: NotificationMessage;
}
extern "C" {
    pub static message_note_ds0: NotificationMessage;
}
extern "C" {
    pub static message_note_e0: NotificationMessage;
}
extern "C" {
    pub static message_note_f0: NotificationMessage;
}
extern "C" {
    pub static message_note_fs0: NotificationMessage;
}
extern "C" {
    pub static message_note_g0: NotificationMessage;
}
extern "C" {
    pub static message_note_gs0: NotificationMessage;
}
extern "C" {
    pub static message_note_a0: NotificationMessage;
}
extern "C" {
    pub static message_note_as0: NotificationMessage;
}
extern "C" {
    pub static message_note_b0: NotificationMessage;
}
extern "C" {
    pub static message_note_c1: NotificationMessage;
}
extern "C" {
    pub static message_note_cs1: NotificationMessage;
}
extern "C" {
    pub static message_note_d1: NotificationMessage;
}
extern "C" {
    pub static message_note_ds1: NotificationMessage;
}
extern "C" {
    pub static message_note_e1: NotificationMessage;
}
extern "C" {
    pub static message_note_f1: NotificationMessage;
}
extern "C" {
    pub static message_note_fs1: NotificationMessage;
}
extern "C" {
    pub static message_note_g1: NotificationMessage;
}
extern "C" {
    pub static message_note_gs1: NotificationMessage;
}
extern "C" {
    pub static message_note_a1: NotificationMessage;
}
extern "C" {
    pub static message_note_as1: NotificationMessage;
}
extern "C" {
    pub static message_note_b1: NotificationMessage;
}
extern "C" {
    pub static message_note_c2: NotificationMessage;
}
extern "C" {
    pub static message_note_cs2: NotificationMessage;
}
extern "C" {
    pub static message_note_d2: NotificationMessage;
}
extern "C" {
    pub static message_note_ds2: NotificationMessage;
}
extern "C" {
    pub static message_note_e2: NotificationMessage;
}
extern "C" {
    pub static message_note_f2: NotificationMessage;
}
extern "C" {
    pub static message_note_fs2: NotificationMessage;
}
extern "C" {
    pub static message_note_g2: NotificationMessage;
}
extern "C" {
    pub static message_note_gs2: NotificationMessage;
}
extern "C" {
    pub static message_note_a2: NotificationMessage;
}
extern "C" {
    pub static message_note_as2: NotificationMessage;
}
extern "C" {
    pub static message_note_b2: NotificationMessage;
}
extern "C" {
    pub static message_note_c3: NotificationMessage;
}
extern "C" {
    pub static message_note_cs3: NotificationMessage;
}
extern "C" {
    pub static message_note_d3: NotificationMessage;
}
extern "C" {
    pub static message_note_ds3: NotificationMessage;
}
extern "C" {
    pub static message_note_e3: NotificationMessage;
}
extern "C" {
    pub static message_note_f3: NotificationMessage;
}
extern "C" {
    pub static message_note_fs3: NotificationMessage;
}
extern "C" {
    pub static message_note_g3: NotificationMessage;
}
extern "C" {
    pub static message_note_gs3: NotificationMessage;
}
extern "C" {
    pub static message_note_a3: NotificationMessage;
}
extern "C" {
    pub static message_note_as3: NotificationMessage;
}
extern "C" {
    pub static message_note_b3: NotificationMessage;
}
extern "C" {
    pub static message_note_c4: NotificationMessage;
}
extern "C" {
    pub static message_note_cs4: NotificationMessage;
}
extern "C" {
    pub static message_note_d4: NotificationMessage;
}
extern "C" {
    pub static message_note_ds4: NotificationMessage;
}
extern "C" {
    pub static message_note_e4: NotificationMessage;
}
extern "C" {
    pub static message_note_f4: NotificationMessage;
}
extern "C" {
    pub static message_note_fs4: NotificationMessage;
}
extern "C" {
    pub static message_note_g4: NotificationMessage;
}
extern "C" {
    pub static message_note_gs4: NotificationMessage;
}
extern "C" {
    pub static message_note_a4: NotificationMessage;
}
extern "C" {
    pub static message_note_as4: NotificationMessage;
}
extern "C" {
    pub static message_note_b4: NotificationMessage;
}
extern "C" {
    pub static message_note_c5: NotificationMessage;
}
extern "C" {
    pub static message_note_cs5: NotificationMessage;
}
extern "C" {
    pub static message_note_d5: NotificationMessage;
}
extern "C" {
    pub static message_note_ds5: NotificationMessage;
}
extern "C" {
    pub static message_note_e5: NotificationMessage;
}
extern "C" {
    pub static message_note_f5: NotificationMessage;
}
extern "C" {
    pub static message_note_fs5: NotificationMessage;
}
extern "C" {
    pub static message_note_g5: NotificationMessage;
}
extern "C" {
    pub static message_note_gs5: NotificationMessage;
}
extern "C" {
    pub static message_note_a5: NotificationMessage;
}
extern "C" {
    pub static message_note_as5: NotificationMessage;
}
extern "C" {
    pub static message_note_b5: NotificationMessage;
}
extern "C" {
    pub static message_note_c6: NotificationMessage;
}
extern "C" {
    pub static message_note_cs6: NotificationMessage;
}
extern "C" {
    pub static message_note_d6: NotificationMessage;
}
extern "C" {
    pub static message_note_ds6: NotificationMessage;
}
extern "C" {
    pub static message_note_e6: NotificationMessage;
}
extern "C" {
    pub static message_note_f6: NotificationMessage;
}
extern "C" {
    pub static message_note_fs6: NotificationMessage;
}
extern "C" {
    pub static message_note_g6: NotificationMessage;
}
extern "C" {
    pub static message_note_gs6: NotificationMessage;
}
extern "C" {
    pub static message_note_a6: NotificationMessage;
}
extern "C" {
    pub static message_note_as6: NotificationMessage;
}
extern "C" {
    pub static message_note_b6: NotificationMessage;
}
extern "C" {
    pub static message_note_c7: NotificationMessage;
}
extern "C" {
    pub static message_note_cs7: NotificationMessage;
}
extern "C" {
    pub static message_note_d7: NotificationMessage;
}
extern "C" {
    pub static message_note_ds7: NotificationMessage;
}
extern "C" {
    pub static message_note_e7: NotificationMessage;
}
extern "C" {
    pub static message_note_f7: NotificationMessage;
}
extern "C" {
    pub static message_note_fs7: NotificationMessage;
}
extern "C" {
    pub static message_note_g7: NotificationMessage;
}
extern "C" {
    pub static message_note_gs7: NotificationMessage;
}
extern "C" {
    pub static message_note_a7: NotificationMessage;
}
extern "C" {
    pub static message_note_as7: NotificationMessage;
}
extern "C" {
    pub static message_note_b7: NotificationMessage;
}
extern "C" {
    pub static message_note_c8: NotificationMessage;
}
extern "C" {
    pub static message_note_cs8: NotificationMessage;
}
extern "C" {
    pub static message_note_d8: NotificationMessage;
}
extern "C" {
    pub static message_note_ds8: NotificationMessage;
}
extern "C" {
    pub static message_note_e8: NotificationMessage;
}
extern "C" {
    pub static message_note_f8: NotificationMessage;
}
extern "C" {
    pub static message_note_fs8: NotificationMessage;
}
extern "C" {
    pub static message_note_g8: NotificationMessage;
}
extern "C" {
    pub static message_note_gs8: NotificationMessage;
}
extern "C" {
    pub static message_note_a8: NotificationMessage;
}
extern "C" {
    pub static message_note_as8: NotificationMessage;
}
extern "C" {
    pub static message_note_b8: NotificationMessage;
}
extern "C" {
    #[doc = "Messages\n\n"]
    pub static message_display_backlight_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_off: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_on: NotificationMessage;
}
extern "C" {
    pub static message_display_backlight_enforce_auto: NotificationMessage;
}
extern "C" {
    pub static message_red_255: NotificationMessage;
}
extern "C" {
    pub static message_green_255: NotificationMessage;
}
extern "C" {
    pub static message_blue_255: NotificationMessage;
}
extern "C" {
    pub static message_red_0: NotificationMessage;
}
extern "C" {
    pub static message_green_0: NotificationMessage;
}
extern "C" {
    pub static message_blue_0: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_10: NotificationMessage;
}
extern "C" {
    pub static message_blink_start_100: NotificationMessage;
}
extern "C" {
    pub static message_blink_stop: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_red: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_green: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_blue: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_cyan: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_magenta: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_yellow: NotificationMessage;
}
extern "C" {
    pub static message_blink_set_color_white: NotificationMessage;
}
extern "C" {
    pub static message_delay_1: NotificationMessage;
}
extern "C" {
    pub static message_delay_10: NotificationMessage;
}
extern "C" {
    pub static message_delay_25: NotificationMessage;
}
extern "C" {
    pub static message_delay_50: NotificationMessage;
}
extern "C" {
    pub static message_delay_100: NotificationMessage;
}
extern "C" {
    pub static message_delay_250: NotificationMessage;
}
extern "C" {
    pub static message_delay_500: NotificationMessage;
}
extern "C" {
    pub static message_delay_1000: NotificationMessage;
}
extern "C" {
    pub static message_sound_off: NotificationMessage;
}
extern "C" {
    pub static message_vibro_on: NotificationMessage;
}
extern "C" {
    pub static message_vibro_off: NotificationMessage;
}
extern "C" {
    pub static message_do_not_reset: NotificationMessage;
}
extern "C" {
    pub static message_force_speaker_volume_setting_1f: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_on: NotificationMessage;
}
extern "C" {
    pub static message_force_vibro_setting_off: NotificationMessage;
}
extern "C" {
    pub static message_force_display_brightness_setting_1f: NotificationMessage;
}
extern "C" {
    pub static message_lcd_contrast_update: NotificationMessage;
}
extern "C" {
    #[doc = "Message sequences\n\n"]
    pub static sequence_reset_red: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_green: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_rgb: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_display: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_sound: NotificationSequence;
}
extern "C" {
    pub static sequence_reset_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_set_vibro_on: NotificationSequence;
}
extern "C" {
    #[doc = "Display: backlight wakeup\n\n"]
    pub static sequence_display_backlight_on: NotificationSequence;
}
extern "C" {
    #[doc = "Display: backlight force off\n\n"]
    pub static sequence_display_backlight_off: NotificationSequence;
}
extern "C" {
    #[doc = "Display: backlight force off after a delay of 1000ms\n\n"]
    pub static sequence_display_backlight_off_delay_1000: NotificationSequence;
}
extern "C" {
    #[doc = "Display: backlight always on lock\n\n"]
    pub static sequence_display_backlight_enforce_on: NotificationSequence;
}
extern "C" {
    #[doc = "Display: backlight always on unlock\n\n"]
    pub static sequence_display_backlight_enforce_auto: NotificationSequence;
}
extern "C" {
    pub static sequence_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_charged: NotificationSequence;
}
extern "C" {
    pub static sequence_not_charging: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_only_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_red_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_green_255: NotificationSequence;
}
extern "C" {
    pub static sequence_set_blue_255: NotificationSequence;
}
extern "C" {
    pub static sequence_solid_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_10: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_red_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_green_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_blue_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_yellow_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_cyan_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_magenta_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_white_100: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_blue: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_red: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_green: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_yellow: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_cyan: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_start_magenta: NotificationSequence;
}
extern "C" {
    pub static sequence_blink_stop: NotificationSequence;
}
extern "C" {
    pub static sequence_single_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_double_vibro: NotificationSequence;
}
extern "C" {
    pub static sequence_success: NotificationSequence;
}
extern "C" {
    pub static sequence_error: NotificationSequence;
}
extern "C" {
    pub static sequence_audiovisual_alert: NotificationSequence;
}
extern "C" {
    pub static sequence_lcd_contrast_update: NotificationSequence;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Power {
    _unused: [u8; 0],
}
pub const PowerBootMode_PowerBootModeNormal: PowerBootMode = 0;
pub const PowerBootMode_PowerBootModeDfu: PowerBootMode = 1;
pub const PowerBootMode_PowerBootModeUpdateStart: PowerBootMode = 2;
pub type PowerBootMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PowerInfo {
    pub gauge_is_ok: bool,
    pub is_charging: bool,
    pub is_shutdown_requested: bool,
    pub current_charger: f32,
    pub current_gauge: f32,
    pub voltage_battery_charge_limit: f32,
    pub voltage_charger: f32,
    pub voltage_gauge: f32,
    pub voltage_vbus: f32,
    pub capacity_remaining: u32,
    pub capacity_full: u32,
    pub temperature_charger: f32,
    pub temperature_gauge: f32,
    pub charge: u8,
    pub health: u8,
    pub is_charge_capped: bool,
}
#[test]
fn bindgen_test_layout_PowerInfo() {
    const UNINIT: ::core::mem::MaybeUninit<PowerInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PowerInfo>(),
        48usize,
        concat!("Size of: ", stringify!(PowerInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PowerInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(PowerInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gauge_is_ok) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(gauge_is_ok)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_charging) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(is_charging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_shutdown_requested) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(is_shutdown_requested)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_charger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_gauge) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(current_gauge)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).voltage_battery_charge_limit) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_battery_charge_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_charger) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_gauge) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).voltage_vbus) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(voltage_vbus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_remaining) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_remaining)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).capacity_full) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(capacity_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_charger) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_charger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temperature_gauge) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(temperature_gauge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charge) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(charge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).health) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(health)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_charge_capped) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(PowerInfo),
            "::",
            stringify!(is_charge_capped)
        )
    );
}
extern "C" {
    #[doc = "Power off device\n\n"]
    pub fn power_off(power: *mut Power);
}
extern "C" {
    #[doc = "Reboot device\n\n# Arguments\n\n* `mode` - PowerBootMode\n\n"]
    pub fn power_reboot(mode: PowerBootMode);
}
extern "C" {
    #[doc = "Get power info\n\n# Arguments\n\n* `power` - Power instance\n* `info` - PowerInfo instance\n\n"]
    pub fn power_get_info(power: *mut Power, info: *mut PowerInfo);
}
extern "C" {
    #[doc = "Get power event pubsub handler\n\nReturns:\n\n* FuriPubSub instance\n\n# Arguments\n\n* `power` - Power instance\n\n"]
    pub fn power_get_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = "Get power settings events pubsub handler\n\nReturns:\n\n* FuriPubSub instance\n\n# Arguments\n\n* `power` - Power instance\n\n"]
    pub fn power_get_settings_events_pubsub(power: *mut Power) -> *mut FuriPubSub;
}
extern "C" {
    #[doc = "Check battery health\n\nReturns:\n\n* true if battery is healthy\n\n"]
    pub fn power_is_battery_healthy(power: *mut Power) -> bool;
}
extern "C" {
    #[doc = "Enable or disable battery low level notification message\n\n# Arguments\n\n* `power` - Power instance\n* `enable` - true - enable, false - disable\n\n"]
    pub fn power_enable_low_battery_level_notification(power: *mut Power, enable: bool);
}
extern "C" {
    #[doc = "Enable or disable battery icon\n\n# Arguments\n\n* `power` - Power instance\n* `is_enabled` - Show battery or not\n\n"]
    pub fn power_set_battery_icon_enabled(power: *mut Power, is_enabled: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rpc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcSession {
    _unused: [u8; 0],
}
#[doc = "Callback to send to client any data (e.g. response to command)\n\n"]
pub type RpcSendBytesCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, bytes: *mut u8, bytes_len: usize),
>;
#[doc = "Callback to notify client that buffer is empty\n\n"]
pub type RpcBufferIsEmptyCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback to notify transport layer that close_session command is received. Any other actions lays on transport layer. No destruction or session close performed.\n\n"]
pub type RpcSessionClosedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback to notify transport layer that session was closed and all operations were finished\n\n"]
pub type RpcSessionTerminatedCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub const RpcOwner_RpcOwnerUnknown: RpcOwner = 0;
pub const RpcOwner_RpcOwnerBle: RpcOwner = 1;
pub const RpcOwner_RpcOwnerUsb: RpcOwner = 2;
pub const RpcOwner_RpcOwnerCount: RpcOwner = 3;
#[doc = "RPC owner\n\n"]
pub type RpcOwner = core::ffi::c_uchar;
extern "C" {
    #[doc = "Get RPC session owner\n\nReturns:\n\n* session owner\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n\n"]
    pub fn rpc_session_get_owner(session: *mut RpcSession) -> RpcOwner;
}
extern "C" {
    #[doc = "Open RPC session\nUSAGE: 1) rpc_session_open(); 2) rpc_session_set_context(); 3) rpc_session_set_send_bytes_callback(); 4) rpc_session_set_close_callback(); 5) while(1) { rpc_session_feed(); } 6) rpc_session_close();\n\nReturns:\n\n* pointer to RpcSession descriptor, or NULL if RPC is busy and can't open session now\n\n# Arguments\n\n* `rpc` - instance\n* `owner` - owner of session\n\n"]
    pub fn rpc_session_open(rpc: *mut Rpc, owner: RpcOwner) -> *mut RpcSession;
}
extern "C" {
    #[doc = "Close RPC session It is guaranteed that no callbacks will be called as soon as session is closed. So no need in setting callbacks to NULL after session close.\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n\n"]
    pub fn rpc_session_close(session: *mut RpcSession);
}
extern "C" {
    #[doc = "Set session context for callbacks to pass\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `context` - context to pass to callbacks\n\n"]
    pub fn rpc_session_set_context(session: *mut RpcSession, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Set callback to send bytes to client WARN: It's forbidden to call RPC API within RpcSendBytesCallback\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `callback` - callback to send bytes to client (can be NULL)\n\n"]
    pub fn rpc_session_set_send_bytes_callback(
        session: *mut RpcSession,
        callback: RpcSendBytesCallback,
    );
}
extern "C" {
    #[doc = "Set callback to notify that buffer is empty\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `callback` - callback to notify client that buffer is empty (can be NULL)\n\n"]
    pub fn rpc_session_set_buffer_is_empty_callback(
        session: *mut RpcSession,
        callback: RpcBufferIsEmptyCallback,
    );
}
extern "C" {
    #[doc = "Set callback to be called when RPC command to close session is received WARN: It's forbidden to call RPC API within RpcSessionClosedCallback\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `callback` - callback to inform about RPC close session command (can be NULL)\n\n"]
    pub fn rpc_session_set_close_callback(
        session: *mut RpcSession,
        callback: RpcSessionClosedCallback,
    );
}
extern "C" {
    #[doc = "Set callback to be called when RPC session is closed\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `callback` - callback to inform about RPC session state\n\n"]
    pub fn rpc_session_set_terminated_callback(
        session: *mut RpcSession,
        callback: RpcSessionTerminatedCallback,
    );
}
extern "C" {
    #[doc = "Give bytes to RPC service to decode them and perform command\n\nReturns:\n\n* actually consumed bytes\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n* `buffer` - buffer to provide to RPC service\n* `size` - size of buffer\n* `timeout` - max timeout to wait till all buffer will be consumed\n\n"]
    pub fn rpc_session_feed(
        session: *mut RpcSession,
        buffer: *mut u8,
        size: usize,
        timeout: u32,
    ) -> usize;
}
extern "C" {
    #[doc = "Get available size of RPC buffer\n\nReturns:\n\n* bytes available in buffer\n\n# Arguments\n\n* `session` - pointer to RpcSession descriptor\n\n"]
    pub fn rpc_session_get_available_size(session: *mut RpcSession) -> usize;
}
#[doc = "No data is provided by the event.\n\n"]
pub const RpcAppSystemEventDataType_RpcAppSystemEventDataTypeNone: RpcAppSystemEventDataType = 0;
#[doc = "Event data contains a zero-terminated string.\n\n"]
pub const RpcAppSystemEventDataType_RpcAppSystemEventDataTypeString: RpcAppSystemEventDataType = 1;
#[doc = "Event data contains a signed 32-bit integer.\n\n"]
pub const RpcAppSystemEventDataType_RpcAppSystemEventDataTypeInt32: RpcAppSystemEventDataType = 2;
#[doc = "Event data contains zero or more bytes.\n\n"]
pub const RpcAppSystemEventDataType_RpcAppSystemEventDataTypeBytes: RpcAppSystemEventDataType = 3;
#[doc = "Enumeration of possible event data types.\n\n"]
pub type RpcAppSystemEventDataType = core::ffi::c_uchar;
#[doc = "Event data structure, containing the type and associated data.\n\nAll below fields except for type are valid only if the respective type is set.\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpcAppSystemEventData {
    #[doc = "Type of the data. The meaning of other fields depends on this one.\n\n"]
    pub type_: RpcAppSystemEventDataType,
    pub __bindgen_anon_1: RpcAppSystemEventData__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RpcAppSystemEventData__bindgen_ty_1 {
    #[doc = "Pointer to a zero-terminated character string.\n\n"]
    pub string: *const core::ffi::c_char,
    #[doc = "Signed 32-bit integer value.\n\n"]
    pub i32_: i32,
    #[doc = "Byte array of arbitrary length.\n\n"]
    pub bytes: RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "Pointer to the byte array data.\n\n"]
    pub ptr: *const u8,
    #[doc = "Size of the byte array, in bytes.\n\n"]
    pub size: usize,
}
#[test]
fn bindgen_test_layout_RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_RpcAppSystemEventData__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<RpcAppSystemEventData__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RpcAppSystemEventData__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RpcAppSystemEventData__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RpcAppSystemEventData__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData__bindgen_ty_1),
            "::",
            stringify!(bytes)
        )
    );
}
#[test]
fn bindgen_test_layout_RpcAppSystemEventData() {
    const UNINIT: ::core::mem::MaybeUninit<RpcAppSystemEventData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RpcAppSystemEventData>(),
        12usize,
        concat!("Size of: ", stringify!(RpcAppSystemEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<RpcAppSystemEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(RpcAppSystemEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEventData),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "Denotes an invalid state.\n\nAn event of this type shall never be passed into the callback.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeInvalid: RpcAppSystemEventType = 0;
#[doc = "The client side has closed the session.\n\nAfter receiving this event, the RPC context is no more valid.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeSessionClose: RpcAppSystemEventType = 1;
#[doc = "The client has requested the application to exit.\n\nThe application must exit after receiving this command.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeAppExit: RpcAppSystemEventType = 2;
#[doc = "The client has requested the application to load a file.\n\nThis command's meaning is application-specific, i.e. the application might or might not require additional commands after loading a file to do anything useful.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeLoadFile: RpcAppSystemEventType = 3;
#[doc = "The client has informed the application that a button has been pressed.\n\nThis command's meaning is application-specific, e.g. to select a part of the previously loaded file or to invoke a particular function within the application.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeButtonPress: RpcAppSystemEventType = 4;
#[doc = "The client has informed the application that a button has been released.\n\nThis command's meaning is application-specific, e.g. to cease all activities to be conducted while a button is being pressed.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeButtonRelease: RpcAppSystemEventType = 5;
#[doc = "The client has sent a byte array of arbitrary size.\n\nThis command's purpose is bi-directional exchange of arbitrary raw data. Useful for implementing higher-level protocols while using the RPC as a transport layer.\n\n"]
pub const RpcAppSystemEventType_RpcAppEventTypeDataExchange: RpcAppSystemEventType = 6;
#[doc = "Enumeration of possible event types.\n\n"]
pub type RpcAppSystemEventType = core::ffi::c_uchar;
#[doc = "RPC application subsystem event structure.\n\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RpcAppSystemEvent {
    #[doc = "Type of the event.\n\n"]
    pub type_: RpcAppSystemEventType,
    #[doc = "Data associated with the event.\n\n"]
    pub data: RpcAppSystemEventData,
}
#[test]
fn bindgen_test_layout_RpcAppSystemEvent() {
    const UNINIT: ::core::mem::MaybeUninit<RpcAppSystemEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RpcAppSystemEvent>(),
        16usize,
        concat!("Size of: ", stringify!(RpcAppSystemEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<RpcAppSystemEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(RpcAppSystemEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RpcAppSystemEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "Callback function type.\n\nA function of this type must be passed to rpc_system_app_set_callback() by the user code.\n\n**Warning!**\n\n* The event pointer is valid ONLY inside the callback function.\n\n# Arguments\n\n* `event` - [Direction: In] pointer to the event object. Valid only inside the callback function.\n* `context` - [Direction: Out] pointer to the user-defined context object.\n\n"]
pub type RpcAppSystemCallback = ::core::option::Option<
    unsafe extern "C" fn(event: *const RpcAppSystemEvent, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RpcAppSystem {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Set the callback function for use by an RpcAppSystem instance.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be configured.\n* `callback` - [Direction: In] pointer to the function to be called upon message reception.\n* `context` - [Direction: Out] pointer to the user-defined context object. Will be passed to the callback.\n\n"]
    pub fn rpc_system_app_set_callback(
        rpc_app: *mut RpcAppSystem,
        callback: RpcAppSystemCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Send a notification that an RpcAppSystem instance has been started and is ready.\n\nCall this function once right after acquiring an RPC context and setting the callback.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be used.\n\n"]
    pub fn rpc_system_app_send_started(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    #[doc = "Send a notification that the application using an RpcAppSystem instance is about to exit.\n\nCall this function when the application is about to exit (usually in the *_free() function).\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be used.\n\n"]
    pub fn rpc_system_app_send_exited(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    #[doc = "Send a confirmation that the application using an RpcAppSystem instance has handled the event.\n\nAn explicit confirmation is required for the following event types:\n* RpcAppEventTypeAppExit\n* RpcAppEventTypeLoadFile\n* RpcAppEventTypeButtonPress\n* RpcAppEventTypeButtonRelease\n* RpcAppEventTypeDataExchange\nNot confirming these events will result in a client-side timeout.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be used.\n* `result` - [Direction: In] whether the command was successfully handled or not (true for success).\n\n"]
    pub fn rpc_system_app_confirm(rpc_app: *mut RpcAppSystem, result: bool);
}
extern "C" {
    #[doc = "Set the error code stored in an RpcAppSystem instance.\n\nThe error code can be retrieved by the client at any time by using the GetError request. The error code value has no meaning within the subsystem, i.e. it is only passed through to the client.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be modified.\n* `error_code` - [Direction: In] arbitrary error code to be set.\n\n"]
    pub fn rpc_system_app_set_error_code(rpc_app: *mut RpcAppSystem, error_code: u32);
}
extern "C" {
    #[doc = "Set the error text stored in an RpcAppSystem instance.\n\nThe error text can be retrieved by the client at any time by using the GetError request. The text has no meaning within the subsystem, i.e. it is only passed through to the client.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be modified.\n* `error_text` - [Direction: In] Pointer to a zero-terminated string containing the error text.\n\n"]
    pub fn rpc_system_app_set_error_text(
        rpc_app: *mut RpcAppSystem,
        error_text: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Reset the error code and text stored in an RpcAppSystem instance.\n\nResets the error code to 0 and error text to \"\" (empty string).\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be reset.\n\n"]
    pub fn rpc_system_app_error_reset(rpc_app: *mut RpcAppSystem);
}
extern "C" {
    #[doc = "Send a byte array of arbitrary data to the client using an RpcAppSystem instance.\n\n# Arguments\n\n* `rpc_app` - [Direction: Out] pointer to the instance to be used.\n* `data` - [Direction: In] pointer to the data buffer to be sent.\n* `data_size` - [Direction: In] size of the data buffer, in bytes.\n\n"]
    pub fn rpc_system_app_exchange_data(
        rpc_app: *mut RpcAppSystem,
        data: *const u8,
        data_size: usize,
    );
}
extern "C" {
    pub static mut I_Certification1_103x56: Icon;
}
extern "C" {
    pub static mut I_Certification2_46x33: Icon;
}
extern "C" {
    pub static mut A_Levelup_128x64: Icon;
}
extern "C" {
    pub static mut I_125_10px: Icon;
}
extern "C" {
    pub static mut I_Apps_10px: Icon;
}
extern "C" {
    pub static mut I_Nfc_10px: Icon;
}
extern "C" {
    pub static mut I_back_10px: Icon;
}
extern "C" {
    pub static mut I_badkb_10px: Icon;
}
extern "C" {
    pub static mut I_dir_10px: Icon;
}
extern "C" {
    pub static mut I_ibutt_10px: Icon;
}
extern "C" {
    pub static mut I_ir_10px: Icon;
}
extern "C" {
    pub static mut I_ir_scope_10px: Icon;
}
extern "C" {
    pub static mut I_keyboard_10px: Icon;
}
extern "C" {
    pub static mut I_loading_10px: Icon;
}
extern "C" {
    pub static mut I_music_10px: Icon;
}
extern "C" {
    pub static mut I_search_10px: Icon;
}
extern "C" {
    pub static mut I_sub1_10px: Icon;
}
extern "C" {
    pub static mut I_subplaylist_10px: Icon;
}
extern "C" {
    pub static mut I_subrem_10px: Icon;
}
extern "C" {
    pub static mut I_u2f_10px: Icon;
}
extern "C" {
    pub static mut I_unknown_10px: Icon;
}
extern "C" {
    pub static mut I_update_10px: Icon;
}
extern "C" {
    pub static mut I_BLE_Pairing_128x64: Icon;
}
extern "C" {
    pub static mut I_Ble_connected_15x15: Icon;
}
extern "C" {
    pub static mut I_Ble_disconnected_15x15: Icon;
}
extern "C" {
    pub static mut I_Button_18x18: Icon;
}
extern "C" {
    pub static mut I_Circles_47x47: Icon;
}
extern "C" {
    pub static mut I_Left_mouse_icon_9x9: Icon;
}
extern "C" {
    pub static mut I_Ok_btn_9x9: Icon;
}
extern "C" {
    pub static mut I_Ok_btn_pressed_13x13: Icon;
}
extern "C" {
    pub static mut I_Pressed_Button_13x13: Icon;
}
extern "C" {
    pub static mut I_Right_mouse_icon_9x9: Icon;
}
extern "C" {
    pub static mut I_Space_65x18: Icon;
}
extern "C" {
    pub static mut I_Voldwn_6x6: Icon;
}
extern "C" {
    pub static mut I_Volup_8x6: Icon;
}
extern "C" {
    pub static mut I_Clock_18x18: Icon;
}
extern "C" {
    pub static mut I_Error_18x18: Icon;
}
extern "C" {
    pub static mut I_EviSmile1_18x21: Icon;
}
extern "C" {
    pub static mut I_EviSmile2_18x21: Icon;
}
extern "C" {
    pub static mut I_EviWaiting1_18x21: Icon;
}
extern "C" {
    pub static mut I_EviWaiting2_18x21: Icon;
}
extern "C" {
    pub static mut I_Percent_10x14: Icon;
}
extern "C" {
    pub static mut I_Smile_18x18: Icon;
}
extern "C" {
    pub static mut I_UsbTree_48x22: Icon;
}
extern "C" {
    pub static mut I_ActiveConnection_50x64: Icon;
}
extern "C" {
    pub static mut I_ButtonCenter_7x7: Icon;
}
extern "C" {
    pub static mut I_ButtonDown_7x4: Icon;
}
extern "C" {
    pub static mut I_ButtonLeftSmall_3x5: Icon;
}
extern "C" {
    pub static mut I_ButtonLeft_4x7: Icon;
}
extern "C" {
    pub static mut I_ButtonRightSmall_3x5: Icon;
}
extern "C" {
    pub static mut I_ButtonRight_4x7: Icon;
}
extern "C" {
    pub static mut I_ButtonUp_7x4: Icon;
}
extern "C" {
    pub static mut I_DFU_128x50: Icon;
}
extern "C" {
    pub static mut I_Hashmark_7x7: Icon;
}
extern "C" {
    pub static mut I_More_data_placeholder_5x7: Icon;
}
extern "C" {
    pub static mut I_Warning_30x23: Icon;
}
extern "C" {
    pub static mut I_arrow_nano_down: Icon;
}
extern "C" {
    pub static mut I_arrow_nano_up: Icon;
}
extern "C" {
    pub static mut A_Loading_24: Icon;
}
extern "C" {
    pub static mut A_Round_loader_8x8: Icon;
}
extern "C" {
    pub static mut I_CC_Bluetooth_16x16: Icon;
}
extern "C" {
    pub static mut I_CC_DarkMode_16x16: Icon;
}
extern "C" {
    pub static mut I_CC_LefthandedMode_16x16: Icon;
}
extern "C" {
    pub static mut I_CC_Lock_16x16: Icon;
}
extern "C" {
    pub static mut I_CC_Settings_16x16: Icon;
}
extern "C" {
    pub static mut I_CC_Xtreme_16x16: Icon;
}
extern "C" {
    pub static mut I_DolphinCommon_56x48: Icon;
}
extern "C" {
    pub static mut I_Erase_pin_128x64: Icon;
}
extern "C" {
    pub static mut I_ArrowUpEmpty_14x15: Icon;
}
extern "C" {
    pub static mut I_ArrowUpFilled_14x15: Icon;
}
extern "C" {
    pub static mut I_DolphinReadingSuccess_59x63: Icon;
}
extern "C" {
    pub static mut I_InfraredArrowDown_4x8: Icon;
}
extern "C" {
    pub static mut I_InfraredArrowUp_4x8: Icon;
}
extern "C" {
    pub static mut I_InfraredLearnShort_128x31: Icon;
}
extern "C" {
    pub static mut I_Play_25x27: Icon;
}
extern "C" {
    pub static mut I_Play_hvr_25x27: Icon;
}
extern "C" {
    pub static mut I_bright_text_30x30: Icon;
}
extern "C" {
    pub static mut I_celsius_24x23: Icon;
}
extern "C" {
    pub static mut I_celsius_hover_24x23: Icon;
}
extern "C" {
    pub static mut I_ch_down_24x21: Icon;
}
extern "C" {
    pub static mut I_ch_down_hover_24x21: Icon;
}
extern "C" {
    pub static mut I_ch_text_31x34: Icon;
}
extern "C" {
    pub static mut I_ch_up_24x21: Icon;
}
extern "C" {
    pub static mut I_ch_up_hover_24x21: Icon;
}
extern "C" {
    pub static mut I_cool_30x51: Icon;
}
extern "C" {
    pub static mut I_dry_19x20: Icon;
}
extern "C" {
    pub static mut I_dry_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_dry_text_15x5: Icon;
}
extern "C" {
    pub static mut I_exit_19x20: Icon;
}
extern "C" {
    pub static mut I_exit_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_exit_text_18x5: Icon;
}
extern "C" {
    pub static mut I_fahren_24x23: Icon;
}
extern "C" {
    pub static mut I_fahren_hover_24x23: Icon;
}
extern "C" {
    pub static mut I_flash_19x20: Icon;
}
extern "C" {
    pub static mut I_flash_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_flash_text_21x5: Icon;
}
extern "C" {
    pub static mut I_heat_30x51: Icon;
}
extern "C" {
    pub static mut I_hourglass0_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass1_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass2_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass3_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass4_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass5_24x24: Icon;
}
extern "C" {
    pub static mut I_hourglass6_24x24: Icon;
}
extern "C" {
    pub static mut I_input_19x20: Icon;
}
extern "C" {
    pub static mut I_input_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_input_text_24x5: Icon;
}
extern "C" {
    pub static mut I_max_24x23: Icon;
}
extern "C" {
    pub static mut I_max_hover_24x23: Icon;
}
extern "C" {
    pub static mut I_menu_text_20x5: Icon;
}
extern "C" {
    pub static mut I_mode_19x20: Icon;
}
extern "C" {
    pub static mut I_mode_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_mode_text_20x5: Icon;
}
extern "C" {
    pub static mut I_mute_19x20: Icon;
}
extern "C" {
    pub static mut I_mute_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_mute_text_19x5: Icon;
}
extern "C" {
    pub static mut I_next_19x20: Icon;
}
extern "C" {
    pub static mut I_next_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_next_text_19x6: Icon;
}
extern "C" {
    pub static mut I_off_19x20: Icon;
}
extern "C" {
    pub static mut I_off_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_off_text_12x5: Icon;
}
extern "C" {
    pub static mut I_pause_19x20: Icon;
}
extern "C" {
    pub static mut I_pause_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_pause_text_23x5: Icon;
}
extern "C" {
    pub static mut I_play_19x20: Icon;
}
extern "C" {
    pub static mut I_play_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_play_text_19x5: Icon;
}
extern "C" {
    pub static mut I_power_19x20: Icon;
}
extern "C" {
    pub static mut I_power_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_power_text_24x5: Icon;
}
extern "C" {
    pub static mut I_prev_19x20: Icon;
}
extern "C" {
    pub static mut I_prev_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_prev_text_19x5: Icon;
}
extern "C" {
    pub static mut I_rotate_19x20: Icon;
}
extern "C" {
    pub static mut I_rotate_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_rotate_text_24x5: Icon;
}
extern "C" {
    pub static mut I_speed_text_30x30: Icon;
}
extern "C" {
    pub static mut I_stop_19x20: Icon;
}
extern "C" {
    pub static mut I_stop_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_stop_text_19x5: Icon;
}
extern "C" {
    pub static mut I_timer_19x20: Icon;
}
extern "C" {
    pub static mut I_timer_hover_19x20: Icon;
}
extern "C" {
    pub static mut I_timer_text_23x5: Icon;
}
extern "C" {
    pub static mut I_vol_ac_text_30x30: Icon;
}
extern "C" {
    pub static mut I_vol_tv_text_29x34: Icon;
}
extern "C" {
    pub static mut I_voldown_24x21: Icon;
}
extern "C" {
    pub static mut I_voldown_hover_24x21: Icon;
}
extern "C" {
    pub static mut I_volup_24x21: Icon;
}
extern "C" {
    pub static mut I_volup_hover_24x21: Icon;
}
extern "C" {
    pub static mut I_Lockscreen: Icon;
}
extern "C" {
    pub static mut I_SmallArrowDown_3x5: Icon;
}
extern "C" {
    pub static mut I_SmallArrowUp_3x5: Icon;
}
extern "C" {
    pub static mut I_WarningDolphin_45x42: Icon;
}
extern "C" {
    pub static mut I_KeyBackspaceSelected_17x11: Icon;
}
extern "C" {
    pub static mut I_KeyBackspace_17x11: Icon;
}
extern "C" {
    pub static mut I_KeyKeyboardSelected_10x11: Icon;
}
extern "C" {
    pub static mut I_KeyKeyboard_10x11: Icon;
}
extern "C" {
    pub static mut I_KeySaveSelected_22x11: Icon;
}
extern "C" {
    pub static mut I_KeySave_22x11: Icon;
}
extern "C" {
    pub static mut A_125khz_14: Icon;
}
extern "C" {
    pub static mut A_BadKb_14: Icon;
}
extern "C" {
    pub static mut A_GPIO_14: Icon;
}
extern "C" {
    pub static mut A_Infrared_14: Icon;
}
extern "C" {
    pub static mut A_NFC_14: Icon;
}
extern "C" {
    pub static mut A_Plugins_14: Icon;
}
extern "C" {
    pub static mut A_Settings_14: Icon;
}
extern "C" {
    pub static mut A_Sub1ghz_14: Icon;
}
extern "C" {
    pub static mut A_U2F_14: Icon;
}
extern "C" {
    pub static mut A_Xtreme_14: Icon;
}
extern "C" {
    pub static mut A_iButton_14: Icon;
}
extern "C" {
    pub static mut I_ArrowC_1_36x36: Icon;
}
extern "C" {
    pub static mut I_Keychain_39x36: Icon;
}
extern "C" {
    pub static mut I_Modern_reader_18x34: Icon;
}
extern "C" {
    pub static mut I_Move_flipper_26x39: Icon;
}
extern "C" {
    pub static mut I_NFC_dolphin_emulation_47x61: Icon;
}
extern "C" {
    pub static mut I_NFC_manual_60x50: Icon;
}
extern "C" {
    pub static mut I_Release_arrow_18x15: Icon;
}
extern "C" {
    pub static mut I_Pin_arrow_up_7x9: Icon;
}
extern "C" {
    pub static mut I_Pin_attention_dpad_29x29: Icon;
}
extern "C" {
    pub static mut I_Pin_back_arrow_10x8: Icon;
}
extern "C" {
    pub static mut I_Pin_cell_13x13: Icon;
}
extern "C" {
    pub static mut I_Pin_pointer_5x3: Icon;
}
extern "C" {
    pub static mut I_Pin_star_7x7: Icon;
}
extern "C" {
    pub static mut I_passport_DB: Icon;
}
extern "C" {
    pub static mut I_passport_bad_46x49: Icon;
}
extern "C" {
    pub static mut I_passport_happy_46x49: Icon;
}
extern "C" {
    pub static mut I_passport_okay_46x49: Icon;
}
extern "C" {
    pub static mut I_BatteryBody_52x28: Icon;
}
extern "C" {
    pub static mut I_Battery_16x16: Icon;
}
extern "C" {
    pub static mut I_FaceCharging_29x14: Icon;
}
extern "C" {
    pub static mut I_FaceConfused_29x14: Icon;
}
extern "C" {
    pub static mut I_FaceNopower_29x14: Icon;
}
extern "C" {
    pub static mut I_FaceNormal_29x14: Icon;
}
extern "C" {
    pub static mut I_Health_16x16: Icon;
}
extern "C" {
    pub static mut I_Temperature_16x16: Icon;
}
extern "C" {
    pub static mut I_Unplug_bg_bottom_128x10: Icon;
}
extern "C" {
    pub static mut I_Unplug_bg_top_128x14: Icon;
}
extern "C" {
    pub static mut I_Voltage_16x16: Icon;
}
extern "C" {
    pub static mut I_RFIDDolphinReceive_97x61: Icon;
}
extern "C" {
    pub static mut I_RFIDDolphinSend_97x61: Icon;
}
extern "C" {
    pub static mut I_RFIDDolphinSuccess_108x57: Icon;
}
extern "C" {
    pub static mut I_RFIDSmallChip_14x14: Icon;
}
extern "C" {
    pub static mut I_SDQuestion_35x43: Icon;
}
extern "C" {
    pub static mut I_Cry_dolph_55x52: Icon;
}
extern "C" {
    pub static mut I_Background_128x11: Icon;
}
extern "C" {
    pub static mut I_Battery_25x8: Icon;
}
extern "C" {
    pub static mut I_Bluetooth_Connected_16x8: Icon;
}
extern "C" {
    pub static mut I_Bluetooth_Idle_5x8: Icon;
}
extern "C" {
    pub static mut I_Charging_lightning_9x10: Icon;
}
extern "C" {
    pub static mut I_Charging_lightning_mask_9x10: Icon;
}
extern "C" {
    pub static mut I_Hidden_window_9x8: Icon;
}
extern "C" {
    pub static mut I_Muted_8x8: Icon;
}
extern "C" {
    pub static mut I_Rpc_active_7x8: Icon;
}
extern "C" {
    pub static mut I_SDcardFail_11x8: Icon;
}
extern "C" {
    pub static mut I_SDcardMounted_11x8: Icon;
}
extern "C" {
    pub static mut I_Cos_9x7: Icon;
}
extern "C" {
    pub static mut I_Dynamic_9x7: Icon;
}
extern "C" {
    pub static mut I_Fishing_123x52: Icon;
}
extern "C" {
    pub static mut I_Lock_7x8: Icon;
}
extern "C" {
    pub static mut I_MHz_25x11: Icon;
}
extern "C" {
    pub static mut I_Quest_7x8: Icon;
}
extern "C" {
    pub static mut I_Raw_9x7: Icon;
}
extern "C" {
    pub static mut I_Scanning_123x52: Icon;
}
extern "C" {
    pub static mut I_Static_9x7: Icon;
}
extern "C" {
    pub static mut I_Unlock_7x8: Icon;
}
extern "C" {
    pub static mut I_Auth_62x31: Icon;
}
extern "C" {
    pub static mut I_Connect_me_62x31: Icon;
}
extern "C" {
    pub static mut I_Connected_62x31: Icon;
}
extern "C" {
    pub static mut I_Drive_112x35: Icon;
}
extern "C" {
    pub static mut I_Error_62x31: Icon;
}
extern "C" {
    pub static mut I_Updating_32x40: Icon;
}
extern "C" {
    pub static mut I_DolphinMafia_115x62: Icon;
}
extern "C" {
    pub static mut I_DolphinNice_96x59: Icon;
}
extern "C" {
    pub static mut I_DolphinWait_61x59: Icon;
}
extern "C" {
    pub static mut I_iButtonDolphinVerySuccess_108x52: Icon;
}
extern "C" {
    pub static mut I_iButtonKey_49x44: Icon;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IconPath {
    pub animated: bool,
    pub icon: *const Icon,
    pub path: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_IconPath() {
    const UNINIT: ::core::mem::MaybeUninit<IconPath> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IconPath>(),
        12usize,
        concat!("Size of: ", stringify!(IconPath))
    );
    assert_eq!(
        ::core::mem::align_of::<IconPath>(),
        4usize,
        concat!("Alignment of ", stringify!(IconPath))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).animated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IconPath),
            "::",
            stringify!(animated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IconPath),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IconPath),
            "::",
            stringify!(path)
        )
    );
}
extern "C" {
    pub static ICON_PATHS: [IconPath; 0usize];
}
extern "C" {
    pub static ICON_PATHS_COUNT: usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSignal {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Append one period to the end of the DigitalSignal instance.\n\n# Arguments\n\n* `signal` - [Direction: Out] pointer to a the instance to append to.\n* `ticks` - [Direction: In] the period length, in 10 picosecond units.\n\n"]
    pub fn digital_signal_add_period(signal: *mut DigitalSignal, ticks: u32);
}
extern "C" {
    #[doc = "Append one period to the end of the DigitalSignal instance, with the level specified.\n\nIf the level is the same as the last level contained in the instance, then it is extened by the given ticks value. Otherwise, the behaviour is identical to digital_signal_add_period().\nExample 1: add tc with HIGH level ``` before: ... ------+ ta  |  tb after: ... ------+      +------- ta  |  tb  |  tc ``` Example 2: add tc with LOW level ``` before: ... ------+ ta  |  tb after: ... ------+ ta  |   tb + tc ```\n* \n  * -------\n  * ------+\n  * -------\n  * --------------\n\n# Arguments\n\n* `signal` - [Direction: Out] pointer to the instance to append to.\n* `ticks` - [Direction: In] the period length, in 10 picosecond units.\n* `level` - [Direction: In] the level to be set during the period.\n\n"]
    pub fn digital_signal_add_period_with_level(
        signal: *mut DigitalSignal,
        ticks: u32,
        level: bool,
    );
}
extern "C" {
    #[doc = "Get the current start level contained in the DigitalSignal instance.\n\nIf not explicitly set with digital_signal_set_start_level(), it defaults to false.\n\nReturns:\n\n* the start level value.\n\n# Arguments\n\n* `signal` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn digital_signal_get_start_level(signal: *const DigitalSignal) -> bool;
}
extern "C" {
    #[doc = "Set the start level contained in the DigitalSignal instance.\n\n# Arguments\n\n* `signal` - [Direction: Out] pointer to the instance to be modified.\n* `level` - [Direction: In] signal level to be set as the start level.\n\n"]
    pub fn digital_signal_set_start_level(signal: *mut DigitalSignal, level: bool);
}
extern "C" {
    #[doc = "Get the number of periods currently stored in a DigitalSignal instance.\n\nReturns:\n\n* the number of periods stored in the instance.\n\n# Arguments\n\n* `signal` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn digital_signal_get_size(signal: *const DigitalSignal) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DigitalSequence {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Register a signal within a DigitalSequence instance by its index.\n\nThis function must be called for each signal to be used in the sequence. The DigitalSequence instance does not own the signals, therefore, their lifetime must be no less than the instance's.\nThe user is responsible for creation and deletion of DigitalSignal instances and also for keeping track of their respective indices.\n\n# Arguments\n\n* `sequence` - [Direction: Out] pointer to the instance to be modified.\n* `signal_index` - [Direction: In] index to register the signal under (must be less than 32).\n* `signal` - [Direction: In] pointer to the DigitalSignal instance to be registered.\n\n"]
    pub fn digital_sequence_register_signal(
        sequence: *mut DigitalSequence,
        signal_index: u8,
        signal: *const DigitalSignal,
    );
}
extern "C" {
    #[doc = "Append a signal index to a DigitalSequence instance.\n\nThe signal under the index must be registered beforehand by calling digital_sequence_set_signal().\n\n# Arguments\n\n* `sequence` - [Direction: Out] pointer to the instance to be modified.\n* `signal_index` - [Direction: In] signal index to be appended to the sequence (must be less than 32).\n\n"]
    pub fn digital_sequence_add_signal(sequence: *mut DigitalSequence, signal_index: u8);
}
extern "C" {
    #[doc = "Transmit the sequence contained in the DigitalSequence instance.\n\nMust contain at least one registered signal and one signal index.\nNOTE: The current implementation will properly initialise the GPIO provided during construction, but it is the caller's responsibility to reconfigure it back before reusing for other purposes. This is due to performance reasons.\n\n# Arguments\n\n* `sequence` - [Direction: In] pointer to the sequence to be transmitted.\n\n"]
    pub fn digital_sequence_transmit(sequence: *mut DigitalSequence);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RgbColor {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
#[test]
fn bindgen_test_layout_RgbColor() {
    const UNINIT: ::core::mem::MaybeUninit<RgbColor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RgbColor>(),
        3usize,
        concat!("Size of: ", stringify!(RgbColor))
    );
    assert_eq!(
        ::core::mem::align_of::<RgbColor>(),
        1usize,
        concat!("Alignment of ", stringify!(RgbColor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RgbColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RgbColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RgbColor),
            "::",
            stringify!(b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HsvColor {
    pub h: u8,
    pub s: u8,
    pub v: u8,
}
#[test]
fn bindgen_test_layout_HsvColor() {
    const UNINIT: ::core::mem::MaybeUninit<HsvColor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HsvColor>(),
        3usize,
        concat!("Size of: ", stringify!(HsvColor))
    );
    assert_eq!(
        ::core::mem::align_of::<HsvColor>(),
        1usize,
        concat!("Alignment of ", stringify!(HsvColor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HsvColor),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HsvColor),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HsvColor),
            "::",
            stringify!(v)
        )
    );
}
extern "C" {
    pub fn rgbcmp(a: *const RgbColor, b: *const RgbColor) -> core::ffi::c_int;
}
extern "C" {
    pub fn hsvcmp(a: *const HsvColor, b: *const HsvColor) -> core::ffi::c_int;
}
extern "C" {
    pub fn hsv2rgb(hsv: *const HsvColor, rgb: *mut RgbColor);
}
extern "C" {
    pub fn rgb2hsv(rgb: *const RgbColor, hsv: *mut HsvColor);
}
pub const RGBBacklightRainbowMode_RGBBacklightRainbowModeOff: RGBBacklightRainbowMode = 0;
pub const RGBBacklightRainbowMode_RGBBacklightRainbowModeWave: RGBBacklightRainbowMode = 1;
pub const RGBBacklightRainbowMode_RGBBacklightRainbowModeSolid: RGBBacklightRainbowMode = 2;
pub const RGBBacklightRainbowMode_RGBBacklightRainbowModeCount: RGBBacklightRainbowMode = 3;
pub type RGBBacklightRainbowMode = core::ffi::c_uchar;
extern "C" {
    #[doc = "Save Current RGB Lighting Settings\n\n"]
    pub fn rgb_backlight_save_settings();
}
extern "C" {
    #[doc = "Change the color of the backlight\n\n# Arguments\n\n* `index` - What led to set the color to (0 - SK6805_LED_COUNT-1)\n* `color` - RGB color to use\n\n"]
    pub fn rgb_backlight_set_color(index: u8, color: *const RgbColor);
}
extern "C" {
    pub fn rgb_backlight_get_color(index: u8, color: *mut RgbColor);
}
extern "C" {
    #[doc = "Change rainbow mode\n\n# Arguments\n\n* `rainbow_mode` - What mode to use (0 - RGBBacklightRainbowModeCount)\n\n"]
    pub fn rgb_backlight_set_rainbow_mode(rainbow_mode: RGBBacklightRainbowMode);
}
extern "C" {
    pub fn rgb_backlight_get_rainbow_mode() -> RGBBacklightRainbowMode;
}
extern "C" {
    #[doc = "Change rainbow speed\n\n# Arguments\n\n* `rainbow_speed` - What speed to use (0 - 255)\n\n"]
    pub fn rgb_backlight_set_rainbow_speed(rainbow_speed: u8);
}
extern "C" {
    pub fn rgb_backlight_get_rainbow_speed() -> u8;
}
extern "C" {
    #[doc = "Change rainbow interval\n\n# Arguments\n\n* `rainbow_interval` - What interval to use\n\n"]
    pub fn rgb_backlight_set_rainbow_interval(rainbow_interval: u32);
}
extern "C" {
    pub fn rgb_backlight_get_rainbow_interval() -> u32;
}
extern "C" {
    #[doc = "Change rainbow saturation\n\n# Arguments\n\n* `rainbow_saturation` - What saturation to use (0 - 255)\n\n"]
    pub fn rgb_backlight_set_rainbow_saturation(rainbow_saturation: u8);
}
extern "C" {
    pub fn rgb_backlight_get_rainbow_saturation() -> u8;
}
extern "C" {
    #[doc = "Reconfigure rgb backlight with new settings\n\n# Arguments\n\n* `enabled` - Whether the rgb backlight is enabled\n\n"]
    pub fn rgb_backlight_reconfigure(enabled: bool);
}
extern "C" {
    #[doc = "Resolver for API entries using a pre-sorted table with hashes\n\nReturns:\n\n* true if the table contains a function\n\n# Arguments\n\n* `interface` - pointer to HashtableApiInterface\n* `hash` - gnu hash of function name\n* `address` - output for function address\n\n"]
    pub fn elf_resolve_from_hashtable(
        interface: *const ElfApiInterface,
        hash: u32,
        address: *mut Elf32_Addr,
    ) -> bool;
}
extern "C" {
    pub fn elf_symbolname_hash(s: *const core::ffi::c_char) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompositeApiResolver {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate composite API resolver\n\nReturns:\n\n* CompositeApiResolver* instance\n\n"]
    pub fn composite_api_resolver_alloc() -> *mut CompositeApiResolver;
}
extern "C" {
    #[doc = "Free composite API resolver\n\n# Arguments\n\n* `resolver` - Instance\n\n"]
    pub fn composite_api_resolver_free(resolver: *mut CompositeApiResolver);
}
extern "C" {
    #[doc = "Add API resolver to composite resolver\n\n# Arguments\n\n* `resolver` - Instance\n* `interface` - API resolver\n\n"]
    pub fn composite_api_resolver_add(
        resolver: *mut CompositeApiResolver,
        interface: *const ElfApiInterface,
    );
}
extern "C" {
    #[doc = "Get API interface from composite resolver\n\nReturns:\n\n* API interface\n\n# Arguments\n\n* `resolver` - Instance\n\n"]
    pub fn composite_api_resolver_get(
        resolver: *mut CompositeApiResolver,
    ) -> *const ElfApiInterface;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PluginManager {
    _unused: [u8; 0],
}
pub const PluginManagerError_PluginManagerErrorNone: PluginManagerError = 0;
pub const PluginManagerError_PluginManagerErrorLoaderError: PluginManagerError = 1;
pub const PluginManagerError_PluginManagerErrorApplicationIdMismatch: PluginManagerError = 2;
pub const PluginManagerError_PluginManagerErrorAPIVersionMismatch: PluginManagerError = 3;
pub type PluginManagerError = core::ffi::c_uchar;
extern "C" {
    #[doc = "Allocates new PluginManager\n\nReturns:\n\n* new PluginManager instance\n\n# Arguments\n\n* `application_id` - Application ID filter - only plugins with matching ID will be loaded\n* `api_version` - Application API version filter - only plugins with matching API version\n* `api_interface` - Application API interface - used to resolve plugins' API imports If plugin uses private application's API, use CompoundApiInterface\n\n"]
    pub fn plugin_manager_alloc(
        application_id: *const core::ffi::c_char,
        api_version: u32,
        api_interface: *const ElfApiInterface,
    ) -> *mut PluginManager;
}
extern "C" {
    #[doc = "Frees PluginManager\n\n# Arguments\n\n* `manager` - PluginManager instance\n\n"]
    pub fn plugin_manager_free(manager: *mut PluginManager);
}
extern "C" {
    #[doc = "Loads single plugin by full path\n\nReturns:\n\n* Error code\n\n# Arguments\n\n* `manager` - PluginManager instance\n* `path` - Path to plugin\n\n"]
    pub fn plugin_manager_load_single(
        manager: *mut PluginManager,
        path: *const core::ffi::c_char,
    ) -> PluginManagerError;
}
extern "C" {
    #[doc = "Loads all plugins from specified directory\n\nReturns:\n\n* Error code\n\n# Arguments\n\n* `manager` - PluginManager instance\n* `path` - Path to directory\n\n"]
    pub fn plugin_manager_load_all(
        manager: *mut PluginManager,
        path: *const core::ffi::c_char,
    ) -> PluginManagerError;
}
extern "C" {
    #[doc = "Returns number of loaded plugins\n\nReturns:\n\n* Number of loaded plugins\n\n# Arguments\n\n* `manager` - PluginManager instance\n\n"]
    pub fn plugin_manager_get_count(manager: *mut PluginManager) -> u32;
}
extern "C" {
    #[doc = "Returns plugin descriptor by index\n\nReturns:\n\n* Plugin descriptor\n\n# Arguments\n\n* `manager` - PluginManager instance\n* `index` - Plugin index\n\n"]
    pub fn plugin_manager_get(
        manager: *mut PluginManager,
        index: u32,
    ) -> *const FlipperAppPluginDescriptor;
}
extern "C" {
    #[doc = "Returns plugin entry point by index\n\nReturns:\n\n* Plugin entry point\n\n# Arguments\n\n* `manager` - PluginManager instance\n* `index` - Plugin index\n\n"]
    pub fn plugin_manager_get_ep(
        manager: *mut PluginManager,
        index: u32,
    ) -> *const core::ffi::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperFormat {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate FlipperFormat as string.\n\nReturns:\n\n* FlipperFormat* pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_string_alloc() -> *mut FlipperFormat;
}
extern "C" {
    #[doc = "Allocate FlipperFormat as file.\n\nReturns:\n\n* FlipperFormat* pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = "Allocate FlipperFormat as file, buffered mode.\n\nReturns:\n\n* FlipperFormat* pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_buffered_file_alloc(storage: *mut Storage) -> *mut FlipperFormat;
}
extern "C" {
    #[doc = "Open existing file. Use only if FlipperFormat allocated as a file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open existing file, buffered mode. Use only if FlipperFormat allocated as a buffered file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_buffered_file_open_existing(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open existing file for writing and add values to the end of file. Use only if FlipperFormat allocated as a file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_file_open_append(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open file. Creates a new file, or deletes the contents of the file if it already exists. Use only if FlipperFormat allocated as a file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open file. Creates a new file, or deletes the contents of the file if it already exists, buffered mode. Use only if FlipperFormat allocated as a buffered file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_buffered_file_open_always(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open file. Creates a new file, fails if file already exists. Use only if FlipperFormat allocated as a file.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `path` - File path\n\n"]
    pub fn flipper_format_file_open_new(
        flipper_format: *mut FlipperFormat,
        path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Closes the file, use only if FlipperFormat allocated as a file.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `flipper_format` - \n\n"]
    pub fn flipper_format_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = "Closes the file, use only if FlipperFormat allocated as a buffered file.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `flipper_format` - \n\n"]
    pub fn flipper_format_buffered_file_close(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = "Free FlipperFormat.\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_free(flipper_format: *mut FlipperFormat);
}
extern "C" {
    #[doc = "Set FlipperFormat mode.\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `strict_mode` - True obligates not to skip valid fields. False by default.\n\n"]
    pub fn flipper_format_set_strict_mode(flipper_format: *mut FlipperFormat, strict_mode: bool);
}
extern "C" {
    #[doc = "Rewind the RW pointer.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_rewind(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = "Move the RW pointer at the end. Can be useful if you want to add some data after reading.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn flipper_format_seek_to_end(flipper_format: *mut FlipperFormat) -> bool;
}
extern "C" {
    #[doc = "Check if the key exists.\n\nReturns:\n\n* true key exists\n* false key is not exists\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n\n"]
    pub fn flipper_format_key_exist(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Read the header (file type and version).\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `filetype` - File type string\n* `version` - Version Value\n\n"]
    pub fn flipper_format_read_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Write the header (file type and version).\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `filetype` - File type string\n* `version` - Version Value\n\n"]
    pub fn flipper_format_write_header(
        flipper_format: *mut FlipperFormat,
        filetype: *mut FuriString,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Write the header (file type and version). Plain C string version.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `filetype` - File type string\n* `version` - Version Value\n\n"]
    pub fn flipper_format_write_header_cstr(
        flipper_format: *mut FlipperFormat,
        filetype: *const core::ffi::c_char,
        version: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Get the count of values by key\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - \n* `count` - \n\n"]
    pub fn flipper_format_get_value_count(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        count: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Read a string by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_read_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and string\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_write_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and string. Plain C string version.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_write_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of uint64 in hex format by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of uint64 in hex format\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_hex_uint64(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u64,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of uint32 by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of uint32\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of int32 by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of int32\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of bool by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of bool\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of float by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of float\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Read array of hex-formatted bytes by key\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_read_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write key and array of hex-formatted bytes\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n* `data_size` - Values count\n\n"]
    pub fn flipper_format_write_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Write comment\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `data` - Comment text\n\n"]
    pub fn flipper_format_write_comment(
        flipper_format: *mut FlipperFormat,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Write comment. Plain C string version.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `data` - Comment text\n\n"]
    pub fn flipper_format_write_comment_cstr(
        flipper_format: *mut FlipperFormat,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Removes the first matching key and its value. Sets the RW pointer to a position of deleted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n\n"]
    pub fn flipper_format_delete_key(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a string value. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a string value. Plain C version. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a uint32 array value. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a int32 array value. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a bool array value. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a float array value. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to an array of hex-formatted bytes. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_string(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a string value, or adds the key and value if the key did not exist. Plain C version. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_string_cstr(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a uint32 array value, or adds the key and value if the key did not exist. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_uint32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a int32 array value, or adds the key and value if the key did not exist. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_int32(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const i32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a bool array value, or adds the key and value if the key did not exist. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_bool(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const bool,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to a float array value, or adds the key and value if the key did not exist. Sets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_float(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const f32,
        data_size: u16,
    ) -> bool;
}
extern "C" {
    #[doc = "Updates the value of the first matching key to an array of hex-formatted bytes, or adds the key and value if the key did not exist.\nSets the RW pointer to a position at the end of inserted data.\n\nReturns:\n\n* True on success\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `key` - Key\n* `data` - Value\n\n"]
    pub fn flipper_format_insert_or_update_hex(
        flipper_format: *mut FlipperFormat,
        key: *const core::ffi::c_char,
        data: *const u8,
        data_size: u16,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Stream {
    _unused: [u8; 0],
}
pub const StreamOffset_StreamOffsetFromCurrent: StreamOffset = 0;
pub const StreamOffset_StreamOffsetFromStart: StreamOffset = 1;
pub const StreamOffset_StreamOffsetFromEnd: StreamOffset = 2;
pub type StreamOffset = core::ffi::c_uchar;
pub const StreamDirection_StreamDirectionForward: StreamDirection = 0;
pub const StreamDirection_StreamDirectionBackward: StreamDirection = 1;
pub type StreamDirection = core::ffi::c_uchar;
pub type StreamWriteCB = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut Stream, context: *const core::ffi::c_void) -> bool,
>;
extern "C" {
    #[doc = "Free Stream\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_free(stream: *mut Stream);
}
extern "C" {
    #[doc = "Clean (empty) Stream\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_clean(stream: *mut Stream);
}
extern "C" {
    #[doc = "Indicates that the RW pointer is at the end of the stream\n\nReturns:\n\n* true if RW pointer is at the end of the stream\n* false if RW pointer is not at the end of the stream\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_eof(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = "Moves the RW pointer.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - Stream instance\n* `offset` - how much to move the pointer\n* `offset_type` - starting from what\n\n"]
    pub fn stream_seek(stream: *mut Stream, offset: i32, offset_type: StreamOffset) -> bool;
}
extern "C" {
    #[doc = "Seek to next occurrence of the character\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `stream` - Pointer to the stream instance\n* `c` - [Direction: In] The Character\n* `direction` - [Direction: In] The Direction\n\n"]
    pub fn stream_seek_to_char(
        stream: *mut Stream,
        c: core::ffi::c_char,
        direction: StreamDirection,
    ) -> bool;
}
extern "C" {
    #[doc = "Gets the value of the RW pointer\n\nReturns:\n\n* size_t value of the RW pointer\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_tell(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = "Gets the size of the stream\n\nReturns:\n\n* size_t size of the stream\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_size(stream: *mut Stream) -> usize;
}
extern "C" {
    #[doc = "Write N bytes to the stream\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `data` - data to write\n* `size` - size of data to be written\n\n"]
    pub fn stream_write(stream: *mut Stream, data: *const u8, size: usize) -> usize;
}
extern "C" {
    #[doc = "Read N bytes from stream\n\nReturns:\n\n* size_t how many bytes was read\n\n# Arguments\n\n* `stream` - Stream instance\n* `data` - data to be read\n* `count` - size of data to be read\n\n"]
    pub fn stream_read(stream: *mut Stream, data: *mut u8, count: usize) -> usize;
}
extern "C" {
    #[doc = "Delete N chars from the stream and write data by calling write_callback(context)\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `write_callback` - write callback\n* `context` - write callback context\n\n"]
    pub fn stream_delete_and_insert(
        stream: *mut Stream,
        delete_size: usize,
        write_callback: StreamWriteCB,
        context: *const core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Read line from a stream (supports LF and CRLF line endings)\n\nReturns:\n\n* true if line length is not zero\n* false otherwise\n\n# Arguments\n\n* `stream` - \n* `str_result` - \n\n"]
    pub fn stream_read_line(stream: *mut Stream, str_result: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = "Moves the RW pointer to the start\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_rewind(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = "Write char to the stream\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `c` - char value\n\n"]
    pub fn stream_write_char(stream: *mut Stream, c: core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = "Write string to the stream\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `string` - string value\n\n"]
    pub fn stream_write_string(stream: *mut Stream, string: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = "Write const char* to the stream\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `string` - c-string value\n\n"]
    pub fn stream_write_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> usize;
}
extern "C" {
    #[doc = "Write formatted string to the stream\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `format` - \n* `...` - \n\n"]
    pub fn stream_write_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> usize;
}
extern "C" {
    #[doc = "Write formatted string to the stream, va_list version\n\nReturns:\n\n* size_t how many bytes was written\n\n# Arguments\n\n* `stream` - Stream instance\n* `format` - \n* `args` - \n\n"]
    pub fn stream_write_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> usize;
}
extern "C" {
    #[doc = "Insert N chars to the stream, starting at the current pointer. Data will be inserted, not overwritten, so the stream will be increased in size.\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `data` - data to be inserted\n* `size` - size of data to be inserted\n\n"]
    pub fn stream_insert(stream: *mut Stream, data: *const u8, size: usize) -> bool;
}
extern "C" {
    #[doc = "Insert char to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `c` - char value\n\n"]
    pub fn stream_insert_char(stream: *mut Stream, c: core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Insert string to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `string` - string value\n\n"]
    pub fn stream_insert_string(stream: *mut Stream, string: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = "Insert const char* to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `string` - c-string value\n\n"]
    pub fn stream_insert_cstring(stream: *mut Stream, string: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Insert formatted string to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `format` - \n* `...` - \n\n"]
    pub fn stream_insert_format(stream: *mut Stream, format: *const core::ffi::c_char, ...)
        -> bool;
}
extern "C" {
    #[doc = "Insert formatted string to the stream, va_list version\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `format` - \n* `args` - \n\n"]
    pub fn stream_insert_vaformat(
        stream: *mut Stream,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = "Delete N chars from the stream and insert char to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `c` - char value\n\n"]
    pub fn stream_delete_and_insert_char(
        stream: *mut Stream,
        delete_size: usize,
        c: core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Delete N chars from the stream and insert string to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `string` - string value\n\n"]
    pub fn stream_delete_and_insert_string(
        stream: *mut Stream,
        delete_size: usize,
        string: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Delete N chars from the stream and insert const char* to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `string` - c-string value\n\n"]
    pub fn stream_delete_and_insert_cstring(
        stream: *mut Stream,
        delete_size: usize,
        string: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Delete N chars from the stream and insert formatted string to the stream\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `format` - \n* `...` - \n\n"]
    pub fn stream_delete_and_insert_format(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> bool;
}
extern "C" {
    #[doc = "Delete N chars from the stream and insert formatted string to the stream, va_list version\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `delete_size` - size of data to be deleted\n* `format` - \n* `args` - \n\n"]
    pub fn stream_delete_and_insert_vaformat(
        stream: *mut Stream,
        delete_size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> bool;
}
extern "C" {
    #[doc = "Remove N chars from the stream, starting at the current pointer. The size may be larger than stream size, the stream will be cleared from current RW pointer to the end.\n\nReturns:\n\n* true if the operation was successful\n* false on error\n\n# Arguments\n\n* `stream` - Stream instance\n* `size` - how many chars need to be deleted\n\n"]
    pub fn stream_delete(stream: *mut Stream, size: usize) -> bool;
}
extern "C" {
    #[doc = "Copy data from one stream to another. Data will be copied from current RW pointer and to current RW pointer.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `stream_from` - \n* `stream_to` - \n* `size` - \n\n"]
    pub fn stream_copy(stream_from: *mut Stream, stream_to: *mut Stream, size: usize) -> usize;
}
extern "C" {
    #[doc = "Copy data from one stream to another. Data will be copied from start of one stream and to start of other stream.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `stream_from` - \n* `stream_to` - \n\n"]
    pub fn stream_copy_full(stream_from: *mut Stream, stream_to: *mut Stream) -> usize;
}
extern "C" {
    #[doc = "Splits one stream into two others. The original stream will remain untouched.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `stream_left` - \n* `stream_right` - \n\n"]
    pub fn stream_split(
        stream: *mut Stream,
        stream_left: *mut Stream,
        stream_right: *mut Stream,
    ) -> bool;
}
extern "C" {
    #[doc = "Loads data to the stream from a file. Data will be loaded to the current RW pointer. RW pointer will be moved to the end of the stream.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `stream` - Stream instance\n* `storage` - \n* `path` - \n\n"]
    pub fn stream_load_from_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
    ) -> usize;
}
extern "C" {
    #[doc = "Writes data from a stream to a file. Data will be saved starting from the current RW pointer. RW pointer will be moved to the end of the stream.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `stream` - Stream instance\n* `storage` - \n* `path` - \n* `mode` - \n\n"]
    pub fn stream_save_to_file(
        stream: *mut Stream,
        storage: *mut Storage,
        path: *const core::ffi::c_char,
        mode: FS_OpenMode,
    ) -> usize;
}
extern "C" {
    #[doc = "Dump stream inner data (size, RW position, content)\n\n# Arguments\n\n* `stream` - Stream instance\n\n"]
    pub fn stream_dump_data(stream: *mut Stream);
}
extern "C" {
    #[doc = "Returns the underlying stream instance. Use only if you know what you are doing.\n\nReturns:\n\n* Stream*\n\n# Arguments\n\n* `flipper_format` - \n\n"]
    pub fn flipper_format_get_raw_stream(flipper_format: *mut FlipperFormat) -> *mut Stream;
}
pub const FlipperStreamValue_FlipperStreamValueIgnore: FlipperStreamValue = 0;
pub const FlipperStreamValue_FlipperStreamValueStr: FlipperStreamValue = 1;
pub const FlipperStreamValue_FlipperStreamValueHex: FlipperStreamValue = 2;
pub const FlipperStreamValue_FlipperStreamValueFloat: FlipperStreamValue = 3;
pub const FlipperStreamValue_FlipperStreamValueInt32: FlipperStreamValue = 4;
pub const FlipperStreamValue_FlipperStreamValueUint32: FlipperStreamValue = 5;
pub const FlipperStreamValue_FlipperStreamValueHexUint64: FlipperStreamValue = 6;
pub const FlipperStreamValue_FlipperStreamValueBool: FlipperStreamValue = 7;
pub type FlipperStreamValue = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlipperStreamWriteData {
    pub key: *const core::ffi::c_char,
    pub type_: FlipperStreamValue,
    pub data: *const core::ffi::c_void,
    pub data_size: usize,
}
#[test]
fn bindgen_test_layout_FlipperStreamWriteData() {
    const UNINIT: ::core::mem::MaybeUninit<FlipperStreamWriteData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlipperStreamWriteData>(),
        16usize,
        concat!("Size of: ", stringify!(FlipperStreamWriteData))
    );
    assert_eq!(
        ::core::mem::align_of::<FlipperStreamWriteData>(),
        4usize,
        concat!("Alignment of ", stringify!(FlipperStreamWriteData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperStreamWriteData),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperStreamWriteData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperStreamWriteData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FlipperStreamWriteData),
            "::",
            stringify!(data_size)
        )
    );
}
extern "C" {
    #[doc = "Writes a key/value pair to the stream.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `write_data` - \n\n"]
    pub fn flipper_format_stream_write_value_line(
        stream: *mut Stream,
        write_data: *mut FlipperStreamWriteData,
    ) -> bool;
}
extern "C" {
    #[doc = "Reads a value by key from a stream.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `key` - \n* `type` - \n* `_data` - \n* `data_size` - \n* `strict_mode` - \n\n"]
    pub fn flipper_format_stream_read_value_line(
        stream: *mut Stream,
        key: *const core::ffi::c_char,
        type_: FlipperStreamValue,
        _data: *mut core::ffi::c_void,
        data_size: usize,
        strict_mode: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "Get the count of values by key from a stream.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `key` - \n* `count` - \n* `strict_mode` - \n\n"]
    pub fn flipper_format_stream_get_value_count(
        stream: *mut Stream,
        key: *const core::ffi::c_char,
        count: *mut u32,
        strict_mode: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "Removes a key and the corresponding value string from the stream and inserts a new key/value pair.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `write_data` - \n* `strict_mode` - \n\n"]
    pub fn flipper_format_stream_delete_key_and_write(
        stream: *mut Stream,
        write_data: *mut FlipperStreamWriteData,
        strict_mode: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "Writes a comment string to the stream.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n* `data` - \n\n"]
    pub fn flipper_format_stream_write_comment_cstr(
        stream: *mut Stream,
        data: *const core::ffi::c_char,
    ) -> bool;
}
pub type iButtonProtocolId = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonEditableData {
    pub ptr: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_iButtonEditableData() {
    const UNINIT: ::core::mem::MaybeUninit<iButtonEditableData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<iButtonEditableData>(),
        8usize,
        concat!("Size of: ", stringify!(iButtonEditableData))
    );
    assert_eq!(
        ::core::mem::align_of::<iButtonEditableData>(),
        4usize,
        concat!("Alignment of ", stringify!(iButtonEditableData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iButtonEditableData),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(iButtonEditableData),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonKey {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate a key object\n\nReturns:\n\n* pointer to the key object\n\n# Arguments\n\n* `[in]` - data_size maximum data size held by the key\n\n"]
    pub fn ibutton_key_alloc(data_size: usize) -> *mut iButtonKey;
}
extern "C" {
    #[doc = "Destroy the key object, free resources\n\n# Arguments\n\n* `[in]` - key pointer to the key object\n\n"]
    pub fn ibutton_key_free(key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Get the protocol id held by the key\n\nReturns:\n\n* protocol id held by the key\n\n# Arguments\n\n* `[in]` - key pointer to the key object\n\n"]
    pub fn ibutton_key_get_protocol_id(key: *const iButtonKey) -> iButtonProtocolId;
}
extern "C" {
    #[doc = "Set the protocol id held by the key\n\n# Arguments\n\n* `[in]` - key pointer to the key object\n* `[in]` - protocol_id new protocol id\n\n"]
    pub fn ibutton_key_set_protocol_id(key: *mut iButtonKey, protocol_id: iButtonProtocolId);
}
extern "C" {
    #[doc = "Reset the protocol id and data held by the key\n\n# Arguments\n\n* `[in]` - key pointer to the key object\n\n"]
    pub fn ibutton_key_reset(key: *mut iButtonKey);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonProtocols {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate an iButtonProtocols object\n\nReturns:\n\n* pointer to an iButtonProtocols object\n\n"]
    pub fn ibutton_protocols_alloc() -> *mut iButtonProtocols;
}
extern "C" {
    #[doc = "Destroy an iButtonProtocols object, free resources\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n\n"]
    pub fn ibutton_protocols_free(protocols: *mut iButtonProtocols);
}
extern "C" {
    #[doc = "Get the total number of available protocols\n\n"]
    pub fn ibutton_protocols_get_protocol_count() -> u32;
}
extern "C" {
    #[doc = "Get maximum data size out of all protocols available\n\nReturns:\n\n* maximum data size in bytes\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n\n"]
    pub fn ibutton_protocols_get_max_data_size(protocols: *mut iButtonProtocols) -> usize;
}
extern "C" {
    #[doc = "Get the protocol id based on its name\n\nReturns:\n\n* protocol id on success on iButtonProtocolIdInvalid on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - name pointer to a string containing the name\n\n"]
    pub fn ibutton_protocols_get_id_by_name(
        protocols: *mut iButtonProtocols,
        name: *const core::ffi::c_char,
    ) -> iButtonProtocolId;
}
extern "C" {
    #[doc = "Get the manufacturer name based on the protocol id\n\nReturns:\n\n* pointer to a statically allocated string with manufacturer name\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - id id of the protocol in question\n\n"]
    pub fn ibutton_protocols_get_manufacturer(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get the protocol name based on the protocol id\n\nReturns:\n\n* pointer to a statically allocated string with protocol name\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - id id of the protocol in question\n\n"]
    pub fn ibutton_protocols_get_name(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get protocol features bitmask by protocol id\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - id id of the protocol in question\n\n"]
    pub fn ibutton_protocols_get_features(
        protocols: *mut iButtonProtocols,
        id: iButtonProtocolId,
    ) -> u32;
}
extern "C" {
    #[doc = "Read a physical device (a key or an emulator)\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[out]` - key pointer to the key to read into (must be allocated before)\n\n"]
    pub fn ibutton_protocols_read(protocols: *mut iButtonProtocols, key: *mut iButtonKey) -> bool;
}
extern "C" {
    #[doc = "Write the key to a blank\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be written\n\n"]
    pub fn ibutton_protocols_write_blank(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
    ) -> bool;
}
extern "C" {
    #[doc = "Write the key to another one of the same type\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be written\n\n"]
    pub fn ibutton_protocols_write_copy(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
    ) -> bool;
}
extern "C" {
    #[doc = "Start emulating the key\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be emulated\n\n"]
    pub fn ibutton_protocols_emulate_start(protocols: *mut iButtonProtocols, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Stop emulating the key\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be emulated\n\n"]
    pub fn ibutton_protocols_emulate_stop(protocols: *mut iButtonProtocols, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Save the key data to a file.\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be saved\n* `[in]` - file_name full absolute path to the file name\n\n"]
    pub fn ibutton_protocols_save(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        file_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Load the key from a file.\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[out]` - key pointer to the key to load into (must be allocated before)\n* `[in]` - file_name full absolute path to the file name\n\n"]
    pub fn ibutton_protocols_load(
        protocols: *mut iButtonProtocols,
        key: *mut iButtonKey,
        file_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Format a string containing device full data\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be rendered\n* `[out]` - result pointer to the FuriString instance (must be initialized)\n\n"]
    pub fn ibutton_protocols_render_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Format a string containing device brief data\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be rendered\n* `[out]` - result pointer to the FuriString instance (must be initialized)\n\n"]
    pub fn ibutton_protocols_render_brief_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Format a string containing error message (for invalid keys)\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be rendered\n* `[out]` - result pointer to the FuriString instance (must be initialized)\n\n"]
    pub fn ibutton_protocols_render_error(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        result: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Check whether the key data is valid\n\nReturns:\n\n* true if data is valid, false otherwise\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be checked\n\n"]
    pub fn ibutton_protocols_is_valid(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
    ) -> bool;
}
extern "C" {
    #[doc = "Get a pointer to the key's editable data (for in-place editing)\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in]` - key pointer to the key to be checked\n* `[out]` - editable pointer to a structure to contain the editable data\n\n"]
    pub fn ibutton_protocols_get_editable_data(
        protocols: *mut iButtonProtocols,
        key: *const iButtonKey,
        editable: *mut iButtonEditableData,
    );
}
extern "C" {
    #[doc = "Make all necessary internal adjustments after editing the key\n\n# Arguments\n\n* `[in]` - protocols pointer to an iButtonProtocols object\n* `[in,out]` - key pointer to the key to be adjusted\n\n"]
    pub fn ibutton_protocols_apply_edits(protocols: *mut iButtonProtocols, key: *const iButtonKey);
}
pub const iButtonWorkerWriteResult_iButtonWorkerWriteOK: iButtonWorkerWriteResult = 0;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteSameKey: iButtonWorkerWriteResult = 1;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteNoDetect: iButtonWorkerWriteResult = 2;
pub const iButtonWorkerWriteResult_iButtonWorkerWriteCannotWrite: iButtonWorkerWriteResult = 3;
pub type iButtonWorkerWriteResult = core::ffi::c_uchar;
pub type iButtonWorkerReadCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type iButtonWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, result: iButtonWorkerWriteResult),
>;
pub type iButtonWorkerEmulateCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, emulated: bool)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iButtonWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate ibutton worker\n\nReturns:\n\n* iButtonWorker*\n\n"]
    pub fn ibutton_worker_alloc(protocols: *mut iButtonProtocols) -> *mut iButtonWorker;
}
extern "C" {
    #[doc = "Free ibutton worker\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn ibutton_worker_free(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = "Start ibutton worker thread\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn ibutton_worker_start_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = "Stop ibutton worker thread\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn ibutton_worker_stop_thread(worker: *mut iButtonWorker);
}
extern "C" {
    #[doc = "Set \"read success\" callback\n\n# Arguments\n\n* `worker` - \n* `callback` - \n* `context` - \n\n"]
    pub fn ibutton_worker_read_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start read mode\n\n# Arguments\n\n* `worker` - \n* `key` - \n\n"]
    pub fn ibutton_worker_read_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Set \"write event\" callback\n\n# Arguments\n\n* `worker` - \n* `callback` - \n* `context` - \n\n"]
    pub fn ibutton_worker_write_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start write blank mode\n\n# Arguments\n\n* `worker` - \n* `key` - \n\n"]
    pub fn ibutton_worker_write_blank_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Start write copy mode\n\n# Arguments\n\n* `worker` - \n* `key` - \n\n"]
    pub fn ibutton_worker_write_copy_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Set \"emulate success\" callback\n\n# Arguments\n\n* `worker` - \n* `callback` - \n* `context` - \n\n"]
    pub fn ibutton_worker_emulate_set_callback(
        worker: *mut iButtonWorker,
        callback: iButtonWorkerEmulateCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start emulate mode\n\n# Arguments\n\n* `worker` - \n* `key` - \n\n"]
    pub fn ibutton_worker_emulate_start(worker: *mut iButtonWorker, key: *mut iButtonKey);
}
extern "C" {
    #[doc = "Stop all modes\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn ibutton_worker_stop(worker: *mut iButtonWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredDecoderHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredEncoderHandler {
    _unused: [u8; 0],
}
pub const InfraredProtocol_InfraredProtocolUnknown: InfraredProtocol = -1;
pub const InfraredProtocol_InfraredProtocolNEC: InfraredProtocol = 0;
pub const InfraredProtocol_InfraredProtocolNECext: InfraredProtocol = 1;
pub const InfraredProtocol_InfraredProtocolNEC42: InfraredProtocol = 2;
pub const InfraredProtocol_InfraredProtocolNEC42ext: InfraredProtocol = 3;
pub const InfraredProtocol_InfraredProtocolSamsung32: InfraredProtocol = 4;
pub const InfraredProtocol_InfraredProtocolRC6: InfraredProtocol = 5;
pub const InfraredProtocol_InfraredProtocolRC5: InfraredProtocol = 6;
pub const InfraredProtocol_InfraredProtocolRC5X: InfraredProtocol = 7;
pub const InfraredProtocol_InfraredProtocolSIRC: InfraredProtocol = 8;
pub const InfraredProtocol_InfraredProtocolSIRC15: InfraredProtocol = 9;
pub const InfraredProtocol_InfraredProtocolSIRC20: InfraredProtocol = 10;
pub const InfraredProtocol_InfraredProtocolKaseikyo: InfraredProtocol = 11;
pub const InfraredProtocol_InfraredProtocolRCA: InfraredProtocol = 12;
pub const InfraredProtocol_InfraredProtocolMAX: InfraredProtocol = 13;
pub type InfraredProtocol = core::ffi::c_schar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredMessage {
    pub protocol: InfraredProtocol,
    pub address: u32,
    pub command: u32,
    pub repeat: bool,
}
#[test]
fn bindgen_test_layout_InfraredMessage() {
    const UNINIT: ::core::mem::MaybeUninit<InfraredMessage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InfraredMessage>(),
        16usize,
        concat!("Size of: ", stringify!(InfraredMessage))
    );
    assert_eq!(
        ::core::mem::align_of::<InfraredMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(InfraredMessage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(InfraredMessage),
            "::",
            stringify!(repeat)
        )
    );
}
pub const InfraredStatus_InfraredStatusError: InfraredStatus = 0;
pub const InfraredStatus_InfraredStatusOk: InfraredStatus = 1;
pub const InfraredStatus_InfraredStatusDone: InfraredStatus = 2;
pub const InfraredStatus_InfraredStatusReady: InfraredStatus = 3;
pub type InfraredStatus = core::ffi::c_uchar;
extern "C" {
    #[doc = "Initialize decoder.\n\nReturns:\n\n* returns pointer to INFRARED decoder handler if success, otherwise - error.\n\n"]
    pub fn infrared_alloc_decoder() -> *mut InfraredDecoderHandler;
}
extern "C" {
    #[doc = "Provide to decoder next timing.\n\nReturns:\n\n* if message is ready, returns pointer to decoded message, returns NULL. Note: ownership of returned ptr belongs to handler. So pointer is valid up to next infrared_free_decoder(), infrared_reset_decoder(), infrared_decode(), infrared_check_decoder_ready() calls.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n* `level` - [Direction: In] - high(true) or low(false) level of input signal to analyze. it should alternate every call, otherwise it is an error case, and decoder resets its state and start decoding from the start.\n* `duration` - [Direction: In] - duration of steady high/low input signal.\n\n"]
    pub fn infrared_decode(
        handler: *mut InfraredDecoderHandler,
        level: bool,
        duration: u32,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = "Check whether decoder is ready. Functionality is quite similar to infrared_decode(), but with no timing providing. Some protocols (e.g. Sony SIRC) has variable payload length, which means we can't recognize end of message right after receiving last bit. That's why application should call to infrared_check_decoder_ready() after some timeout to retrieve decoded message, if so.\n\nReturns:\n\n* if message is ready, returns pointer to decoded message, returns NULL. Note: ownership of returned ptr belongs to handler. So pointer is valid up to next infrared_free_decoder(), infrared_reset_decoder(), infrared_decode(), infrared_check_decoder_ready() calls.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n\n"]
    pub fn infrared_check_decoder_ready(
        handler: *mut InfraredDecoderHandler,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = "Deinitialize decoder and free allocated memory.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n\n"]
    pub fn infrared_free_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = "Reset INFRARED decoder.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED decoders. Should be acquired with \\c infrared_alloc_decoder().\n\n"]
    pub fn infrared_reset_decoder(handler: *mut InfraredDecoderHandler);
}
extern "C" {
    #[doc = "Get protocol name by protocol enum.\n\nReturns:\n\n* string to protocol name.\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol identifier.\n\n"]
    pub fn infrared_get_protocol_name(protocol: InfraredProtocol) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get protocol enum by protocol name.\n\nReturns:\n\n* protocol identifier.\n\n# Arguments\n\n* `protocol_name` - [Direction: In] - string to protocol name.\n\n"]
    pub fn infrared_get_protocol_by_name(
        protocol_name: *const core::ffi::c_char,
    ) -> InfraredProtocol;
}
extern "C" {
    #[doc = "Get address length by protocol enum.\n\nReturns:\n\n* length of address in bits.\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol identifier.\n\n"]
    pub fn infrared_get_protocol_address_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = "Get command length by protocol enum.\n\nReturns:\n\n* length of command in bits.\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol identifier.\n\n"]
    pub fn infrared_get_protocol_command_length(protocol: InfraredProtocol) -> u8;
}
extern "C" {
    #[doc = "Checks whether protocol valid.\n\nReturns:\n\n* true if protocol is valid, false otherwise.\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol identifier.\n\n"]
    pub fn infrared_is_protocol_valid(protocol: InfraredProtocol) -> bool;
}
extern "C" {
    #[doc = "Allocate INFRARED encoder.\n\nReturns:\n\n* encoder handler.\n\n"]
    pub fn infrared_alloc_encoder() -> *mut InfraredEncoderHandler;
}
extern "C" {
    #[doc = "Free encoder handler previously allocated with \\c infrared_alloc_encoder().\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder().\n\n"]
    pub fn infrared_free_encoder(handler: *mut InfraredEncoderHandler);
}
extern "C" {
    #[doc = "Encode previously set INFRARED message. Usage: 1) alloc with \\c infrared_alloc_encoder() 2) set message to encode with \\c infrared_reset_encoder() 3) call for \\c infrared_encode() to continuously get one at a time timings. 4) when \\c infrared_encode() returns InfraredStatusDone, it means new message is fully encoded. 5) to encode additional timings, just continue calling \\c infrared_encode().\n\nReturns:\n\n* status of encode operation.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder().\n* `duration` - [Direction: In, Out] - encoded timing.\n* `level` - [Direction: In, Out] - encoded level.\n\n"]
    pub fn infrared_encode(
        handler: *mut InfraredEncoderHandler,
        duration: *mut u32,
        level: *mut bool,
    ) -> InfraredStatus;
}
extern "C" {
    #[doc = "Reset INFRARED encoder and set new message to encode. If it's not called after receiveing InfraredStatusDone in \\c infrared_encode(), encoder will encode repeat messages till the end of time.\n\n# Arguments\n\n* `handler` - [Direction: In] - handler to INFRARED encoder. Should be acquired with \\c infrared_alloc_encoder().\n* `message` - [Direction: In] - message to encode.\n\n"]
    pub fn infrared_reset_encoder(
        handler: *mut InfraredEncoderHandler,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = "Get PWM frequency value for selected protocol\n\nReturns:\n\n* frequency\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol to get from PWM frequency\n\n"]
    pub fn infrared_get_protocol_frequency(protocol: InfraredProtocol) -> u32;
}
extern "C" {
    #[doc = "Get PWM duty cycle value for selected protocol\n\nReturns:\n\n* duty cycle\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol to get from PWM duty cycle\n\n"]
    pub fn infrared_get_protocol_duty_cycle(protocol: InfraredProtocol) -> f32;
}
extern "C" {
    #[doc = "Get the minimum count of signal repeats for the selected protocol\n\nReturns:\n\n* repeat count\n\n# Arguments\n\n* `protocol` - [Direction: In] - protocol to get the repeat count from\n\n"]
    pub fn infrared_get_protocol_min_repeat_count(protocol: InfraredProtocol) -> usize;
}
#[doc = "New data obtained\n\n"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateOk:
    FuriHalInfraredTxGetDataState = 0;
#[doc = "New data obtained, and this is end of package\n\n"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateDone:
    FuriHalInfraredTxGetDataState = 1;
#[doc = "New data obtained, and this is end of package and no more data available\n\n"]
pub const FuriHalInfraredTxGetDataState_FuriHalInfraredTxGetDataStateLastDone:
    FuriHalInfraredTxGetDataState = 2;
pub type FuriHalInfraredTxGetDataState = core::ffi::c_uchar;
#[doc = "Callback type for providing data to INFRARED DMA TX system. It is called every tim\n\n"]
pub type FuriHalInfraredTxGetDataISRCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        duration: *mut u32,
        level: *mut bool,
    ) -> FuriHalInfraredTxGetDataState,
>;
#[doc = "Callback type called every time signal is sent by DMA to Timer.\nActually, it means there are 2 timings left to send for this signal, which is almost end. Don't use this callback to stop transmission, as far as there are next signal is charged for transmission by DMA.\n\n"]
pub type FuriHalInfraredTxSignalSentISRCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Signature of callback function for receiving continuous INFRARED rx signal.\n\n# Arguments\n\n* `ctx[in]` - context to pass to callback\n* `level[in]` - level of input INFRARED rx signal\n* `duration[in]` - duration of continuous rx signal level in us\n\n"]
pub type FuriHalInfraredRxCaptureCallback = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut core::ffi::c_void, level: bool, duration: u32),
>;
#[doc = "Signature of callback function for reaching silence timeout on INFRARED port.\n\n# Arguments\n\n* `ctx[in]` - context to pass to callback\n\n"]
pub type FuriHalInfraredRxTimeoutCallback =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut core::ffi::c_void)>;
extern "C" {
    pub fn furi_hal_infrared_set_debug_out(enable: bool);
}
extern "C" {
    pub fn furi_hal_infrared_get_debug_out_status() -> bool;
}
extern "C" {
    #[doc = "Initialize INFRARED RX timer to receive interrupts.\nIt provides interrupts for every RX-signal edge changing with its duration.\n\n"]
    pub fn furi_hal_infrared_async_rx_start();
}
extern "C" {
    #[doc = "Deinitialize INFRARED RX interrupt.\n\n"]
    pub fn furi_hal_infrared_async_rx_stop();
}
extern "C" {
    #[doc = "Setup hal for receiving silence timeout.\nShould be used with 'furi_hal_infrared_timeout_irq_set_callback()'.\n\n# Arguments\n\n* `timeout_us` - [Direction: In] time to wait for silence on INFRARED port before generating IRQ.\n\n"]
    pub fn furi_hal_infrared_async_rx_set_timeout(timeout_us: u32);
}
extern "C" {
    #[doc = "Setup callback for previously initialized INFRARED RX interrupt.\n\n# Arguments\n\n* `callback` - [Direction: In] callback to call when RX signal edge changing occurs\n* `ctx` - [Direction: In] context for callback\n\n"]
    pub fn furi_hal_infrared_async_rx_set_capture_isr_callback(
        callback: FuriHalInfraredRxCaptureCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Setup callback for reaching silence timeout on INFRARED port.\nShould setup hal with 'furi_hal_infrared_setup_rx_timeout_irq()' first.\n\n# Arguments\n\n* `callback` - [Direction: In] callback for silence timeout\n* `ctx` - [Direction: In] context to pass to callback\n\n"]
    pub fn furi_hal_infrared_async_rx_set_timeout_isr_callback(
        callback: FuriHalInfraredRxTimeoutCallback,
        ctx: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Check if INFRARED is in use now.\n\nReturns:\n\n* true if INFRARED is busy, false otherwise.\n\n"]
    pub fn furi_hal_infrared_is_busy() -> bool;
}
extern "C" {
    #[doc = "Set callback providing new data.\nThis function has to be called before furi_hal_infrared_async_tx_start().\n\n# Arguments\n\n* `callback` - [Direction: In] function to provide new data\n* `context` - [Direction: In] context for callback\n\n"]
    pub fn furi_hal_infrared_async_tx_set_data_isr_callback(
        callback: FuriHalInfraredTxGetDataISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start IR asynchronous transmission.\nIt can be stopped by 2 reasons: 1. implicit call for furi_hal_infrared_async_tx_stop() 2. callback can provide FuriHalInfraredTxGetDataStateLastDone response which means no more data available for transmission.\nAny func (furi_hal_infrared_async_tx_stop() or furi_hal_infrared_async_tx_wait_termination()) has to be called to wait end of transmission and free resources.\n\n# Arguments\n\n* `freq` - [Direction: In] frequency for PWM\n* `duty_cycle` - [Direction: In] duty cycle for PWM\n\n"]
    pub fn furi_hal_infrared_async_tx_start(freq: u32, duty_cycle: f32);
}
extern "C" {
    #[doc = "Stop IR asynchronous transmission and free resources.\nTransmission will stop as soon as transmission reaches end of package (FuriHalInfraredTxGetDataStateDone or FuriHalInfraredTxGetDataStateLastDone).\n\n"]
    pub fn furi_hal_infrared_async_tx_stop();
}
extern "C" {
    #[doc = "Wait for end of IR asynchronous transmission and free resources.\nTransmission will stop as soon as transmission reaches end of transmission (FuriHalInfraredTxGetDataStateLastDone).\n\n"]
    pub fn furi_hal_infrared_async_tx_wait_termination();
}
extern "C" {
    #[doc = "Set callback for end of signal transmission\n\n# Arguments\n\n* `callback` - [Direction: In] function to call when signal is sent\n* `context` - [Direction: In] context for callback\n\n"]
    pub fn furi_hal_infrared_async_tx_set_signal_sent_isr_callback(
        callback: FuriHalInfraredTxSignalSentISRCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Send message over INFRARED.\n\n# Arguments\n\n* `message` - [Direction: In] - message to send.\n* `times` - [Direction: In] - number of times message should be sent.\n\n"]
    pub fn infrared_send(message: *const InfraredMessage, times: core::ffi::c_int);
}
extern "C" {
    #[doc = "Send raw data through infrared port.\n\n# Arguments\n\n* `timings` - [Direction: In] - array of timings to send.\n* `timings_cnt` - [Direction: In] - timings array size.\n* `start_from_mark` - [Direction: In] - true if timings starts from mark, otherwise from space\n\n"]
    pub fn infrared_send_raw(timings: *const u32, timings_cnt: u32, start_from_mark: bool);
}
extern "C" {
    #[doc = "Send raw data through infrared port, with additional settings.\n\n# Arguments\n\n* `timings` - [Direction: In] - array of timings to send.\n* `timings_cnt` - [Direction: In] - timings array size.\n* `start_from_mark` - [Direction: In] - true if timings starts from mark, otherwise from space\n* `duty_cycle` - [Direction: In] - duty cycle to generate on PWM\n* `frequency` - [Direction: In] - frequency to generate on PWM\n\n"]
    pub fn infrared_send_raw_ext(
        timings: *const u32,
        timings_cnt: u32,
        start_from_mark: bool,
        frequency: u32,
        duty_cycle: f32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InfraredWorkerSignal {
    _unused: [u8; 0],
}
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseNew:
    InfraredWorkerGetSignalResponse = 0;
#[doc = "Signal, provided by callback is new and encoder should be reseted\n\n"]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseSame:
    InfraredWorkerGetSignalResponse = 1;
#[doc = "Signal, provided by callback is same. No encoder resetting.\n\n"]
pub const InfraredWorkerGetSignalResponse_InfraredWorkerGetSignalResponseStop:
    InfraredWorkerGetSignalResponse = 2;
pub type InfraredWorkerGetSignalResponse = core::ffi::c_uchar;
#[doc = "Callback type for providing next signal to send. Should be used with infrared_worker_make_decoded_signal() or infrared_worker_make_raw_signal()\n\n"]
pub type InfraredWorkerGetSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse,
>;
#[doc = "Callback type for 'message is sent' event\n\n"]
pub type InfraredWorkerMessageSentCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[doc = "Callback type to call by InfraredWorker thread when new signal is received\n\n"]
pub type InfraredWorkerReceivedSignalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        received_signal: *mut InfraredWorkerSignal,
    ),
>;
extern "C" {
    #[doc = "Allocate InfraredWorker\n\nReturns:\n\n* just created instance of InfraredWorker\n\n"]
    pub fn infrared_worker_alloc() -> *mut InfraredWorker;
}
extern "C" {
    #[doc = "Free InfraredWorker\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_free(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = "Start InfraredWorker thread, initialise furi_hal, prepare all work.\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_rx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = "Stop InfraredWorker thread, deinitialize furi_hal.\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_rx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = "Set received data callback InfraredWorker\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n* `context` - [Direction: In] - context to pass to callbacks\n* `callback` - [Direction: In] - InfraredWorkerReceivedSignalCallback callback\n\n"]
    pub fn infrared_worker_rx_set_received_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerReceivedSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Enable blinking on receiving any signal on IR port.\n\n# Arguments\n\n* `instance` - [Direction: In] - instance of InfraredWorker\n* `enable` - [Direction: In] - true if you want to enable blinking false otherwise\n\n"]
    pub fn infrared_worker_rx_enable_blink_on_receiving(
        instance: *mut InfraredWorker,
        enable: bool,
    );
}
extern "C" {
    #[doc = "Enable decoding of received infrared signals.\n\n# Arguments\n\n* `instance` - [Direction: In] - instance of InfraredWorker\n* `enable` - [Direction: In] - true if you want to enable decoding false otherwise\n\n"]
    pub fn infrared_worker_rx_enable_signal_decoding(instance: *mut InfraredWorker, enable: bool);
}
extern "C" {
    #[doc = "Clarify is received signal either decoded or raw\n\nReturns:\n\n* true if signal is decoded, false if signal is raw\n\n# Arguments\n\n* `signal` - [Direction: In] - received signal\n\n"]
    pub fn infrared_worker_signal_is_decoded(signal: *const InfraredWorkerSignal) -> bool;
}
extern "C" {
    #[doc = "Start transmitting signal. Callback InfraredWorkerGetSignalCallback should be set before this function is called, as it calls for it to fill buffer before starting transmission.\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_tx_start(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = "Stop transmitting signal. Waits for end of current signal and stops transmission.\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_tx_stop(instance: *mut InfraredWorker);
}
extern "C" {
    #[doc = "Set callback for providing next signal to send\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n* `context` - [Direction: In] - context to pass to callbacks\n* `callback` - [Direction: In] - InfraredWorkerGetSignalCallback callback\n\n"]
    pub fn infrared_worker_tx_set_get_signal_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerGetSignalCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set callback for end of signal transmitting\n\n# Arguments\n\n* `instance` - [Direction: In] - InfraredWorker instance\n* `context` - [Direction: In] - context to pass to callbacks\n* `callback` - [Direction: In] - InfraredWorkerMessageSentCallback callback\n\n"]
    pub fn infrared_worker_tx_set_signal_sent_callback(
        instance: *mut InfraredWorker,
        callback: InfraredWorkerMessageSentCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Callback to pass to infrared_worker_tx_set_get_signal_callback() if signal is steady and will not be changed between infrared_worker start and stop. Before starting transmission, desired steady signal must be set with infrared_worker_set_decoded_signal() or infrared_worker_set_raw_signal().\nThis function should not be called directly.\n\n# Arguments\n\n* `context` - [Direction: In] - context\n* `instance` - [Direction: In, Out] - InfraredWorker instance\n\n"]
    pub fn infrared_worker_tx_get_signal_steady_callback(
        context: *mut core::ffi::c_void,
        instance: *mut InfraredWorker,
    ) -> InfraredWorkerGetSignalResponse;
}
extern "C" {
    #[doc = "Acquire raw signal from interface struct 'InfraredWorkerSignal'. First, you have to ensure that signal is raw.\n\n# Arguments\n\n* `signal` - [Direction: In] - received signal\n* `timings` - [Direction: In, Out] - pointer to array of timings\n* `timings_cnt` - [Direction: In, Out] - pointer to amount of timings\n\n"]
    pub fn infrared_worker_get_raw_signal(
        signal: *const InfraredWorkerSignal,
        timings: *mut *const u32,
        timings_cnt: *mut usize,
    );
}
extern "C" {
    #[doc = "Acquire decoded message from interface struct 'InfraredWorkerSignal'. First, you have to ensure that signal is decoded.\n\nReturns:\n\n* decoded INFRARED message\n\n# Arguments\n\n* `signal` - [Direction: In] - received signal\n\n"]
    pub fn infrared_worker_get_decoded_signal(
        signal: *const InfraredWorkerSignal,
    ) -> *const InfraredMessage;
}
extern "C" {
    #[doc = "Set current decoded signal for InfraredWorker instance\n\n# Arguments\n\n* `instance` - [Direction: In, Out] - InfraredWorker instance\n* `message` - [Direction: In] - decoded signal\n\n"]
    pub fn infrared_worker_set_decoded_signal(
        instance: *mut InfraredWorker,
        message: *const InfraredMessage,
    );
}
extern "C" {
    #[doc = "Set current raw signal for InfraredWorker instance\n\n# Arguments\n\n* `instance` - [Direction: In, Out] - InfraredWorker instance\n* `timings` - [Direction: In] - array of raw timings\n* `timings_cnt` - [Direction: In] - size of array of raw timings\n* `frequency` - [Direction: In] - carrier frequency in Hertz\n* `duty_cycle` - [Direction: In] - carrier duty cycle (0.0 - 1.0)\n\n"]
    pub fn infrared_worker_set_raw_signal(
        instance: *mut InfraredWorker,
        timings: *const u32,
        timings_cnt: usize,
        frequency: u32,
        duty_cycle: f32,
    );
}
pub type ProtocolAlloc = ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>;
pub type ProtocolFree =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolGetData =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> *mut u8>;
pub type ProtocolDecoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void)>;
pub type ProtocolDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, level: bool, duration: u32) -> bool,
>;
pub type ProtocolEncoderStart =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> bool>;
pub type ProtocolEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(protocol: *mut core::ffi::c_void) -> LevelDuration>;
pub type ProtocolRenderData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, result: *mut FuriString),
>;
pub type ProtocolWriteData = ::core::option::Option<
    unsafe extern "C" fn(protocol: *mut core::ffi::c_void, data: *mut core::ffi::c_void) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDecoder {
    pub start: ProtocolDecoderStart,
    pub feed: ProtocolDecoderFeed,
}
#[test]
fn bindgen_test_layout_ProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolDecoder>(),
        8usize,
        concat!("Size of: ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolDecoder>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolEncoder {
    pub start: ProtocolEncoderStart,
    pub yield_: ProtocolEncoderYield,
}
#[test]
fn bindgen_test_layout_ProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolEncoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolEncoder>(),
        8usize,
        concat!("Size of: ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolEncoder>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolBase {
    pub data_size: usize,
    pub name: *const core::ffi::c_char,
    pub manufacturer: *const core::ffi::c_char,
    pub features: u32,
    pub validate_count: u8,
    pub alloc: ProtocolAlloc,
    pub free: ProtocolFree,
    pub get_data: ProtocolGetData,
    pub decoder: ProtocolDecoder,
    pub encoder: ProtocolEncoder,
    pub render_data: ProtocolRenderData,
    pub render_brief_data: ProtocolRenderData,
    pub write_data: ProtocolWriteData,
}
#[test]
fn bindgen_test_layout_ProtocolBase() {
    const UNINIT: ::core::mem::MaybeUninit<ProtocolBase> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ProtocolBase>(),
        60usize,
        concat!("Size of: ", stringify!(ProtocolBase))
    );
    assert_eq!(
        ::core::mem::align_of::<ProtocolBase>(),
        4usize,
        concat!("Alignment of ", stringify!(ProtocolBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).validate_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(validate_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(get_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).render_brief_data) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(render_brief_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ProtocolBase),
            "::",
            stringify!(write_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProtocolDict {
    _unused: [u8; 0],
}
pub type ProtocolId = i32;
extern "C" {
    pub fn protocol_dict_alloc(
        protocols: *mut *const ProtocolBase,
        protocol_count: usize,
    ) -> *mut ProtocolDict;
}
extern "C" {
    pub fn protocol_dict_free(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_set_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *const u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_data_size(dict: *mut ProtocolDict, protocol_index: usize) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_max_data_size(dict: *mut ProtocolDict) -> usize;
}
extern "C" {
    pub fn protocol_dict_get_name(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_get_manufacturer(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn protocol_dict_decoders_start(dict: *mut ProtocolDict);
}
extern "C" {
    pub fn protocol_dict_get_features(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_decoders_feed(
        dict: *mut ProtocolDict,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_feature(
        dict: *mut ProtocolDict,
        feature: u32,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_decoders_feed_by_id(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        level: bool,
        duration: u32,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_encoder_start(dict: *mut ProtocolDict, protocol_index: usize) -> bool;
}
extern "C" {
    pub fn protocol_dict_encoder_yield(
        dict: *mut ProtocolDict,
        protocol_index: usize,
    ) -> LevelDuration;
}
extern "C" {
    pub fn protocol_dict_render_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_render_brief_data(
        dict: *mut ProtocolDict,
        result: *mut FuriString,
        protocol_index: usize,
    );
}
extern "C" {
    pub fn protocol_dict_get_validate_count(dict: *mut ProtocolDict, protocol_index: usize) -> u32;
}
extern "C" {
    pub fn protocol_dict_get_protocol_by_name(
        dict: *mut ProtocolDict,
        name: *const core::ffi::c_char,
    ) -> ProtocolId;
}
extern "C" {
    pub fn protocol_dict_get_write_data(
        dict: *mut ProtocolDict,
        protocol_index: usize,
        data: *mut core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDT5577 {
    pub block: [u32; 8usize],
    pub blocks_to_write: u32,
}
#[test]
fn bindgen_test_layout_LFRFIDT5577() {
    const UNINIT: ::core::mem::MaybeUninit<LFRFIDT5577> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LFRFIDT5577>(),
        36usize,
        concat!("Size of: ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        ::core::mem::align_of::<LFRFIDT5577>(),
        4usize,
        concat!("Alignment of ", stringify!(LFRFIDT5577))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks_to_write) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LFRFIDT5577),
            "::",
            stringify!(blocks_to_write)
        )
    );
}
extern "C" {
    #[doc = "Write T5577 tag data to tag\n\n# Arguments\n\n* `data` - \n\n"]
    pub fn t5577_write(data: *mut LFRFIDT5577);
}
extern "C" {
    pub fn t5577_write_with_pass(data: *mut LFRFIDT5577, password: u32);
}
pub const LFRFIDProtocol_LFRFIDProtocolEM4100: LFRFIDProtocol = 0;
pub const LFRFIDProtocol_LFRFIDProtocolH10301: LFRFIDProtocol = 1;
pub const LFRFIDProtocol_LFRFIDProtocolIdteck: LFRFIDProtocol = 2;
pub const LFRFIDProtocol_LFRFIDProtocolIndala26: LFRFIDProtocol = 3;
pub const LFRFIDProtocol_LFRFIDProtocolIOProxXSF: LFRFIDProtocol = 4;
pub const LFRFIDProtocol_LFRFIDProtocolAwid: LFRFIDProtocol = 5;
pub const LFRFIDProtocol_LFRFIDProtocolFDXA: LFRFIDProtocol = 6;
pub const LFRFIDProtocol_LFRFIDProtocolFDXB: LFRFIDProtocol = 7;
pub const LFRFIDProtocol_LFRFIDProtocolHidGeneric: LFRFIDProtocol = 8;
pub const LFRFIDProtocol_LFRFIDProtocolHidExGeneric: LFRFIDProtocol = 9;
pub const LFRFIDProtocol_LFRFIDProtocolPyramid: LFRFIDProtocol = 10;
pub const LFRFIDProtocol_LFRFIDProtocolViking: LFRFIDProtocol = 11;
pub const LFRFIDProtocol_LFRFIDProtocolJablotron: LFRFIDProtocol = 12;
pub const LFRFIDProtocol_LFRFIDProtocolParadox: LFRFIDProtocol = 13;
pub const LFRFIDProtocol_LFRFIDProtocolPACStanley: LFRFIDProtocol = 14;
pub const LFRFIDProtocol_LFRFIDProtocolKeri: LFRFIDProtocol = 15;
pub const LFRFIDProtocol_LFRFIDProtocolGallagher: LFRFIDProtocol = 16;
pub const LFRFIDProtocol_LFRFIDProtocolNexwatch: LFRFIDProtocol = 17;
pub const LFRFIDProtocol_LFRFIDProtocolMax: LFRFIDProtocol = 18;
pub type LFRFIDProtocol = core::ffi::c_uchar;
extern "C" {
    pub static mut lfrfid_protocols: [*const ProtocolBase; 0usize];
}
extern "C" {
    #[doc = "Save protocol from dictionary to file\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `dict` - \n* `protocol` - \n* `filename` - \n\n"]
    pub fn lfrfid_dict_file_save(
        dict: *mut ProtocolDict,
        protocol: ProtocolId,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Load protocol from file to dictionary\n\nReturns:\n\n* ProtocolId\n\n# Arguments\n\n* `dict` - \n* `filename` - \n\n"]
    pub fn lfrfid_dict_file_load(
        dict: *mut ProtocolDict,
        filename: *const core::ffi::c_char,
    ) -> ProtocolId;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawFile {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate a new LFRFIDRawFile instance\n\nReturns:\n\n* LFRFIDRawFile*\n\n# Arguments\n\n* `storage` - \n\n"]
    pub fn lfrfid_raw_file_alloc(storage: *mut Storage) -> *mut LFRFIDRawFile;
}
extern "C" {
    #[doc = "Free a LFRFIDRawFile instance\n\n# Arguments\n\n* `file` - \n\n"]
    pub fn lfrfid_raw_file_free(file: *mut LFRFIDRawFile);
}
extern "C" {
    #[doc = "Open RAW file for writing\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `file_path` - \n\n"]
    pub fn lfrfid_raw_file_open_write(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Open RAW file for reading\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `file_path` - \n\n"]
    pub fn lfrfid_raw_file_open_read(
        file: *mut LFRFIDRawFile,
        file_path: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Write RAW file header\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `frequency` - \n* `duty_cycle` - \n* `max_buffer_size` - \n\n"]
    pub fn lfrfid_raw_file_write_header(
        file: *mut LFRFIDRawFile,
        frequency: f32,
        duty_cycle: f32,
        max_buffer_size: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Write data to RAW file\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `buffer_data` - \n* `buffer_size` - \n\n"]
    pub fn lfrfid_raw_file_write_buffer(
        file: *mut LFRFIDRawFile,
        buffer_data: *mut u8,
        buffer_size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Read RAW file header\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `frequency` - \n* `duty_cycle` - \n\n"]
    pub fn lfrfid_raw_file_read_header(
        file: *mut LFRFIDRawFile,
        frequency: *mut f32,
        duty_cycle: *mut f32,
    ) -> bool;
}
extern "C" {
    #[doc = "Read varint-encoded pair from RAW file\n\nReturns:\n\n* bool\n\n# Arguments\n\n* `file` - \n* `duration` - \n* `pulse` - \n* `pass_end` - file was wrapped around, can be NULL\n\n"]
    pub fn lfrfid_raw_file_read_pair(
        file: *mut LFRFIDRawFile,
        duration: *mut u32,
        pulse: *mut u32,
        pass_end: *mut bool,
    ) -> bool;
}
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteOK: LFRFIDWorkerWriteResult = 0;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteProtocolCannotBeWritten:
    LFRFIDWorkerWriteResult = 1;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteFobCannotBeWritten: LFRFIDWorkerWriteResult = 2;
pub const LFRFIDWorkerWriteResult_LFRFIDWorkerWriteTooLongToWrite: LFRFIDWorkerWriteResult = 3;
pub type LFRFIDWorkerWriteResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeAuto: LFRFIDWorkerReadType = 0;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypeASKOnly: LFRFIDWorkerReadType = 1;
pub const LFRFIDWorkerReadType_LFRFIDWorkerReadTypePSKOnly: LFRFIDWorkerReadType = 2;
pub type LFRFIDWorkerReadType = core::ffi::c_uchar;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseStart: LFRFIDWorkerReadResult = 0;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseEnd: LFRFIDWorkerReadResult = 1;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardStart: LFRFIDWorkerReadResult = 2;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadSenseCardEnd: LFRFIDWorkerReadResult = 3;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartASK: LFRFIDWorkerReadResult = 4;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadStartPSK: LFRFIDWorkerReadResult = 5;
pub const LFRFIDWorkerReadResult_LFRFIDWorkerReadDone: LFRFIDWorkerReadResult = 6;
pub type LFRFIDWorkerReadResult = core::ffi::c_uchar;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawFileError: LFRFIDWorkerReadRawResult = 0;
pub const LFRFIDWorkerReadRawResult_LFRFIDWorkerReadRawOverrun: LFRFIDWorkerReadRawResult = 1;
pub type LFRFIDWorkerReadRawResult = core::ffi::c_uchar;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawFileError:
    LFRFIDWorkerEmulateRawResult = 0;
pub const LFRFIDWorkerEmulateRawResult_LFRFIDWorkerEmulateRawOverrun: LFRFIDWorkerEmulateRawResult =
    1;
pub type LFRFIDWorkerEmulateRawResult = core::ffi::c_uchar;
pub type LFRFIDWorkerReadCallback = ::core::option::Option<
    unsafe extern "C" fn(
        result: LFRFIDWorkerReadResult,
        protocol: ProtocolId,
        context: *mut core::ffi::c_void,
    ),
>;
pub type LFRFIDWorkerWriteCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerWriteResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerReadRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerReadRawResult, context: *mut core::ffi::c_void),
>;
pub type LFRFIDWorkerEmulateRawCallback = ::core::option::Option<
    unsafe extern "C" fn(result: LFRFIDWorkerEmulateRawResult, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate LF-RFID worker\n\nReturns:\n\n* LFRFIDWorker*\n\n"]
    pub fn lfrfid_worker_alloc(dict: *mut ProtocolDict) -> *mut LFRFIDWorker;
}
extern "C" {
    #[doc = "Free LF-RFID worker\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_worker_free(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = "Start LF-RFID worker thread\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_worker_start_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = "Stop LF-RFID worker thread\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_worker_stop_thread(worker: *mut LFRFIDWorker);
}
extern "C" {
    #[doc = "Start read mode\n\n# Arguments\n\n* `worker` - \n* `type` - \n* `callback` - \n* `context` - \n\n"]
    pub fn lfrfid_worker_read_start(
        worker: *mut LFRFIDWorker,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start write mode\n\n# Arguments\n\n* `worker` - \n* `protocol` - \n* `callback` - \n* `context` - \n\n"]
    pub fn lfrfid_worker_write_start(
        worker: *mut LFRFIDWorker,
        protocol: LFRFIDProtocol,
        callback: LFRFIDWorkerWriteCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start emulate mode\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_worker_emulate_start(worker: *mut LFRFIDWorker, protocol: LFRFIDProtocol);
}
extern "C" {
    #[doc = "Start raw read mode\n\n# Arguments\n\n* `worker` - \n* `filename` - \n* `type` - \n* `callback` - \n* `context` - \n\n"]
    pub fn lfrfid_worker_read_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        type_: LFRFIDWorkerReadType,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Emulate raw read mode\n\n# Arguments\n\n* `worker` - \n* `filename` - \n* `callback` - \n* `context` - \n\n"]
    pub fn lfrfid_worker_emulate_raw_start(
        worker: *mut LFRFIDWorker,
        filename: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop all modes\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_worker_stop(worker: *mut LFRFIDWorker);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LFRFIDRawWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate a new LFRFIDRawWorker instance\n\nReturns:\n\n* LFRFIDRawWorker*\n\n"]
    pub fn lfrfid_raw_worker_alloc() -> *mut LFRFIDRawWorker;
}
extern "C" {
    #[doc = "Free a LFRFIDRawWorker instance\n\n# Arguments\n\n* `worker` - LFRFIDRawWorker instance\n\n"]
    pub fn lfrfid_raw_worker_free(worker: *mut LFRFIDRawWorker);
}
extern "C" {
    #[doc = "Start reading\n\n# Arguments\n\n* `worker` - LFRFIDRawWorker instance\n* `file_path` - path where file will be saved\n* `frequency` - HW frequency\n* `duty_cycle` - HW duty cycle\n* `callback` - callback for read event\n* `context` - context for callback\n\n"]
    pub fn lfrfid_raw_worker_start_read(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        frequency: f32,
        duty_cycle: f32,
        callback: LFRFIDWorkerReadRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Start emulate\n\n# Arguments\n\n* `worker` - LFRFIDRawWorker instance\n* `file_path` - path to file that will be emulated\n* `callback` - callback for emulate event\n* `context` - context for callback\n\n"]
    pub fn lfrfid_raw_worker_start_emulate(
        worker: *mut LFRFIDRawWorker,
        file_path: *const core::ffi::c_char,
        callback: LFRFIDWorkerEmulateRawCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop worker\n\n# Arguments\n\n* `worker` - \n\n"]
    pub fn lfrfid_raw_worker_stop(worker: *mut LFRFIDRawWorker);
}
pub const BitLibParity_BitLibParityEven: BitLibParity = 0;
pub const BitLibParity_BitLibParityOdd: BitLibParity = 1;
pub const BitLibParity_BitLibParityAlways0: BitLibParity = 2;
pub const BitLibParity_BitLibParityAlways1: BitLibParity = 3;
pub type BitLibParity = core::ffi::c_uchar;
extern "C" {
    #[doc = "Push a bit into a byte array.\n\n# Arguments\n\n* `data` - array to push bit into\n* `data_size` - array size\n* `bit` - bit to push\n\n"]
    pub fn bit_lib_push_bit(data: *mut u8, data_size: usize, bit: bool);
}
extern "C" {
    #[doc = "Set a bit in a byte array.\n\n# Arguments\n\n* `data` - array to set bit in\n* `position` - The position of the bit to set.\n* `bit` - bit value to set\n\n"]
    pub fn bit_lib_set_bit(data: *mut u8, position: usize, bit: bool);
}
extern "C" {
    #[doc = "Set the bit at the given position to the given value.\n\n# Arguments\n\n* `data` - The data to set the bit in.\n* `position` - The position of the bit to set.\n* `byte` - The data to set the bit to.\n* `length` - The length of the data.\n\n"]
    pub fn bit_lib_set_bits(data: *mut u8, position: usize, byte: u8, length: u8);
}
extern "C" {
    #[doc = "Get the bit of a byte.\n\nReturns:\n\n* The bit.\n\n# Arguments\n\n* `data` - The byte to get the bits from.\n* `position` - The position of the bit.\n\n"]
    pub fn bit_lib_get_bit(data: *const u8, position: usize) -> bool;
}
extern "C" {
    #[doc = "Get the bits of a data, as uint8_t.\n\nReturns:\n\n* The bits.\n\n# Arguments\n\n* `data` - The data to get the bits from.\n* `position` - The position of the first bit.\n* `length` - The length of the bits.\n\n"]
    pub fn bit_lib_get_bits(data: *const u8, position: usize, length: u8) -> u8;
}
extern "C" {
    #[doc = "Get the bits of a data, as uint16_t.\n\nReturns:\n\n* The bits.\n\n# Arguments\n\n* `data` - The data to get the bits from.\n* `position` - The position of the first bit.\n* `length` - The length of the bits.\n\n"]
    pub fn bit_lib_get_bits_16(data: *const u8, position: usize, length: u8) -> u16;
}
extern "C" {
    #[doc = "Get the bits of a data, as uint32_t.\n\nReturns:\n\n* The bits.\n\n# Arguments\n\n* `data` - The data to get the bits from.\n* `position` - The position of the first bit.\n* `length` - The length of the bits.\n\n"]
    pub fn bit_lib_get_bits_32(data: *const u8, position: usize, length: u8) -> u32;
}
extern "C" {
    #[doc = "Test parity of given bits\n\nReturns:\n\n* true if parity is correct, false otherwise\n\n# Arguments\n\n* `bits` - Bits to test parity of\n* `parity` - Parity to test against\n\n"]
    pub fn bit_lib_test_parity_32(bits: u32, parity: BitLibParity) -> bool;
}
extern "C" {
    #[doc = "Test parity of bit array, check parity for every parity_length block from start\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `data` - Bit array\n* `position` - Start position\n* `length` - Bit count\n* `parity` - Parity to test against\n* `parity_length` - Parity block length\n\n"]
    pub fn bit_lib_test_parity(
        data: *const u8,
        position: usize,
        length: u8,
        parity: BitLibParity,
        parity_length: u8,
    ) -> bool;
}
extern "C" {
    #[doc = "Add parity to bit array\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `data` - Source bit array\n* `position` - Start position\n* `dest` - Destination bit array\n* `dest_position` - Destination position\n* `source_length` - Source bit count\n* `parity_length` - Parity block length\n* `parity` - Parity to test against\n\n"]
    pub fn bit_lib_add_parity(
        data: *const u8,
        position: usize,
        dest: *mut u8,
        dest_position: usize,
        source_length: u8,
        parity_length: u8,
        parity: BitLibParity,
    ) -> usize;
}
extern "C" {
    #[doc = "Remove bit every n in array and shift array left. Useful to remove parity.\n\nReturns:\n\n* size_t\n\n# Arguments\n\n* `data` - Bit array\n* `position` - Start position\n* `length` - Bit count\n* `n` - every n bit will be removed\n\n"]
    pub fn bit_lib_remove_bit_every_nth(data: *mut u8, position: usize, length: u8, n: u8)
        -> usize;
}
extern "C" {
    #[doc = "Copy bits from source to destination.\n\n# Arguments\n\n* `data` - destination array\n* `position` - position in destination array\n* `length` - length of bits to copy\n* `source` - source array\n* `source_position` - position in source array\n\n"]
    pub fn bit_lib_copy_bits(
        data: *mut u8,
        position: usize,
        length: usize,
        source: *const u8,
        source_position: usize,
    );
}
extern "C" {
    #[doc = "Reverse bits in bit array\n\n# Arguments\n\n* `data` - Bit array\n* `position` - start position\n* `length` - length of bits to reverse\n\n"]
    pub fn bit_lib_reverse_bits(data: *mut u8, position: usize, length: u8);
}
extern "C" {
    #[doc = "Count 1 bits in data\n\nReturns:\n\n* uint8_t set bit count\n\n# Arguments\n\n* `data` - \n\n"]
    pub fn bit_lib_get_bit_count(data: u32) -> u8;
}
extern "C" {
    #[doc = "Print data as bit array\n\n# Arguments\n\n* `data` - \n* `length` - \n\n"]
    pub fn bit_lib_print_bits(data: *const u8, length: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitLibRegion {
    pub mark: core::ffi::c_char,
    pub start: usize,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_BitLibRegion() {
    const UNINIT: ::core::mem::MaybeUninit<BitLibRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BitLibRegion>(),
        12usize,
        concat!("Size of: ", stringify!(BitLibRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<BitLibRegion>(),
        4usize,
        concat!("Alignment of ", stringify!(BitLibRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mark) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(mark)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BitLibRegion),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = "Print data as bit array and mark regions. Regions needs to be sorted by start position.\n\n# Arguments\n\n* `regions` - \n* `region_count` - \n* `data` - \n* `length` - \n\n"]
    pub fn bit_lib_print_regions(
        regions: *const BitLibRegion,
        region_count: usize,
        data: *const u8,
        length: usize,
    );
}
extern "C" {
    #[doc = "Reverse bits in uint16_t, faster than generic bit_lib_reverse_bits.\n\nReturns:\n\n* uint16_t\n\n# Arguments\n\n* `data` - \n\n"]
    pub fn bit_lib_reverse_16_fast(data: u16) -> u16;
}
extern "C" {
    #[doc = "Reverse bits in uint8_t, faster than generic bit_lib_reverse_bits.\n\nReturns:\n\n* uint8_t the reversed byte\n\n# Arguments\n\n* `byte` - Byte\n\n"]
    pub fn bit_lib_reverse_8_fast(byte: u8) -> u8;
}
extern "C" {
    #[doc = "Slow, but generic CRC8 implementation\n\nReturns:\n\n* uint8_t\n\n# Arguments\n\n* `data` - \n* `data_size` - \n* `polynom` - CRC polynom\n* `init` - init value\n* `ref_in` - true if the right bit is older\n* `ref_out` - true to reverse output\n* `xor_out` - xor output with this value\n\n"]
    pub fn bit_lib_crc8(
        data: *const u8,
        data_size: usize,
        polynom: u8,
        init: u8,
        ref_in: bool,
        ref_out: bool,
        xor_out: u8,
    ) -> u16;
}
extern "C" {
    #[doc = "Slow, but generic CRC16 implementation\n\nReturns:\n\n* uint16_t\n\n# Arguments\n\n* `data` - \n* `data_size` - \n* `polynom` - CRC polynom\n* `init` - init value\n* `ref_in` - true if the right bit is older\n* `ref_out` - true to reverse output\n* `xor_out` - xor output with this value\n\n"]
    pub fn bit_lib_crc16(
        data: *const u8,
        data_size: usize,
        polynom: u16,
        init: u16,
        ref_in: bool,
        ref_out: bool,
        xor_out: u16,
    ) -> u16;
}
#[doc = "Line Coding Structure\n\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usb_cdc_line_coding {
    #[doc = "<\\brief Data terminal rate, in bits per second.\n\n"]
    pub dwDTERate: u32,
    #[doc = "<\\brief Stop bits.\n\n"]
    pub bCharFormat: u8,
    #[doc = "<\\brief Parity.\n\n"]
    pub bParityType: u8,
    #[doc = "<\\brief Data bits (5,6,7,8 or 16).\n\n"]
    pub bDataBits: u8,
}
#[test]
fn bindgen_test_layout_usb_cdc_line_coding() {
    const UNINIT: ::core::mem::MaybeUninit<usb_cdc_line_coding> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usb_cdc_line_coding>(),
        7usize,
        concat!("Size of: ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        ::core::mem::align_of::<usb_cdc_line_coding>(),
        1usize,
        concat!("Alignment of ", stringify!(usb_cdc_line_coding))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwDTERate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(dwDTERate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bCharFormat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bCharFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bParityType) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bParityType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bDataBits) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(usb_cdc_line_coding),
            "::",
            stringify!(bDataBits)
        )
    );
}
extern "C" {
    #[doc = "This function calculates the SHA-1 checksum of a buffer.\n\nThe function allocates the context, performs the calculation, and frees the context.\nThe SHA-1 result is calculated as output = SHA-1(input buffer).\n\n**Warning!**\n\n* SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.\n\nReturns:\n\n* \\c 0 on success.\n* A negative error code on failure.\n\n# Arguments\n\n* `input` - The buffer holding the input data. This must be a readable buffer of length \\p ilen Bytes.\n* `ilen` - The length of the input data \\p input in Bytes.\n* `output` - The SHA-1 checksum result. This must be a writable buffer of length \\c 20 Bytes.\n\n"]
    pub fn mbedtls_sha1(
        input: *const core::ffi::c_uchar,
        ilen: usize,
        output: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uECC_Curve_t {
    _unused: [u8; 0],
}
pub type uECC_Curve = *const uECC_Curve_t;
extern "C" {
    pub fn uECC_secp256r1() -> uECC_Curve;
}
pub type uECC_RNG_Function = ::core::option::Option<
    unsafe extern "C" fn(dest: *mut u8, size: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn uECC_set_rng(rng_function: uECC_RNG_Function);
}
extern "C" {
    pub fn uECC_compute_public_key(
        private_key: *const u8,
        public_key: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn uECC_sign(
        private_key: *const u8,
        message_hash: *const u8,
        hash_size: core::ffi::c_uint,
        signature: *mut u8,
        curve: uECC_Curve,
    ) -> core::ffi::c_int;
}
pub type pb_type_t = uint_least8_t;
pub type pb_size_t = uint_least16_t;
pub type pb_byte_t = uint_least8_t;
pub type pb_istream_t = pb_istream_s;
pub type pb_ostream_t = pb_ostream_s;
pub type pb_field_iter_t = pb_field_iter_s;
pub type pb_msgdesc_t = pb_msgdesc_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_msgdesc_s {
    pub field_info: *const u32,
    pub submsg_info: *const *const pb_msgdesc_t,
    pub default_value: *const pb_byte_t,
    pub field_callback: ::core::option::Option<
        unsafe extern "C" fn(
            istream: *mut pb_istream_t,
            ostream: *mut pb_ostream_t,
            field: *const pb_field_iter_t,
        ) -> bool,
    >,
    pub field_count: pb_size_t,
    pub required_field_count: pb_size_t,
    pub largest_tag: pb_size_t,
}
#[test]
fn bindgen_test_layout_pb_msgdesc_s() {
    const UNINIT: ::core::mem::MaybeUninit<pb_msgdesc_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pb_msgdesc_s>(),
        24usize,
        concat!("Size of: ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        ::core::mem::align_of::<pb_msgdesc_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_msgdesc_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).field_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).submsg_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(submsg_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).field_callback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).field_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(field_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).required_field_count) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(required_field_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).largest_tag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_msgdesc_s),
            "::",
            stringify!(largest_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_field_iter_s {
    pub descriptor: *const pb_msgdesc_t,
    pub message: *mut core::ffi::c_void,
    pub index: pb_size_t,
    pub field_info_index: pb_size_t,
    pub required_field_index: pb_size_t,
    pub submessage_index: pb_size_t,
    pub tag: pb_size_t,
    pub data_size: pb_size_t,
    pub array_size: pb_size_t,
    pub type_: pb_type_t,
    pub pField: *mut core::ffi::c_void,
    pub pData: *mut core::ffi::c_void,
    pub pSize: *mut core::ffi::c_void,
    pub submsg_desc: *const pb_msgdesc_t,
}
#[test]
fn bindgen_test_layout_pb_field_iter_s() {
    const UNINIT: ::core::mem::MaybeUninit<pb_field_iter_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pb_field_iter_s>(),
        40usize,
        concat!("Size of: ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        ::core::mem::align_of::<pb_field_iter_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_field_iter_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(descriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).field_info_index) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(field_info_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).required_field_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(required_field_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).submessage_index) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submessage_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(array_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pField) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pField)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pData) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(pSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).submsg_desc) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_field_iter_s),
            "::",
            stringify!(submsg_desc)
        )
    );
}
pub type pb_field_t = pb_field_iter_t;
extern "C" {
    pub fn pb_default_field_callback(
        istream: *mut pb_istream_t,
        ostream: *mut pb_ostream_t,
        field: *const pb_field_t,
    ) -> bool;
}
pub const pb_wire_type_t_PB_WT_VARINT: pb_wire_type_t = 0;
pub const pb_wire_type_t_PB_WT_64BIT: pb_wire_type_t = 1;
pub const pb_wire_type_t_PB_WT_STRING: pb_wire_type_t = 2;
pub const pb_wire_type_t_PB_WT_32BIT: pb_wire_type_t = 5;
pub const pb_wire_type_t_PB_WT_PACKED: pb_wire_type_t = 255;
pub type pb_wire_type_t = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_istream_s {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: usize) -> bool,
    >,
    pub state: *mut core::ffi::c_void,
    pub bytes_left: usize,
    pub errmsg: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_pb_istream_s() {
    const UNINIT: ::core::mem::MaybeUninit<pb_istream_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pb_istream_s>(),
        16usize,
        concat!("Size of: ", stringify!(pb_istream_s))
    );
    assert_eq!(
        ::core::mem::align_of::<pb_istream_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_istream_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(bytes_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errmsg) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_istream_s),
            "::",
            stringify!(errmsg)
        )
    );
}
extern "C" {
    pub fn pb_decode(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_decode_ex(
        stream: *mut pb_istream_t,
        fields: *const pb_msgdesc_t,
        dest_struct: *mut core::ffi::c_void,
        flags: core::ffi::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn pb_release(fields: *const pb_msgdesc_t, dest_struct: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Functions for manipulating streams *\n\n"]
    pub fn pb_istream_from_buffer(buf: *const pb_byte_t, msglen: usize) -> pb_istream_t;
}
extern "C" {
    pub fn pb_read(stream: *mut pb_istream_t, buf: *mut pb_byte_t, count: usize) -> bool;
}
extern "C" {
    #[doc = "Helper functions for writing field callbacks *\n\n"]
    pub fn pb_decode_tag(
        stream: *mut pb_istream_t,
        wire_type: *mut pb_wire_type_t,
        tag: *mut u32,
        eof: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn pb_skip_field(stream: *mut pb_istream_t, wire_type: pb_wire_type_t) -> bool;
}
extern "C" {
    pub fn pb_decode_varint(stream: *mut pb_istream_t, dest: *mut u64) -> bool;
}
extern "C" {
    pub fn pb_decode_varint32(stream: *mut pb_istream_t, dest: *mut u32) -> bool;
}
extern "C" {
    pub fn pb_decode_bool(stream: *mut pb_istream_t, dest: *mut bool) -> bool;
}
extern "C" {
    pub fn pb_decode_svarint(stream: *mut pb_istream_t, dest: *mut i64) -> bool;
}
extern "C" {
    pub fn pb_decode_fixed32(stream: *mut pb_istream_t, dest: *mut core::ffi::c_void) -> bool;
}
extern "C" {
    pub fn pb_decode_fixed64(stream: *mut pb_istream_t, dest: *mut core::ffi::c_void) -> bool;
}
extern "C" {
    pub fn pb_make_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_close_string_substream(
        stream: *mut pb_istream_t,
        substream: *mut pb_istream_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pb_ostream_s {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(
            stream: *mut pb_ostream_t,
            buf: *const pb_byte_t,
            count: usize,
        ) -> bool,
    >,
    pub state: *mut core::ffi::c_void,
    pub max_size: usize,
    pub bytes_written: usize,
    pub errmsg: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_pb_ostream_s() {
    const UNINIT: ::core::mem::MaybeUninit<pb_ostream_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pb_ostream_s>(),
        20usize,
        concat!("Size of: ", stringify!(pb_ostream_s))
    );
    assert_eq!(
        ::core::mem::align_of::<pb_ostream_s>(),
        4usize,
        concat!("Alignment of ", stringify!(pb_ostream_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_written) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(bytes_written)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errmsg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pb_ostream_s),
            "::",
            stringify!(errmsg)
        )
    );
}
extern "C" {
    pub fn pb_encode(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_ex(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
        flags: core::ffi::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn pb_get_encoded_size(
        size: *mut usize,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = "Functions for manipulating streams *\n\n"]
    pub fn pb_ostream_from_buffer(buf: *mut pb_byte_t, bufsize: usize) -> pb_ostream_t;
}
extern "C" {
    pub fn pb_write(stream: *mut pb_ostream_t, buf: *const pb_byte_t, count: usize) -> bool;
}
extern "C" {
    #[doc = "Helper functions for writing field callbacks *\n\n"]
    pub fn pb_encode_tag_for_field(
        stream: *mut pb_ostream_t,
        field: *const pb_field_iter_t,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_tag(
        stream: *mut pb_ostream_t,
        wiretype: pb_wire_type_t,
        field_number: u32,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_varint(stream: *mut pb_ostream_t, value: u64) -> bool;
}
extern "C" {
    pub fn pb_encode_svarint(stream: *mut pb_ostream_t, value: i64) -> bool;
}
extern "C" {
    pub fn pb_encode_string(
        stream: *mut pb_ostream_t,
        buffer: *const pb_byte_t,
        size: usize,
    ) -> bool;
}
extern "C" {
    pub fn pb_encode_fixed32(stream: *mut pb_ostream_t, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
    pub fn pb_encode_fixed64(stream: *mut pb_ostream_t, value: *const core::ffi::c_void) -> bool;
}
extern "C" {
    pub fn pb_encode_submessage(
        stream: *mut pb_ostream_t,
        fields: *const pb_msgdesc_t,
        src_struct: *const core::ffi::c_void,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate a BitBuffer instance.\n\nReturns:\n\n* pointer to the allocated BitBuffer instance\n\n# Arguments\n\n* `[in]` - capacity_bytes maximum buffer capacity, in bytes\n\n"]
    pub fn bit_buffer_alloc(capacity_bytes: usize) -> *mut BitBuffer;
}
extern "C" {
    #[doc = "Delete a BitBuffer instance.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance\n\n"]
    pub fn bit_buffer_free(buf: *mut BitBuffer);
}
extern "C" {
    #[doc = "Clear all data from a BitBuffer instance.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance\n\n"]
    pub fn bit_buffer_reset(buf: *mut BitBuffer);
}
extern "C" {
    #[doc = "Copy another BitBuffer instance's contents to this one, replacing all of the original data. The destination capacity must be no less than the source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - other pointer to a BitBuffer instance to copy from\n\n# Notes\n\n* \n\n"]
    pub fn bit_buffer_copy(buf: *mut BitBuffer, other: *const BitBuffer);
}
extern "C" {
    #[doc = "Copy all BitBuffer instance's contents to this one, starting from start_index, replacing all of the original data. The destination capacity must be no less than the source data size counting from start_index.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - other pointer to a BitBuffer instance to copy from\n* `[in]` - start_index index to begin copying source data from\n\n"]
    pub fn bit_buffer_copy_right(buf: *mut BitBuffer, other: *const BitBuffer, start_index: usize);
}
extern "C" {
    #[doc = "Copy all BitBuffer instance's contents to this one, ending with end_index, replacing all of the original data. The destination capacity must be no less than the source data size counting to end_index.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - other pointer to a BitBuffer instance to copy from\n* `[in]` - end_index index to end copying source data at\n\n"]
    pub fn bit_buffer_copy_left(buf: *mut BitBuffer, other: *const BitBuffer, end_index: usize);
}
extern "C" {
    #[doc = "Copy a byte array to a BitBuffer instance, replacing all of the original data. The destination capacity must be no less than the source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - data pointer to the byte array to be copied\n* `[in]` - size_bytes size of the data to be copied, in bytes\n\n"]
    pub fn bit_buffer_copy_bytes(buf: *mut BitBuffer, data: *const u8, size_bytes: usize);
}
extern "C" {
    #[doc = "Copy a byte array to a BitBuffer instance, replacing all of the original data. The destination capacity must be no less than the source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - data pointer to the byte array to be copied\n* `[in]` - size_bits size of the data to be copied, in bits\n\n"]
    pub fn bit_buffer_copy_bits(buf: *mut BitBuffer, data: *const u8, size_bits: usize);
}
extern "C" {
    #[doc = "Copy a byte with parity array to a BitBuffer instance, replacing all of the original data. The destination capacity must be no less than the source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to copy into\n* `[in]` - data pointer to the byte array to be copied\n* `[in]` - size_bitss size of the data to be copied, in bits\n\n"]
    pub fn bit_buffer_copy_bytes_with_parity(
        buf: *mut BitBuffer,
        data: *const u8,
        size_bits: usize,
    );
}
extern "C" {
    #[doc = "Write a BitBuffer instance's entire contents to an arbitrary memory location. The destination memory must be allocated. Additionally, the destination capacity must be no less than the source data size.\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to write from\n* `[out]` - dest pointer to the destination memory location\n* `[in]` - size_bytes maximum destination data size, in bytes\n\n"]
    pub fn bit_buffer_write_bytes(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        size_bytes: usize,
    );
}
extern "C" {
    #[doc = "Write a BitBuffer instance's entire contents to an arbitrary memory location. Additionally, place a parity bit after each byte. The destination memory must be allocated. Additionally, the destination capacity must be no less than the source data size plus parity.\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to write from\n* `[out]` - dest pointer to the destination memory location\n* `[in]` - size_bytes maximum destination data size, in bytes\n* `[out]` - bits_written actual number of bits writen, in bits\n\n"]
    pub fn bit_buffer_write_bytes_with_parity(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        size_bytes: usize,
        bits_written: *mut usize,
    );
}
extern "C" {
    #[doc = "Write a slice of BitBuffer instance's contents to an arbitrary memory location. The destination memory must be allocated. Additionally, the destination capacity must be no less than the requested slice size.\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to write from\n* `[out]` - dest pointer to the destination memory location\n* `[in]` - start_index index to begin copying source data from\n* `[in]` - size_bytes data slice size, in bytes\n\n"]
    pub fn bit_buffer_write_bytes_mid(
        buf: *const BitBuffer,
        dest: *mut core::ffi::c_void,
        start_index: usize,
        size_bytes: usize,
    );
}
extern "C" {
    #[doc = "Check whether a BitBuffer instance contains a partial byte (i.e. the bit count is not divisible by 8).\n\nReturns:\n\n* true if the instance contains a partial byte, false otherwise\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be checked\n\n"]
    pub fn bit_buffer_has_partial_byte(buf: *const BitBuffer) -> bool;
}
extern "C" {
    #[doc = "Check whether a BitBuffer instance's contents start with the designated byte.\n\nReturns:\n\n* true if data starts with designated byte, false otherwise\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be checked\n* `[in]` - byte byte value to be checked against\n\n"]
    pub fn bit_buffer_starts_with_byte(buf: *const BitBuffer, byte: u8) -> bool;
}
extern "C" {
    #[doc = "Get a BitBuffer instance's capacity (i.e. the maximum possible amount of data), in bytes.\n\nReturns:\n\n* capacity, in bytes\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n\n"]
    pub fn bit_buffer_get_capacity_bytes(buf: *const BitBuffer) -> usize;
}
extern "C" {
    #[doc = "Get a BitBuffer instance's data size (i.e. the amount of stored data), in bits. Might be not divisible by 8 (see bit_buffer_is_partial_byte).\n\nReturns:\n\n* data size, in bits.\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n\n"]
    pub fn bit_buffer_get_size(buf: *const BitBuffer) -> usize;
}
extern "C" {
    #[doc = "Get a BitBuffer instance's data size (i.e. the amount of stored data), in bytes. If a partial byte is present, it is also counted.\n\nReturns:\n\n* data size, in bytes.\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n\n"]
    pub fn bit_buffer_get_size_bytes(buf: *const BitBuffer) -> usize;
}
extern "C" {
    #[doc = "Get a byte value at a specified index in a BitBuffer instance. The index must be valid (i.e. less than the instance's data size in bytes).\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n* `[in]` - index index of the byte in question\n\n"]
    pub fn bit_buffer_get_byte(buf: *const BitBuffer, index: usize) -> u8;
}
extern "C" {
    #[doc = "Get a byte value starting from the specified bit index in a BitBuffer instance. The resulting byte might correspond to a single byte (if the index is a multiple of 8), or two overlapping bytes combined. The index must be valid (i.e. less than the instance's data size in bits).\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n* `[in]` - index bit index of the byte in question\n\n"]
    pub fn bit_buffer_get_byte_from_bit(buf: *const BitBuffer, index_bits: usize) -> u8;
}
extern "C" {
    #[doc = "Get the pointer to a BitBuffer instance's underlying data.\n\nReturns:\n\n* pointer to the underlying data\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n\n"]
    pub fn bit_buffer_get_data(buf: *const BitBuffer) -> *const u8;
}
extern "C" {
    #[doc = "Get the pointer to a BitBuffer instance's underlying data.\n\nReturns:\n\n* pointer to the underlying data\n\n# Arguments\n\n* `[in]` - buf pointer to a BitBuffer instance to be queried\n\n"]
    pub fn bit_buffer_get_parity(buf: *const BitBuffer) -> *const u8;
}
extern "C" {
    #[doc = "Set byte value at a specified index in a BitBuffer instance. The index must be valid (i.e. less than the instance's data size in bytes).\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be modified\n* `[in]` - index index of the byte in question\n* `[in]` - byte byte value to be set at index\n\n"]
    pub fn bit_buffer_set_byte(buf: *mut BitBuffer, index: usize, byte: u8);
}
extern "C" {
    #[doc = "Set byte and parity bit value at a specified index in a BitBuffer instance. The index must be valid (i.e. less than the instance's data size in bytes).\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be modified\n* `[in]` - index index of the byte in question\n* `[in]` - byte byte value to be set at index\n* `[in]` - parity parity bit value to be set at index\n\n"]
    pub fn bit_buffer_set_byte_with_parity(
        buff: *mut BitBuffer,
        index: usize,
        byte: u8,
        parity: bool,
    );
}
extern "C" {
    #[doc = "Resize a BitBuffer instance to a new size, in bits.\n\n**Warning!**\n\n* May cause bugs. Use only if absolutely necessary.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be resized\n* `[in]` - new_size the new size of the buffer, in bits\n\n"]
    pub fn bit_buffer_set_size(buf: *mut BitBuffer, new_size: usize);
}
extern "C" {
    #[doc = "Resize a BitBuffer instance to a new size, in bytes.\n\n**Warning!**\n\n* May cause bugs. Use only if absolutely necessary.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be resized\n* `[in]` - new_size_bytes the new size of the buffer, in bytes\n\n"]
    pub fn bit_buffer_set_size_bytes(buf: *mut BitBuffer, new_size_bytes: usize);
}
extern "C" {
    #[doc = "Append all BitBuffer's instance contents to this one. The destination capacity must be no less than its original data size plus source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be appended to\n* `[in]` - other pointer to a BitBuffer instance to be appended\n\n"]
    pub fn bit_buffer_append(buf: *mut BitBuffer, other: *const BitBuffer);
}
extern "C" {
    #[doc = "Append a BitBuffer's instance contents to this one, starting from start_index. The destination capacity must be no less than the source data size counting from start_index.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be appended to\n* `[in]` - other pointer to a BitBuffer instance to be appended\n* `[in]` - start_index index to begin copying source data from\n\n"]
    pub fn bit_buffer_append_right(
        buf: *mut BitBuffer,
        other: *const BitBuffer,
        start_index: usize,
    );
}
extern "C" {
    #[doc = "Append a byte to a BitBuffer instance. The destination capacity must be no less its original data size plus one.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be appended to\n* `[in]` - byte byte value to be appended\n\n"]
    pub fn bit_buffer_append_byte(buf: *mut BitBuffer, byte: u8);
}
extern "C" {
    #[doc = "Append a byte array to a BitBuffer instance. The destination capacity must be no less its original data size plus source data size.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be appended to\n* `[in]` - data pointer to the byte array to be appended\n* `[in]` - size_bytes size of the data to be appended, in bytes\n\n"]
    pub fn bit_buffer_append_bytes(buf: *mut BitBuffer, data: *const u8, size_bytes: usize);
}
extern "C" {
    #[doc = "Append a bit to a BitBuffer instance. The destination capacity must be sufficient to accomodate the additional bit.\n\n# Arguments\n\n* `[in,out]` - buf pointer to a BitBuffer instance to be appended to\n* `[in]` - bit bit value to be appended\n\n"]
    pub fn bit_buffer_append_bit(buf: *mut BitBuffer, bit: bool);
}
pub const Iso13239CrcType_Iso13239CrcTypeDefault: Iso13239CrcType = 0;
pub const Iso13239CrcType_Iso13239CrcTypePicopass: Iso13239CrcType = 1;
pub type Iso13239CrcType = core::ffi::c_uchar;
extern "C" {
    pub fn iso13239_crc_append(type_: Iso13239CrcType, buf: *mut BitBuffer);
}
extern "C" {
    pub fn iso13239_crc_check(type_: Iso13239CrcType, buf: *const BitBuffer) -> bool;
}
extern "C" {
    pub fn iso13239_crc_trim(buf: *mut BitBuffer);
}
pub const Iso14443CrcType_Iso14443CrcTypeA: Iso14443CrcType = 0;
pub const Iso14443CrcType_Iso14443CrcTypeB: Iso14443CrcType = 1;
pub type Iso14443CrcType = core::ffi::c_uchar;
extern "C" {
    pub fn iso14443_crc_append(type_: Iso14443CrcType, buf: *mut BitBuffer);
}
extern "C" {
    pub fn iso14443_crc_check(type_: Iso14443CrcType, buf: *const BitBuffer) -> bool;
}
extern "C" {
    pub fn iso14443_crc_trim(buf: *mut BitBuffer);
}
#[doc = "Display full(verbose) name.\n\n"]
pub const NfcDeviceNameType_NfcDeviceNameTypeFull: NfcDeviceNameType = 0;
#[doc = "Display shortened name.\n\n"]
pub const NfcDeviceNameType_NfcDeviceNameTypeShort: NfcDeviceNameType = 1;
#[doc = "Verbosity level of the displayed NFC device name.\n\n"]
pub type NfcDeviceNameType = core::ffi::c_uchar;
#[doc = "Generic opaque type for protocol-specific NFC device data.\n\n"]
pub type NfcDeviceData = core::ffi::c_void;
pub const NfcProtocol_NfcProtocolIso14443_3a: NfcProtocol = 0;
pub const NfcProtocol_NfcProtocolIso14443_3b: NfcProtocol = 1;
pub const NfcProtocol_NfcProtocolIso14443_4a: NfcProtocol = 2;
pub const NfcProtocol_NfcProtocolIso14443_4b: NfcProtocol = 3;
pub const NfcProtocol_NfcProtocolIso15693_3: NfcProtocol = 4;
pub const NfcProtocol_NfcProtocolFelica: NfcProtocol = 5;
pub const NfcProtocol_NfcProtocolMfUltralight: NfcProtocol = 6;
pub const NfcProtocol_NfcProtocolMfClassic: NfcProtocol = 7;
pub const NfcProtocol_NfcProtocolMfDesfire: NfcProtocol = 8;
pub const NfcProtocol_NfcProtocolSlix: NfcProtocol = 9;
pub const NfcProtocol_NfcProtocolSt25tb: NfcProtocol = 10;
#[doc = "Special value representing the number of available protocols.\n\n"]
pub const NfcProtocol_NfcProtocolNum: NfcProtocol = 11;
#[doc = "Special value representing an invalid state.\n\n"]
pub const NfcProtocol_NfcProtocolInvalid: NfcProtocol = 12;
#[doc = "Enumeration of all available NFC protocols.\n\nWhen implementing a new protocol, add its identifier before the NfcProtocolNum entry.\n\n"]
pub type NfcProtocol = core::ffi::c_uchar;
extern "C" {
    #[doc = "Get the immediate parent of a specific protocol.\n\nReturns:\n\n* parent protocol identifier if it has one, or NfcProtocolInvalid otherwise.\n\n# Arguments\n\n* `protocol` - [Direction: In] identifier of the protocol in question.\n\n"]
    pub fn nfc_protocol_get_parent(protocol: NfcProtocol) -> NfcProtocol;
}
extern "C" {
    #[doc = "Determine if a specific protocol has a parent on an arbitrary level.\n\nUnlike nfc_protocol_get_parent(), this function will traverse the full protocol hierarchy and check each parent node for the matching protocol type.\n\nReturns:\n\n* true if the parent of given type exists, false otherwise.\n\n# Arguments\n\n* `protocol` - [Direction: In] identifier of the protocol in question.\n* `parent_protocol` - [Direction: In] identifier of the parent protocol in question.\n\n"]
    pub fn nfc_protocol_has_parent(protocol: NfcProtocol, parent_protocol: NfcProtocol) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcDevice {
    _unused: [u8; 0],
}
#[doc = "Loading callback function signature.\n\nA function with such signature can be set as a callback to indicate the completion (or a failure) of nfc_device_load() and nfc_device_save() functions.\nThis facility is commonly used to control GUI elements, such as progress dialogs.\n\n# Arguments\n\n* `context` - [Direction: In] user-defined context that was passed in nfc_device_set_loading_callback().\n* `state` - [Direction: In] true if the data was loaded successfully, false otherwise.\n\n"]
pub type NfcLoadingCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: bool)>;
extern "C" {
    #[doc = "Allocate an NfcDevice instance.\n\nA newly created instance does not hold any data and thus is considered invalid. The most common use case would be to set its data by calling nfc_device_set_data() right afterwards.\n\nReturns:\n\n* pointer to the allocated instance.\n\n"]
    pub fn nfc_device_alloc() -> *mut NfcDevice;
}
extern "C" {
    #[doc = "Delete an NfcDevice instance.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be deleted.\n\n"]
    pub fn nfc_device_free(instance: *mut NfcDevice);
}
extern "C" {
    #[doc = "Clear an NfcDevice instance.\n\nAll data contained in the instance will be deleted and the instance itself will become invalid as if it was just allocated.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be cleared.\n\n"]
    pub fn nfc_device_clear(instance: *mut NfcDevice);
}
extern "C" {
    #[doc = "Reset an NfcDevice instance.\n\nThe data contained in the instance will be reset according to the protocol-defined procedure. Unlike the nfc_device_clear() function, the instance will remain valid.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be reset.\n\n"]
    pub fn nfc_device_reset(instance: *mut NfcDevice);
}
extern "C" {
    #[doc = "Get the protocol identifier from an NfcDevice instance.\n\nIf the instance is invalid, the return value will be NfcProtocolInvalid.\n\nReturns:\n\n* protocol identifier contained in the instance.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn nfc_device_get_protocol(instance: *const NfcDevice) -> NfcProtocol;
}
extern "C" {
    #[doc = "Get the protocol-specific data from an NfcDevice instance.\n\nThe protocol parameter's behaviour is a bit tricky. The function will check whether there is such a protocol somewhere in the protocol hierarchy and return the data exactly from that level.\nExample: Call nfc_device_get_data() on an instance with Mf DESFire protocol. The protocol hierarchy will look like the following:\n`Mf DESFire --> ISO14443-4A --> ISO14443-3A`\nThus, the following values of the protocol parameter are valid:\nNfcProtocolIso14443_3a NfcProtocolIso14443_4a NfcProtocolMfDesfire\nand passing them to the call would result in the respective data being returned.\nHowever, supplying a protocol identifier which is not in the hierarchy will result in a crash. This is to improve type safety.\n\nReturns:\n\n* pointer to the instance's data.\n\n# Arguments\n\n* `instance` - pointer to the instance to be queried\n* `protocol` - protocol identifier of the data to be retrieved.\n\n"]
    pub fn nfc_device_get_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
    ) -> *const NfcDeviceData;
}
extern "C" {
    #[doc = "Get the protocol name by its identifier.\n\nThis function does not require an instance as its return result depends only the protocol identifier.\n\nReturns:\n\n* pointer to a statically allocated string containing the protocol name.\n\n# Arguments\n\n* `protocol` - [Direction: In] numeric identifier of the protocol in question.\n\n"]
    pub fn nfc_device_get_protocol_name(protocol: NfcProtocol) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get the name of an NfcDevice instance.\n\nThe return value may change depending on the instance's internal state and the name_type parameter.\n\nReturns:\n\n* pointer to a statically allocated string containing the device name.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n* `name_type` - [Direction: In] type of the name to be displayed.\n\n"]
    pub fn nfc_device_get_name(
        instance: *const NfcDevice,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Get the unique identifier (UID) of an NfcDevice instance.\n\nThe UID length is protocol-dependent. Additionally, a particular protocol might support several UID lengths.\n\nReturns:\n\n* pointer to the byte array containing the instance's UID.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n* `uid_len` - [Direction: In, Out] pointer to the variable to contain the UID length.\n\n"]
    pub fn nfc_device_get_uid(instance: *const NfcDevice, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    #[doc = "Set the unique identifier (UID) of an NfcDevice instance.\n\nThe UID length must be supported by the instance's protocol.\n\nReturns:\n\n* true if the UID was valid and set, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `uid` - [Direction: In] pointer to the byte array containing the new UID.\n* `uid_len` - [Direction: In] length of the UID.\n\n"]
    pub fn nfc_device_set_uid(instance: *mut NfcDevice, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    #[doc = "Set the data and protocol of an NfcDevice instance.\n\nAny data previously contained in the instance will be deleted.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `protocol` - [Direction: In] numeric identifier of the data's protocol.\n* `protocol_data` - [Direction: In] pointer to the protocol-specific data.\n\n"]
    pub fn nfc_device_set_data(
        instance: *mut NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *const NfcDeviceData,
    );
}
extern "C" {
    #[doc = "Copy (export) the data contained in an NfcDevice instance to an outside NfcDeviceData instance.\n\nThis function does the inverse of nfc_device_set_data().\nThe protocol identifier passed as the protocol parameter MUST match the one stored in the instance, otherwise a crash will occur. This is to improve type safety.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be copied from.\n* `protocol` - [Direction: In] numeric identifier of the instance's protocol.\n* `protocol_data` - [Direction: In, Out] pointer to the destination data.\n\n"]
    pub fn nfc_device_copy_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *mut NfcDeviceData,
    );
}
extern "C" {
    #[doc = "Check whether an NfcDevice instance holds certain data.\n\nThis function's behaviour is similar to nfc_device_is_equal(), with the difference that it takes NfcProtocol and NfcDeviceData* instead of the second NfcDevice*.\nThe following code snippets [1] and [2] are equivalent:\n[1] ```c bool is_equal = nfc_device_is_equal(device1, device2); ``` [2] ```c NfcProtocol protocol = nfc_device_get_protocol(device2); const NfcDeviceData* data = nfc_device_get_data(device2, protocol); bool is_equal = nfc_device_is_equal_data(device1, protocol, data); ```\n\nReturns:\n\n* true if the instance is of the right type and the data matches, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be compared.\n* `protocol` - [Direction: In] protocol identifier of the data to be compared.\n* `protocol_data` - [Direction: In] pointer to the NFC device data to be compared.\n\n"]
    pub fn nfc_device_is_equal_data(
        instance: *const NfcDevice,
        protocol: NfcProtocol,
        protocol_data: *const NfcDeviceData,
    ) -> bool;
}
extern "C" {
    #[doc = "Compare two NfcDevice instances to determine whether they are equal.\n\nReturns:\n\n* true if both instances are considered equal, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the first instance to be compared.\n* `other` - [Direction: In] pointer to the second instance to be compared.\n\n"]
    pub fn nfc_device_is_equal(instance: *const NfcDevice, other: *const NfcDevice) -> bool;
}
extern "C" {
    #[doc = "Set the loading callback function.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `callback` - [Direction: In] pointer to a function to be called when the load operation completes.\n* `context` - [Direction: In] pointer to a user-specific context (will be passed to the callback).\n\n"]
    pub fn nfc_device_set_loading_callback(
        instance: *mut NfcDevice,
        callback: NfcLoadingCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Save NFC device data form an NfcDevice instance to a file.\n\nReturns:\n\n* true if the data was successfully saved, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be saved.\n* `path` - [Direction: In] pointer to a character string with a full file path.\n\n"]
    pub fn nfc_device_save(instance: *mut NfcDevice, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Load NFC device data to an NfcDevice instance from a file.\n\nReturns:\n\n* true if the data was successfully loaded, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be loaded into.\n* `path` - [Direction: In] pointer to a character string with a full file path.\n\n"]
    pub fn nfc_device_load(instance: *mut NfcDevice, path: *const core::ffi::c_char) -> bool;
}
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfUltralight: NfcDataGeneratorType = 0;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfUltralightEV1_11: NfcDataGeneratorType = 1;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfUltralightEV1_H11: NfcDataGeneratorType = 2;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfUltralightEV1_21: NfcDataGeneratorType = 3;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfUltralightEV1_H21: NfcDataGeneratorType = 4;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAG203: NfcDataGeneratorType = 5;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAG213: NfcDataGeneratorType = 6;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAG215: NfcDataGeneratorType = 7;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAG216: NfcDataGeneratorType = 8;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAGI2C1k: NfcDataGeneratorType = 9;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAGI2C2k: NfcDataGeneratorType = 10;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAGI2CPlus1k: NfcDataGeneratorType = 11;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNTAGI2CPlus2k: NfcDataGeneratorType = 12;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfClassicMini: NfcDataGeneratorType = 13;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfClassic1k_4b: NfcDataGeneratorType = 14;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfClassic1k_7b: NfcDataGeneratorType = 15;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfClassic4k_4b: NfcDataGeneratorType = 16;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeMfClassic4k_7b: NfcDataGeneratorType = 17;
pub const NfcDataGeneratorType_NfcDataGeneratorTypeNum: NfcDataGeneratorType = 18;
pub type NfcDataGeneratorType = core::ffi::c_uchar;
extern "C" {
    pub fn nfc_data_generator_get_name(type_: NfcDataGeneratorType) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn nfc_data_generator_fill_data(type_: NfcDataGeneratorType, nfc_device: *mut NfcDevice);
}
pub const NfcDictMode_NfcDictModeOpenExisting: NfcDictMode = 0;
pub const NfcDictMode_NfcDictModeOpenAlways: NfcDictMode = 1;
pub type NfcDictMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcDict {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Check dictionary presence\n\nReturns:\n\n* true if dictionary exists, false otherwise\n\n# Arguments\n\n* `path` - - dictionary path\n\n"]
    pub fn nfc_dict_check_presence(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Open or create dictionary Depending on mode, dictionary will be opened or created.\n\nReturns:\n\n* NfcDict dictionary instance\n\n# Arguments\n\n* `path` - - dictionary path\n* `mode` - - NfcDictMode value\n* `key_size` - - size of dictionary keys in bytes\n\n"]
    pub fn nfc_dict_alloc(
        path: *const core::ffi::c_char,
        mode: NfcDictMode,
        key_size: usize,
    ) -> *mut NfcDict;
}
extern "C" {
    #[doc = "Close dictionary\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n\n"]
    pub fn nfc_dict_free(instance: *mut NfcDict);
}
extern "C" {
    #[doc = "Get total number of keys in dictionary\n\nReturns:\n\n* total number of keys in dictionary\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n\n"]
    pub fn nfc_dict_get_total_keys(instance: *mut NfcDict) -> u32;
}
extern "C" {
    #[doc = "Rewind dictionary\n\nReturns:\n\n* true if rewind was successful, false otherwise\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n\n"]
    pub fn nfc_dict_rewind(instance: *mut NfcDict) -> bool;
}
extern "C" {
    #[doc = "Check if key is present in dictionary\n\nReturns:\n\n* true if key is present, false otherwise\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n* `key` - - key to check\n* `key_size` - - size of key in bytes\n\n"]
    pub fn nfc_dict_is_key_present(instance: *mut NfcDict, key: *const u8, key_size: usize)
        -> bool;
}
extern "C" {
    #[doc = "Get next key from dictionary This function will return next key from dictionary. If there are no more keys, it will return false, and nfc_dict_rewind() should be called.\n\nReturns:\n\n* true if key was successfully retrieved, false otherwise\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n* `key` - - buffer to store key\n* `key_size` - - size of key in bytes\n\n"]
    pub fn nfc_dict_get_next_key(instance: *mut NfcDict, key: *mut u8, key_size: usize) -> bool;
}
extern "C" {
    #[doc = "Add key to dictionary\n\nReturns:\n\n* true if key was successfully added, false otherwise\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n* `key` - - key to add\n* `key_size` - - size of key in bytes\n\n"]
    pub fn nfc_dict_add_key(instance: *mut NfcDict, key: *const u8, key_size: usize) -> bool;
}
extern "C" {
    #[doc = "Delete key from dictionary\n\nReturns:\n\n* true if key was successfully deleted, false otherwise\n\n# Arguments\n\n* `instance` - - NfcDict dictionary instance\n* `key` - - key to delete\n* `key_size` - - size of key in bytes\n\n"]
    pub fn nfc_dict_delete_key(instance: *mut NfcDict, key: *const u8, key_size: usize) -> bool;
}
extern "C" {
    pub fn nfc_util_num2bytes(src: u64, len: u8, dest: *mut u8);
}
extern "C" {
    pub fn nfc_util_bytes2num(src: *const u8, len: u8) -> u64;
}
extern "C" {
    pub fn nfc_util_even_parity32(data: u32) -> u8;
}
extern "C" {
    pub fn nfc_util_odd_parity8(data: u8) -> u8;
}
extern "C" {
    pub fn nfc_util_odd_parity(src: *const u8, dst: *mut u8, len: u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Nfc {
    _unused: [u8; 0],
}
#[doc = "User code explicitly aborted the current operation.\n\n"]
pub const NfcEventType_NfcEventTypeUserAbort: NfcEventType = 0;
#[doc = "Reader's field was detected by the NFC hardware.\n\n"]
pub const NfcEventType_NfcEventTypeFieldOn: NfcEventType = 1;
#[doc = "Reader's field was lost.\n\n"]
pub const NfcEventType_NfcEventTypeFieldOff: NfcEventType = 2;
#[doc = "Data transmission has started.\n\n"]
pub const NfcEventType_NfcEventTypeTxStart: NfcEventType = 3;
#[doc = "Data transmission has ended.\n\n"]
pub const NfcEventType_NfcEventTypeTxEnd: NfcEventType = 4;
#[doc = "Data reception has started.\n\n"]
pub const NfcEventType_NfcEventTypeRxStart: NfcEventType = 5;
#[doc = "Data reception has ended.\n\n"]
pub const NfcEventType_NfcEventTypeRxEnd: NfcEventType = 6;
#[doc = "The listener has been activated by the reader.\n\n"]
pub const NfcEventType_NfcEventTypeListenerActivated: NfcEventType = 7;
#[doc = "The card has been activated by the poller.\n\n"]
pub const NfcEventType_NfcEventTypePollerReady: NfcEventType = 8;
#[doc = "Enumeration of possible Nfc event types.\n\nNot all technologies implement all events (this is due to hardware limitations).\n\n"]
pub type NfcEventType = core::ffi::c_uchar;
#[doc = "Nfc event data structure.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcEventData {
    #[doc = "Pointer to the received data buffer.\n\n"]
    pub buffer: *mut BitBuffer,
}
#[test]
fn bindgen_test_layout_NfcEventData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcEventData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcEventData>(),
        4usize,
        concat!("Size of: ", stringify!(NfcEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcEventData),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = "Nfc event structure.\n\nUpon emission of an event, an instance of this struct will be passed to the callback.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcEvent {
    #[doc = "Type of the emitted event.\n\n"]
    pub type_: NfcEventType,
    #[doc = "Event-specific data.\n\n"]
    pub data: NfcEventData,
}
#[test]
fn bindgen_test_layout_NfcEvent() {
    const UNINIT: ::core::mem::MaybeUninit<NfcEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcEvent>(),
        8usize,
        concat!("Size of: ", stringify!(NfcEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "Continue operation normally.\n\n"]
pub const NfcCommand_NfcCommandContinue: NfcCommand = 0;
#[doc = "Reset the current state.\n\n"]
pub const NfcCommand_NfcCommandReset: NfcCommand = 1;
#[doc = "Stop the current operation.\n\n"]
pub const NfcCommand_NfcCommandStop: NfcCommand = 2;
#[doc = "Switch Nfc hardware to low-power mode.\n\n"]
pub const NfcCommand_NfcCommandSleep: NfcCommand = 3;
#[doc = "Enumeration of possible Nfc commands.\n\nThe event callback must return one of these to determine the next action.\n\n"]
pub type NfcCommand = core::ffi::c_uchar;
#[doc = "Nfc event callback type.\n\nA function of this type must be passed as the callback parameter upon start of a an Nfc instance.\n\nReturns:\n\n* command which the event producer must execute.\n\n# Arguments\n\n* `[in]` - event Nfc event, passed by value, complete with protocol type and data.\n* `[in,out]` - context pointer to the user-specific context (set when starting an Nfc instance).\n\n"]
pub type NfcEventCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcEvent, context: *mut core::ffi::c_void) -> NfcCommand,
>;
#[doc = "Configure the Nfc instance as a poller.\n\n"]
pub const NfcMode_NfcModePoller: NfcMode = 0;
#[doc = "Configure the Nfc instance as a listener.\n\n"]
pub const NfcMode_NfcModeListener: NfcMode = 1;
#[doc = "Operating mode count. Internal use.\n\n"]
pub const NfcMode_NfcModeNum: NfcMode = 2;
#[doc = "Enumeration of possible operating modes.\n\nNot all technologies implement the listener operating mode.\n\n"]
pub type NfcMode = core::ffi::c_uchar;
#[doc = "Configure the Nfc instance to use the ISO14443-3A technology.\n\n"]
pub const NfcTech_NfcTechIso14443a: NfcTech = 0;
#[doc = "Configure the Nfc instance to use the ISO14443-3B technology.\n\n"]
pub const NfcTech_NfcTechIso14443b: NfcTech = 1;
#[doc = "Configure the Nfc instance to use the ISO15693 technology.\n\n"]
pub const NfcTech_NfcTechIso15693: NfcTech = 2;
#[doc = "Configure the Nfc instance to use the FeliCa technology.\n\n"]
pub const NfcTech_NfcTechFelica: NfcTech = 3;
#[doc = "Technologies count. Internal use.\n\n"]
pub const NfcTech_NfcTechNum: NfcTech = 4;
#[doc = "Enumeration of available technologies.\n\n"]
pub type NfcTech = core::ffi::c_uchar;
#[doc = "No error has occurred.\n\n"]
pub const NfcError_NfcErrorNone: NfcError = 0;
#[doc = "An unknown error has occured on the lower level.\n\n"]
pub const NfcError_NfcErrorInternal: NfcError = 1;
#[doc = "Operation is taking too long (e.g. card does not respond).\n\n"]
pub const NfcError_NfcErrorTimeout: NfcError = 2;
#[doc = "An incomplete data frame has been received.\n\n"]
pub const NfcError_NfcErrorIncompleteFrame: NfcError = 3;
#[doc = "Data has not been parsed due to wrong/unknown format.\n\n"]
pub const NfcError_NfcErrorDataFormat: NfcError = 4;
#[doc = "Enumeration of possible Nfc error codes.\n\n"]
pub type NfcError = core::ffi::c_uchar;
extern "C" {
    #[doc = "Allocate an Nfc instance.\n\nWill exclusively take over the NFC HAL until deleted.\n\nReturns:\n\n* pointer to the allocated Nfc instance.\n\n"]
    pub fn nfc_alloc() -> *mut Nfc;
}
extern "C" {
    #[doc = "Delete an Nfc instance.\n\nWill release the NFC HAL lock, making it available for use by others.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be deleted.\n\n"]
    pub fn nfc_free(instance: *mut Nfc);
}
extern "C" {
    #[doc = "Configure the Nfc instance to work in a particular mode.\n\nNot all technologies implement the listener operating mode.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be configured.\n* `mode` - [Direction: In] required operating mode.\n* `tech` - [Direction: In] required technology configuration.\n\n"]
    pub fn nfc_config(instance: *mut Nfc, mode: NfcMode, tech: NfcTech);
}
extern "C" {
    #[doc = "Set poller frame delay time.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `fdt_poll_fc` - [Direction: In] frame delay time, in carrier cycles.\n\n"]
    pub fn nfc_set_fdt_poll_fc(instance: *mut Nfc, fdt_poll_fc: u32);
}
extern "C" {
    #[doc = "Set listener frame delay time.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `fdt_listen_fc` - [Direction: In] frame delay time, in carrier cycles.\n\n"]
    pub fn nfc_set_fdt_listen_fc(instance: *mut Nfc, fdt_listen_fc: u32);
}
extern "C" {
    #[doc = "Set mask receive time.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `mask_rx_time` - [Direction: In] mask receive time, in carrier cycles.\n\n"]
    pub fn nfc_set_mask_receive_time_fc(instance: *mut Nfc, mask_rx_time_fc: u32);
}
extern "C" {
    #[doc = "Set frame delay time.\n\nFrame delay time is the minimum time between two consecutive poll frames.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `fdt_poll_poll_us` - [Direction: In] frame delay time, in microseconds.\n\n"]
    pub fn nfc_set_fdt_poll_poll_us(instance: *mut Nfc, fdt_poll_poll_us: u32);
}
extern "C" {
    #[doc = "Set guard time.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be modified.\n* `guard_time_us` - [Direction: In] guard time, in microseconds.\n\n"]
    pub fn nfc_set_guard_time_us(instance: *mut Nfc, guard_time_us: u32);
}
extern "C" {
    #[doc = "Start the Nfc instance.\n\nThe instance must be configured to work with a specific technology in a specific operating mode with a nfc_config() call before starting.\nOnce started, the user code will be receiving events through the provided callback which must handle them according to the logic required.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be started.\n* `callback` - [Direction: In] pointer to a user-defined callback function which will receive events.\n* `context` - [Direction: In] pointer to a user-specific context (will be passed to the callback).\n\n"]
    pub fn nfc_start(
        instance: *mut Nfc,
        callback: NfcEventCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop Nfc instance.\n\nThe instance can only be stopped if it is running.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be stopped.\n\n"]
    pub fn nfc_stop(instance: *mut Nfc);
}
extern "C" {
    #[doc = "Transmit and receive a data frame in poller mode.\n\nThe rx_buffer will be filled with any data received as a response to data sent from tx_buffer, with a timeout defined by the fwt parameter.\nThe data being transmitted and received may be either bit- or byte-oriented. It shall not contain any technology-specific sequences as start or stop bits and/or other special symbols, as this is handled on the underlying HAL level.\nMust ONLY be used inside the callback function.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `tx_buffer` - [Direction: In] pointer to the buffer containing the data to be transmitted.\n* `rx_buffer` - [Direction: In, Out] pointer to the buffer to be filled with received data.\n* `fwt` - [Direction: In] frame wait time (response timeout), in carrier cycles.\n\n"]
    pub fn nfc_poller_trx(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Transmit a data frame in listener mode.\n\nUsed to transmit a response to the reader request in listener mode.\nThe data being transmitted may be either bit- or byte-oriented. It shall not contain any technology-specific sequences as start or stop bits and/or other special symbols, as this is handled on the underlying HAL level.\nMust ONLY be used inside the callback function.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `tx_buffer` - [Direction: In] pointer to the buffer containing the data to be transmitted.\n\n"]
    pub fn nfc_listener_tx(instance: *mut Nfc, tx_buffer: *const BitBuffer) -> NfcError;
}
pub const NfcIso14443aShortFrame_NfcIso14443aShortFrameSensReq: NfcIso14443aShortFrame = 0;
pub const NfcIso14443aShortFrame_NfcIso14443aShortFrameAllReqa: NfcIso14443aShortFrame = 1;
#[doc = "Enumeration of possible ISO14443-3A short frame types.\n\n"]
pub type NfcIso14443aShortFrame = core::ffi::c_uchar;
extern "C" {
    #[doc = "Transmit an ISO14443-3A short frame and receive the response in poller mode.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `frame` - [Direction: In] type of short frame to be sent.\n* `rx_buffer` - [Direction: In, Out] pointer to the buffer to be filled with received data.\n* `fwt` - [Direction: In] frame wait time (response timeout), in carrier cycles.\n\n"]
    pub fn nfc_iso14443a_poller_trx_short_frame(
        instance: *mut Nfc,
        frame: NfcIso14443aShortFrame,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Transmit an ISO14443-3A SDD frame and receive the response in poller mode.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `tx_buffer` - [Direction: In] pointer to the buffer containing the data to be transmitted.\n* `rx_buffer` - [Direction: In, Out] pointer to the buffer to be filled with received data.\n* `fwt` - [Direction: In] frame wait time (response timeout), in carrier cycles.\n\n"]
    pub fn nfc_iso14443a_poller_trx_sdd_frame(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Transmit an ISO14443-3A data frame with custom parity bits and receive the response in poller mode.\n\nSame as nfc_poller_trx(), but uses the parity bits provided by the user code instead of calculating them automatically.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `tx_buffer` - [Direction: In] pointer to the buffer containing the data to be transmitted.\n* `rx_buffer` - [Direction: In, Out] pointer to the buffer to be filled with received data.\n* `fwt` - [Direction: In] frame wait time (response timeout), in carrier cycles.\n\n"]
    pub fn nfc_iso14443a_poller_trx_custom_parity(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Transmit an ISO14443-3A frame with custom parity bits in listener mode.\n\nSame as nfc_listener_tx(), but uses the parity bits provided by the user code instead of calculating them automatically.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be used in the transaction.\n* `tx_buffer` - [Direction: In] pointer to the buffer containing the data to be transmitted.\n\n"]
    pub fn nfc_iso14443a_listener_tx_custom_parity(
        instance: *mut Nfc,
        tx_buffer: *const BitBuffer,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Set ISO14443-3A collision resolution parameters in listener mode.\n\nConfigures the NFC hardware for automatic collision resolution.\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be configured.\n* `uid` - [Direction: In] pointer to a byte array containing the UID.\n* `uid_len` - [Direction: In] UID length in bytes (must be supported by the protocol).\n* `atqa` - [Direction: In] ATQA byte value.\n* `sak` - [Direction: In] SAK byte value.\n\n"]
    pub fn nfc_iso14443a_listener_set_col_res_data(
        instance: *mut Nfc,
        uid: *mut u8,
        uid_len: u8,
        atqa: *mut u8,
        sak: u8,
    ) -> NfcError;
}
extern "C" {
    #[doc = "Send ISO15693 Start of Frame pattern in listener mode\n\nReturns:\n\n* NfcErrorNone on success, any other error code on failure.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be configured.\n\n"]
    pub fn nfc_iso15693_listener_tx_sof(instance: *mut Nfc) -> NfcError;
}
#[doc = "Generic Nfc instance type.\n\nMust be cast to a concrete type before use. Depending on the context, a pointer of this type may point to an object of the following types:\n* Nfc type,\n* Concrete poller type,\n* Concrete listener type.\n\n"]
pub type NfcGenericInstance = core::ffi::c_void;
#[doc = "Generic Nfc event data type.\n\nMust be cast to a concrete type before use. Usually, it will be the protocol-specific event type.\n\n"]
pub type NfcGenericEventData = core::ffi::c_void;
#[doc = "Generic Nfc event type.\n\nA generic Nfc event contains a protocol identifier, can be used to determine the remaing fields' type.\nIf the value of the protocol field is NfcProtocolInvalid, then it means that the event was emitted from an Nfc instance, otherwise it originated from a concrete poller or listener instance.\nThe event_data field is protocol-specific and should be cast to the appropriate type before use.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcGenericEvent {
    #[doc = "Protocol identifier of the instance that produced the event.\n\n"]
    pub protocol: NfcProtocol,
    #[doc = "Pointer to the protocol-specific instance that produced the event.\n\n"]
    pub instance: *mut NfcGenericInstance,
    #[doc = "Pointer to the protocol-specific event.\n\n"]
    pub event_data: *mut NfcGenericEventData,
}
#[test]
fn bindgen_test_layout_NfcGenericEvent() {
    const UNINIT: ::core::mem::MaybeUninit<NfcGenericEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcGenericEvent>(),
        12usize,
        concat!("Size of: ", stringify!(NfcGenericEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcGenericEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcGenericEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcGenericEvent),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcGenericEvent),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcGenericEvent),
            "::",
            stringify!(event_data)
        )
    );
}
#[doc = "Generic Nfc event callback type.\n\nA function of this type must be passed as the callback parameter upon start of a poller, listener or Nfc instance.\n\nReturns:\n\n* the command which the event producer must execute.\n\n# Arguments\n\n* `[in]` - event Nfc generic event, passed by value, complete with protocol type and data.\n* `[in,out]` - context pointer to the user-specific context (set when starting a poller/listener instance).\n\n"]
pub type NfcGenericCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcGenericEvent, context: *mut core::ffi::c_void) -> NfcCommand,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcListener {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate an NfcListener instance.\n\n[`nfc.h`]\n\nReturns:\n\n* pointer to an allocated instance.\n\n# Arguments\n\n* `nfc` - [Direction: In] pointer to an Nfc instance.\n* `protocol` - [Direction: In] identifier of the protocol to be used.\n* `data` - [Direction: In] pointer to the data to use during emulation.\n\n"]
    pub fn nfc_listener_alloc(
        nfc: *mut Nfc,
        protocol: NfcProtocol,
        data: *const NfcDeviceData,
    ) -> *mut NfcListener;
}
extern "C" {
    #[doc = "Delete an NfcListener instance.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be deleted.\n\n"]
    pub fn nfc_listener_free(instance: *mut NfcListener);
}
extern "C" {
    #[doc = "Start an NfcListener instance.\n\nThe callback logic is protocol-specific, so it cannot be described here in detail. However, the callback return value ALWAYS determines what the listener should do next: to continue whatever it was doing prior to the callback run or to stop.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be started.\n* `callback` - [Direction: In] pointer to a user-defined callback function which will receive events.\n* `context` - [Direction: In] pointer to a user-specific context (will be passed to the callback).\n\n"]
    pub fn nfc_listener_start(
        instance: *mut NfcListener,
        callback: NfcGenericCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop an NfcListener instance.\n\nThe emulation process can be stopped explicitly (the other way is via the callback return value).\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be stopped.\n\n"]
    pub fn nfc_listener_stop(instance: *mut NfcListener);
}
extern "C" {
    #[doc = "Get the protocol identifier an NfcListener instance was created with.\n\nReturns:\n\n* identifier of the protocol used by the instance.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn nfc_listener_get_protocol(instance: *const NfcListener) -> NfcProtocol;
}
extern "C" {
    #[doc = "Get the data that was that was provided for emulation.\n\nThe protocol identifier passed as the protocol parameter MUST match the one stored in the instance, otherwise a crash will occur. This is to improve type safety.\n\nReturns:\n\n* pointer to the NFC device data.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n* `protocol` - [Direction: In] assumed protocol identifier of the data to be retrieved.\n\n"]
    pub fn nfc_listener_get_data(
        instance: *const NfcListener,
        protocol: NfcProtocol,
    ) -> *const NfcDeviceData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcPoller {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate an NfcPoller instance.\n\n[`nfc.h`]\n\nReturns:\n\n* pointer to an allocated instance.\n\n# Arguments\n\n* `nfc` - [Direction: In] pointer to an Nfc instance.\n* `protocol` - [Direction: In] identifier of the protocol to be used.\n\n"]
    pub fn nfc_poller_alloc(nfc: *mut Nfc, protocol: NfcProtocol) -> *mut NfcPoller;
}
extern "C" {
    #[doc = "Delete an NfcPoller instance.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be deleted.\n\n"]
    pub fn nfc_poller_free(instance: *mut NfcPoller);
}
extern "C" {
    #[doc = "Start an NfcPoller instance.\n\nThe callback logic is protocol-specific, so it cannot be described here in detail. However, the callback return value ALWAYS determines what the poller should do next: to continue whatever it was doing prior to the callback run or to stop.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be started.\n* `callback` - [Direction: In] pointer to a user-defined callback function which will receive events.\n* `context` - [Direction: In] pointer to a user-specific context (will be passed to the callback).\n\n"]
    pub fn nfc_poller_start(
        instance: *mut NfcPoller,
        callback: NfcGenericCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop an NfcPoller instance.\n\nThe reading process can be stopped explicitly (the other way is via the callback return value).\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to be stopped.\n\n"]
    pub fn nfc_poller_stop(instance: *mut NfcPoller);
}
extern "C" {
    #[doc = "Detect whether there is a card supporting a particular protocol in the vicinity.\n\nThe behaviour of this function is protocol-defined, in general, it will do whatever is necessary to determine whether a card supporting the current protocol is in the vicinity and whether it is functioning normally.\nIt is used automatically inside NfcScanner, so there is usually no need to call it explicitly.\n[`nfc_scanner.h`]\n\nReturns:\n\n* true if a supported card was detected, false otherwise.\n\n# Arguments\n\n* `instance` - [Direction: Out] pointer to the instance to perform the detection with.\n\n"]
    pub fn nfc_poller_detect(instance: *mut NfcPoller) -> bool;
}
extern "C" {
    #[doc = "Get the protocol identifier an NfcPoller instance was created with.\n\nReturns:\n\n* identifier of the protocol used by the instance.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn nfc_poller_get_protocol(instance: *const NfcPoller) -> NfcProtocol;
}
extern "C" {
    #[doc = "Get the data that was that was gathered during the reading process.\n\nReturns:\n\n* pointer to the NFC device data.\n\n# Arguments\n\n* `instance` - [Direction: In] pointer to the instance to be queried.\n\n"]
    pub fn nfc_poller_get_data(instance: *const NfcPoller) -> *const NfcDeviceData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScanner {
    _unused: [u8; 0],
}
#[doc = "One or more protocols have been detected.\n\n"]
pub const NfcScannerEventType_NfcScannerEventTypeDetected: NfcScannerEventType = 0;
#[doc = "Event type passed to the user callback.\n\n"]
pub type NfcScannerEventType = core::ffi::c_uchar;
#[doc = "Event data passed to the user callback.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScannerEventData {
    #[doc = "Number of detected protocols (one or more).\n\n"]
    pub protocol_num: usize,
    #[doc = "Pointer to the array of detected protocol identifiers.\n\n"]
    pub protocols: *mut NfcProtocol,
}
#[test]
fn bindgen_test_layout_NfcScannerEventData() {
    const UNINIT: ::core::mem::MaybeUninit<NfcScannerEventData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcScannerEventData>(),
        8usize,
        concat!("Size of: ", stringify!(NfcScannerEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcScannerEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcScannerEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcScannerEventData),
            "::",
            stringify!(protocol_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocols) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcScannerEventData),
            "::",
            stringify!(protocols)
        )
    );
}
#[doc = "Event passed to the user callback.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NfcScannerEvent {
    #[doc = "Type of event. Determines how the data must be handled.\n\n"]
    pub type_: NfcScannerEventType,
    #[doc = "Event-specific data. Handled accordingly to the even type.\n\n"]
    pub data: NfcScannerEventData,
}
#[test]
fn bindgen_test_layout_NfcScannerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<NfcScannerEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NfcScannerEvent>(),
        12usize,
        concat!("Size of: ", stringify!(NfcScannerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<NfcScannerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(NfcScannerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcScannerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NfcScannerEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "User callback function signature.\n\nA function with such signature must be provided by the user upon calling nfc_scanner_start().\n\n# Arguments\n\n* `event` - [Direction: In] occurred event, complete with type and data.\n* `context` - [Direction: In] pointer to the context data provided in nfc_scanner_start() call.\n\n"]
pub type NfcScannerCallback = ::core::option::Option<
    unsafe extern "C" fn(event: NfcScannerEvent, context: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = "Allocate an NfcScanner instance.\n\n[`nfc.h`]\n\nReturns:\n\n* pointer to the allocated NfcScanner instance.\n\n# Arguments\n\n* `nfc` - [Direction: In] pointer to an Nfc instance.\n\n"]
    pub fn nfc_scanner_alloc(nfc: *mut Nfc) -> *mut NfcScanner;
}
extern "C" {
    #[doc = "Delete an NfcScanner instance.\n\n# Arguments\n\n* `pointer` - [Direction: Out] to the instance to be deleted.\n\n"]
    pub fn nfc_scanner_free(instance: *mut NfcScanner);
}
extern "C" {
    #[doc = "Start an NfcScanner.\n\n# Arguments\n\n* `pointer` - [Direction: Out] to the instance to be started.\n* `callback` - [Direction: In] pointer to the callback function (will be called upon a detection event).\n* `context` - [Direction: In] pointer to the caller-specific context (will be passed to the callback).\n\n"]
    pub fn nfc_scanner_start(
        instance: *mut NfcScanner,
        callback: NfcScannerCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Stop an NfcScanner.\n\n# Arguments\n\n* `pointer` - [Direction: Out] to the instance to be stopped.\n\n"]
    pub fn nfc_scanner_stop(instance: *mut NfcScanner);
}
pub const Iso14443_3aError_Iso14443_3aErrorNone: Iso14443_3aError = 0;
pub const Iso14443_3aError_Iso14443_3aErrorNotPresent: Iso14443_3aError = 1;
pub const Iso14443_3aError_Iso14443_3aErrorColResFailed: Iso14443_3aError = 2;
pub const Iso14443_3aError_Iso14443_3aErrorBufferOverflow: Iso14443_3aError = 3;
pub const Iso14443_3aError_Iso14443_3aErrorCommunication: Iso14443_3aError = 4;
pub const Iso14443_3aError_Iso14443_3aErrorFieldOff: Iso14443_3aError = 5;
pub const Iso14443_3aError_Iso14443_3aErrorWrongCrc: Iso14443_3aError = 6;
pub const Iso14443_3aError_Iso14443_3aErrorTimeout: Iso14443_3aError = 7;
pub type Iso14443_3aError = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aData {
    pub uid: [u8; 10usize],
    pub uid_len: u8,
    pub atqa: [u8; 2usize],
    pub sak: u8,
}
#[test]
fn bindgen_test_layout_Iso14443_3aData() {
    const UNINIT: ::core::mem::MaybeUninit<Iso14443_3aData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Iso14443_3aData>(),
        14usize,
        concat!("Size of: ", stringify!(Iso14443_3aData))
    );
    assert_eq!(
        ::core::mem::align_of::<Iso14443_3aData>(),
        1usize,
        concat!("Alignment of ", stringify!(Iso14443_3aData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso14443_3aData),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid_len) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso14443_3aData),
            "::",
            stringify!(uid_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atqa) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso14443_3aData),
            "::",
            stringify!(atqa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sak) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso14443_3aData),
            "::",
            stringify!(sak)
        )
    );
}
extern "C" {
    pub fn iso14443_3a_alloc() -> *mut Iso14443_3aData;
}
extern "C" {
    pub fn iso14443_3a_free(data: *mut Iso14443_3aData);
}
extern "C" {
    pub fn iso14443_3a_reset(data: *mut Iso14443_3aData);
}
extern "C" {
    pub fn iso14443_3a_copy(data: *mut Iso14443_3aData, other: *const Iso14443_3aData);
}
extern "C" {
    pub fn iso14443_3a_verify(data: *mut Iso14443_3aData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn iso14443_3a_load(
        data: *mut Iso14443_3aData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3a_save(data: *const Iso14443_3aData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn iso14443_3a_is_equal(
        data: *const Iso14443_3aData,
        other: *const Iso14443_3aData,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3a_get_device_name(
        data: *const Iso14443_3aData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn iso14443_3a_get_uid(data: *const Iso14443_3aData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn iso14443_3a_set_uid(data: *mut Iso14443_3aData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn iso14443_3a_get_base_data(data: *const Iso14443_3aData) -> *mut Iso14443_3aData;
}
extern "C" {
    pub fn iso14443_3a_get_cuid(data: *const Iso14443_3aData) -> u32;
}
extern "C" {
    pub fn iso14443_3a_supports_iso14443_4(data: *const Iso14443_3aData) -> bool;
}
extern "C" {
    pub fn iso14443_3a_get_sak(data: *const Iso14443_3aData) -> u8;
}
extern "C" {
    pub fn iso14443_3a_get_atqa(data: *const Iso14443_3aData, atqa: *mut u8);
}
extern "C" {
    pub fn iso14443_3a_set_sak(data: *mut Iso14443_3aData, sak: u8);
}
extern "C" {
    pub fn iso14443_3a_set_atqa(data: *mut Iso14443_3aData, atqa: *const u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3aPoller {
    _unused: [u8; 0],
}
extern "C" {
    pub fn iso14443_3a_poller_txrx(
        instance: *mut Iso14443_3aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> Iso14443_3aError;
}
extern "C" {
    pub fn iso14443_3a_poller_send_standard_frame(
        instance: *mut Iso14443_3aPoller,
        tx_buffer: *const BitBuffer,
        rx_buffer: *mut BitBuffer,
        fwt: u32,
    ) -> Iso14443_3aError;
}
extern "C" {
    pub fn iso14443_3a_poller_read(
        nfc: *mut Nfc,
        iso14443_3a_data: *mut Iso14443_3aData,
    ) -> Iso14443_3aError;
}
pub const Iso14443_3bBitRate_Iso14443_3bBitRateBoth106Kbit: Iso14443_3bBitRate = 0;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePiccToPcd212Kbit: Iso14443_3bBitRate = 1;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePiccToPcd424Kbit: Iso14443_3bBitRate = 2;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePiccToPcd848Kbit: Iso14443_3bBitRate = 3;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePcdToPicc212Kbit: Iso14443_3bBitRate = 4;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePcdToPicc424Kbit: Iso14443_3bBitRate = 5;
pub const Iso14443_3bBitRate_Iso14443_3bBitRatePcdToPicc848Kbit: Iso14443_3bBitRate = 6;
pub type Iso14443_3bBitRate = core::ffi::c_uchar;
pub const Iso14443_3bFrameOption_Iso14443_3bFrameOptionNad: Iso14443_3bFrameOption = 0;
pub const Iso14443_3bFrameOption_Iso14443_3bFrameOptionCid: Iso14443_3bFrameOption = 1;
pub type Iso14443_3bFrameOption = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_3bData {
    _unused: [u8; 0],
}
extern "C" {
    pub fn iso14443_3b_alloc() -> *mut Iso14443_3bData;
}
extern "C" {
    pub fn iso14443_3b_free(data: *mut Iso14443_3bData);
}
extern "C" {
    pub fn iso14443_3b_reset(data: *mut Iso14443_3bData);
}
extern "C" {
    pub fn iso14443_3b_copy(data: *mut Iso14443_3bData, other: *const Iso14443_3bData);
}
extern "C" {
    pub fn iso14443_3b_verify(data: *mut Iso14443_3bData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn iso14443_3b_load(
        data: *mut Iso14443_3bData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3b_save(data: *const Iso14443_3bData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn iso14443_3b_is_equal(
        data: *const Iso14443_3bData,
        other: *const Iso14443_3bData,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3b_get_device_name(
        data: *const Iso14443_3bData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn iso14443_3b_get_uid(data: *const Iso14443_3bData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn iso14443_3b_set_uid(data: *mut Iso14443_3bData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn iso14443_3b_get_base_data(data: *const Iso14443_3bData) -> *mut Iso14443_3bData;
}
extern "C" {
    pub fn iso14443_3b_supports_iso14443_4(data: *const Iso14443_3bData) -> bool;
}
extern "C" {
    pub fn iso14443_3b_supports_bit_rate(
        data: *const Iso14443_3bData,
        bit_rate: Iso14443_3bBitRate,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3b_supports_frame_option(
        data: *const Iso14443_3bData,
        option: Iso14443_3bFrameOption,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_3b_get_application_data(
        data: *const Iso14443_3bData,
        data_size: *mut usize,
    ) -> *const u8;
}
extern "C" {
    pub fn iso14443_3b_get_frame_size_max(data: *const Iso14443_3bData) -> u16;
}
extern "C" {
    pub fn iso14443_3b_get_fwt_fc_max(data: *const Iso14443_3bData) -> u32;
}
pub const Iso14443_4aBitRate_Iso14443_4aBitRateBoth106Kbit: Iso14443_4aBitRate = 0;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePiccToPcd212Kbit: Iso14443_4aBitRate = 1;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePiccToPcd424Kbit: Iso14443_4aBitRate = 2;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePiccToPcd848Kbit: Iso14443_4aBitRate = 3;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePcdToPicc212Kbit: Iso14443_4aBitRate = 4;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePcdToPicc424Kbit: Iso14443_4aBitRate = 5;
pub const Iso14443_4aBitRate_Iso14443_4aBitRatePcdToPicc848Kbit: Iso14443_4aBitRate = 6;
pub type Iso14443_4aBitRate = core::ffi::c_uchar;
pub const Iso14443_4aFrameOption_Iso14443_4aFrameOptionNad: Iso14443_4aFrameOption = 0;
pub const Iso14443_4aFrameOption_Iso14443_4aFrameOptionCid: Iso14443_4aFrameOption = 1;
pub type Iso14443_4aFrameOption = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4aData {
    _unused: [u8; 0],
}
extern "C" {
    pub fn iso14443_4a_alloc() -> *mut Iso14443_4aData;
}
extern "C" {
    pub fn iso14443_4a_free(data: *mut Iso14443_4aData);
}
extern "C" {
    pub fn iso14443_4a_reset(data: *mut Iso14443_4aData);
}
extern "C" {
    pub fn iso14443_4a_copy(data: *mut Iso14443_4aData, other: *const Iso14443_4aData);
}
extern "C" {
    pub fn iso14443_4a_verify(data: *mut Iso14443_4aData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn iso14443_4a_load(
        data: *mut Iso14443_4aData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_4a_save(data: *const Iso14443_4aData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn iso14443_4a_is_equal(
        data: *const Iso14443_4aData,
        other: *const Iso14443_4aData,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_4a_get_device_name(
        data: *const Iso14443_4aData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn iso14443_4a_get_uid(data: *const Iso14443_4aData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn iso14443_4a_set_uid(data: *mut Iso14443_4aData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn iso14443_4a_get_base_data(data: *const Iso14443_4aData) -> *mut Iso14443_3aData;
}
extern "C" {
    pub fn iso14443_4a_get_frame_size_max(data: *const Iso14443_4aData) -> u16;
}
extern "C" {
    pub fn iso14443_4a_get_fwt_fc_max(data: *const Iso14443_4aData) -> u32;
}
extern "C" {
    pub fn iso14443_4a_get_historical_bytes(
        data: *const Iso14443_4aData,
        count: *mut u32,
    ) -> *const u8;
}
extern "C" {
    pub fn iso14443_4a_supports_bit_rate(
        data: *const Iso14443_4aData,
        bit_rate: Iso14443_4aBitRate,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_4a_supports_frame_option(
        data: *const Iso14443_4aData,
        option: Iso14443_4aFrameOption,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso14443_4bData {
    _unused: [u8; 0],
}
extern "C" {
    pub fn iso14443_4b_alloc() -> *mut Iso14443_4bData;
}
extern "C" {
    pub fn iso14443_4b_free(data: *mut Iso14443_4bData);
}
extern "C" {
    pub fn iso14443_4b_reset(data: *mut Iso14443_4bData);
}
extern "C" {
    pub fn iso14443_4b_copy(data: *mut Iso14443_4bData, other: *const Iso14443_4bData);
}
extern "C" {
    pub fn iso14443_4b_verify(data: *mut Iso14443_4bData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn iso14443_4b_load(
        data: *mut Iso14443_4bData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_4b_save(data: *const Iso14443_4bData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn iso14443_4b_is_equal(
        data: *const Iso14443_4bData,
        other: *const Iso14443_4bData,
    ) -> bool;
}
extern "C" {
    pub fn iso14443_4b_get_device_name(
        data: *const Iso14443_4bData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn iso14443_4b_get_uid(data: *const Iso14443_4bData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn iso14443_4b_set_uid(data: *mut Iso14443_4bData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn iso14443_4b_get_base_data(data: *const Iso14443_4bData) -> *mut Iso14443_3bData;
}
pub const MfClassicError_MfClassicErrorNone: MfClassicError = 0;
pub const MfClassicError_MfClassicErrorNotPresent: MfClassicError = 1;
pub const MfClassicError_MfClassicErrorProtocol: MfClassicError = 2;
pub const MfClassicError_MfClassicErrorAuth: MfClassicError = 3;
pub const MfClassicError_MfClassicErrorTimeout: MfClassicError = 4;
pub type MfClassicError = core::ffi::c_uchar;
pub const MfClassicType_MfClassicTypeMini: MfClassicType = 0;
pub const MfClassicType_MfClassicType1k: MfClassicType = 1;
pub const MfClassicType_MfClassicType4k: MfClassicType = 2;
pub const MfClassicType_MfClassicTypeNum: MfClassicType = 3;
pub type MfClassicType = core::ffi::c_uchar;
pub const MfClassicAction_MfClassicActionDataRead: MfClassicAction = 0;
pub const MfClassicAction_MfClassicActionDataWrite: MfClassicAction = 1;
pub const MfClassicAction_MfClassicActionDataInc: MfClassicAction = 2;
pub const MfClassicAction_MfClassicActionDataDec: MfClassicAction = 3;
pub const MfClassicAction_MfClassicActionKeyARead: MfClassicAction = 4;
pub const MfClassicAction_MfClassicActionKeyAWrite: MfClassicAction = 5;
pub const MfClassicAction_MfClassicActionKeyBRead: MfClassicAction = 6;
pub const MfClassicAction_MfClassicActionKeyBWrite: MfClassicAction = 7;
pub const MfClassicAction_MfClassicActionACRead: MfClassicAction = 8;
pub const MfClassicAction_MfClassicActionACWrite: MfClassicAction = 9;
pub type MfClassicAction = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicBlock {
    pub data: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_MfClassicBlock() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicBlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicBlock>(),
        16usize,
        concat!("Size of: ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicBlock>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicBlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicBlock),
            "::",
            stringify!(data)
        )
    );
}
pub const MfClassicKeyType_MfClassicKeyTypeA: MfClassicKeyType = 0;
pub const MfClassicKeyType_MfClassicKeyTypeB: MfClassicKeyType = 1;
pub type MfClassicKeyType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicKey {
    pub data: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_MfClassicKey() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicKey>(),
        6usize,
        concat!("Size of: ", stringify!(MfClassicKey))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicKey>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicKey),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAccessBits {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfClassicAccessBits() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicAccessBits> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicAccessBits>(),
        4usize,
        concat!("Size of: ", stringify!(MfClassicAccessBits))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicAccessBits>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicAccessBits))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAccessBits),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicNt {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfClassicNt() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicNt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicNt>(),
        4usize,
        concat!("Size of: ", stringify!(MfClassicNt))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicNt>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicNt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicNt),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAt {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfClassicAt() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicAt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicAt>(),
        4usize,
        concat!("Size of: ", stringify!(MfClassicAt))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicAt>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicAt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAt),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicNr {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfClassicNr() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicNr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicNr>(),
        4usize,
        concat!("Size of: ", stringify!(MfClassicNr))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicNr>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicNr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicNr),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAr {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfClassicAr() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicAr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicAr>(),
        4usize,
        concat!("Size of: ", stringify!(MfClassicAr))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicAr>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicAr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAr),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicAuthContext {
    pub block_num: u8,
    pub key: MfClassicKey,
    pub key_type: MfClassicKeyType,
    pub nt: MfClassicNt,
    pub nr: MfClassicNr,
    pub ar: MfClassicAr,
    pub at: MfClassicAt,
}
#[test]
fn bindgen_test_layout_MfClassicAuthContext() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicAuthContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicAuthContext>(),
        24usize,
        concat!("Size of: ", stringify!(MfClassicAuthContext))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicAuthContext>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicAuthContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(block_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(key_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(nt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(ar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).at) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicAuthContext),
            "::",
            stringify!(at)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfClassicSectorTrailer {
    pub block: MfClassicBlock,
    pub __bindgen_anon_1: MfClassicSectorTrailer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicSectorTrailer__bindgen_ty_1 {
    pub key_a: MfClassicKey,
    pub access_bits: MfClassicAccessBits,
    pub key_b: MfClassicKey,
}
#[test]
fn bindgen_test_layout_MfClassicSectorTrailer__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicSectorTrailer__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicSectorTrailer__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MfClassicSectorTrailer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicSectorTrailer__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MfClassicSectorTrailer__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicSectorTrailer__bindgen_ty_1),
            "::",
            stringify!(key_a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).access_bits) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicSectorTrailer__bindgen_ty_1),
            "::",
            stringify!(access_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicSectorTrailer__bindgen_ty_1),
            "::",
            stringify!(key_b)
        )
    );
}
#[test]
fn bindgen_test_layout_MfClassicSectorTrailer() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicSectorTrailer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicSectorTrailer>(),
        16usize,
        concat!("Size of: ", stringify!(MfClassicSectorTrailer))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicSectorTrailer>(),
        1usize,
        concat!("Alignment of ", stringify!(MfClassicSectorTrailer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicSectorTrailer),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicDeviceKeys {
    pub key_a_mask: u64,
    pub key_a: [MfClassicKey; 40usize],
    pub key_b_mask: u64,
    pub key_b: [MfClassicKey; 40usize],
}
#[test]
fn bindgen_test_layout_MfClassicDeviceKeys() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicDeviceKeys> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicDeviceKeys>(),
        496usize,
        concat!("Size of: ", stringify!(MfClassicDeviceKeys))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicDeviceKeys>(),
        8usize,
        concat!("Alignment of ", stringify!(MfClassicDeviceKeys))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicDeviceKeys),
            "::",
            stringify!(key_a_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicDeviceKeys),
            "::",
            stringify!(key_a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b_mask) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicDeviceKeys),
            "::",
            stringify!(key_b_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicDeviceKeys),
            "::",
            stringify!(key_b)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfClassicData {
    pub iso14443_3a_data: *mut Iso14443_3aData,
    pub type_: MfClassicType,
    pub block_read_mask: [u32; 8usize],
    pub key_a_mask: u64,
    pub key_b_mask: u64,
    pub block: [MfClassicBlock; 256usize],
}
#[test]
fn bindgen_test_layout_MfClassicData() {
    const UNINIT: ::core::mem::MaybeUninit<MfClassicData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfClassicData>(),
        4152usize,
        concat!("Size of: ", stringify!(MfClassicData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfClassicData>(),
        8usize,
        concat!("Alignment of ", stringify!(MfClassicData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso14443_3a_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(iso14443_3a_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_read_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block_read_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_a_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_a_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_b_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(key_b_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfClassicData),
            "::",
            stringify!(block)
        )
    );
}
extern "C" {
    pub fn mf_classic_alloc() -> *mut MfClassicData;
}
extern "C" {
    pub fn mf_classic_free(data: *mut MfClassicData);
}
extern "C" {
    pub fn mf_classic_reset(data: *mut MfClassicData);
}
extern "C" {
    pub fn mf_classic_copy(data: *mut MfClassicData, other: *const MfClassicData);
}
extern "C" {
    pub fn mf_classic_verify(data: *mut MfClassicData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn mf_classic_load(data: *mut MfClassicData, ff: *mut FlipperFormat, version: u32) -> bool;
}
extern "C" {
    pub fn mf_classic_save(data: *const MfClassicData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn mf_classic_is_equal(data: *const MfClassicData, other: *const MfClassicData) -> bool;
}
extern "C" {
    pub fn mf_classic_get_device_name(
        data: *const MfClassicData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn mf_classic_get_uid(data: *const MfClassicData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn mf_classic_set_uid(data: *mut MfClassicData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn mf_classic_get_base_data(data: *const MfClassicData) -> *mut Iso14443_3aData;
}
extern "C" {
    pub fn mf_classic_get_total_sectors_num(type_: MfClassicType) -> u8;
}
extern "C" {
    pub fn mf_classic_get_total_block_num(type_: MfClassicType) -> u16;
}
extern "C" {
    pub fn mf_classic_get_first_block_num_of_sector(sector: u8) -> u8;
}
extern "C" {
    pub fn mf_classic_get_blocks_num_in_sector(sector: u8) -> u8;
}
extern "C" {
    pub fn mf_classic_get_sector_trailer_num_by_sector(sector: u8) -> u8;
}
extern "C" {
    pub fn mf_classic_get_sector_trailer_num_by_block(block: u8) -> u8;
}
extern "C" {
    pub fn mf_classic_get_sector_trailer_by_sector(
        data: *const MfClassicData,
        sector_num: u8,
    ) -> *mut MfClassicSectorTrailer;
}
extern "C" {
    pub fn mf_classic_is_sector_trailer(block: u8) -> bool;
}
extern "C" {
    pub fn mf_classic_get_sector_by_block(block: u8) -> u8;
}
extern "C" {
    pub fn mf_classic_block_to_value(
        block: *const MfClassicBlock,
        value: *mut i32,
        addr: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn mf_classic_value_to_block(value: i32, addr: u8, block: *mut MfClassicBlock);
}
extern "C" {
    pub fn mf_classic_is_key_found(
        data: *const MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
    ) -> bool;
}
extern "C" {
    pub fn mf_classic_set_key_found(
        data: *mut MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
        key: u64,
    );
}
extern "C" {
    pub fn mf_classic_set_key_not_found(
        data: *mut MfClassicData,
        sector_num: u8,
        key_type: MfClassicKeyType,
    );
}
extern "C" {
    pub fn mf_classic_is_block_read(data: *const MfClassicData, block_num: u8) -> bool;
}
extern "C" {
    pub fn mf_classic_set_block_read(
        data: *mut MfClassicData,
        block_num: u8,
        block_data: *mut MfClassicBlock,
    );
}
extern "C" {
    pub fn mf_classic_is_sector_read(data: *const MfClassicData, sector_num: u8) -> bool;
}
extern "C" {
    pub fn mf_classic_get_read_sectors_and_keys(
        data: *const MfClassicData,
        sectors_read: *mut u8,
        keys_found: *mut u8,
    );
}
extern "C" {
    pub fn mf_classic_is_card_read(data: *const MfClassicData) -> bool;
}
extern "C" {
    pub fn mf_classic_is_value_block(sec_tr: *mut MfClassicSectorTrailer, block_num: u8) -> bool;
}
extern "C" {
    pub fn mf_classic_is_allowed_access_data_block(
        sec_tr: *mut MfClassicSectorTrailer,
        block_num: u8,
        key_type: MfClassicKeyType,
        action: MfClassicAction,
    ) -> bool;
}
extern "C" {
    pub fn mf_classic_is_allowed_access(
        data: *mut MfClassicData,
        block_num: u8,
        key_type: MfClassicKeyType,
        action: MfClassicAction,
    ) -> bool;
}
extern "C" {
    pub fn mf_classic_poller_collect_nt(
        nfc: *mut Nfc,
        block_num: u8,
        key_type: MfClassicKeyType,
        nt: *mut MfClassicNt,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_auth(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicAuthContext,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_read_block(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_write_block(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: *mut MfClassicBlock,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_read_value(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        value: *mut i32,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_change_value(
        nfc: *mut Nfc,
        block_num: u8,
        key: *mut MfClassicKey,
        key_type: MfClassicKeyType,
        data: i32,
        new_value: *mut i32,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_detect_type(
        nfc: *mut Nfc,
        type_: *mut MfClassicType,
    ) -> MfClassicError;
}
extern "C" {
    pub fn mf_classic_poller_read(
        nfc: *mut Nfc,
        keys: *const MfClassicDeviceKeys,
        data: *mut MfClassicData,
    ) -> MfClassicError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleArray {
    _unused: [u8; 0],
}
pub type SimpleArrayData = core::ffi::c_void;
pub type SimpleArrayElement = core::ffi::c_void;
pub type SimpleArrayInit =
    ::core::option::Option<unsafe extern "C" fn(elem: *mut SimpleArrayElement)>;
pub type SimpleArrayReset =
    ::core::option::Option<unsafe extern "C" fn(elem: *mut SimpleArrayElement)>;
pub type SimpleArrayCopy = ::core::option::Option<
    unsafe extern "C" fn(elem: *mut SimpleArrayElement, other: *const SimpleArrayElement),
>;
#[doc = "Simple Array configuration structure. Defined per type.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SimpleArrayConfig {
    #[doc = "Initialisation (in-place constructor) method.\n\n"]
    pub init: SimpleArrayInit,
    #[doc = "Reset (custom destructor) method.\n\n"]
    pub reset: SimpleArrayReset,
    #[doc = "Copy (custom copy-constructor) method.\n\n"]
    pub copy: SimpleArrayCopy,
    pub type_size: usize,
}
#[test]
fn bindgen_test_layout_SimpleArrayConfig() {
    const UNINIT: ::core::mem::MaybeUninit<SimpleArrayConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SimpleArrayConfig>(),
        16usize,
        concat!("Size of: ", stringify!(SimpleArrayConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<SimpleArrayConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(SimpleArrayConfig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleArrayConfig),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleArrayConfig),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleArrayConfig),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SimpleArrayConfig),
            "::",
            stringify!(type_size)
        )
    );
}
extern "C" {
    #[doc = "Allocate a SimpleArray instance with the given configuration.\n\nReturns:\n\n* Pointer to the allocated SimpleArray instance\n\n# Arguments\n\n* `[in]` - config Pointer to the type-specific configuration\n\n"]
    pub fn simple_array_alloc(config: *const SimpleArrayConfig) -> *mut SimpleArray;
}
extern "C" {
    #[doc = "Free a SimpleArray instance and release its contents.\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be freed\n\n"]
    pub fn simple_array_free(instance: *mut SimpleArray);
}
extern "C" {
    #[doc = "Initialise a SimpleArray instance by allocating additional space to contain the requested number of elements. If init() is specified in the config, then it is called for each element, otherwise the data is filled with zeroes.\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be init'd\n* `[in]` - count Number of elements to be allocated and init'd\n\n"]
    pub fn simple_array_init(instance: *mut SimpleArray, count: u32);
}
extern "C" {
    #[doc = "Reset a SimpleArray instance and delete all of its elements. If reset() is specified in the config, then it is called for each element, otherwise the data is simply free()'d.\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be reset\n\n"]
    pub fn simple_array_reset(instance: *mut SimpleArray);
}
extern "C" {
    #[doc = "Copy (duplicate) another SimpleArray instance to this one. If copy() is specified in the config, then it is called for each element, otherwise the data is simply memcpy()'d.\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to copy to\n* `[in]` - other Pointer to the SimpleArray instance to copy from\n\n"]
    pub fn simple_array_copy(instance: *mut SimpleArray, other: *const SimpleArray);
}
extern "C" {
    #[doc = "Check if another SimpleArray instance is equal (the same object or holds the same data) to this one.\n\nReturns:\n\n* True if instances are considered equal, false otherwise\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to be compared\n* `[in]` - other Pointer to the SimpleArray instance to be compared\n\n"]
    pub fn simple_array_is_equal(instance: *const SimpleArray, other: *const SimpleArray) -> bool;
}
extern "C" {
    #[doc = "Get the count of elements currently contained in a SimpleArray instance.\n\nReturns:\n\n* Count of elements contained in the instance\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to query the count from\n\n"]
    pub fn simple_array_get_count(instance: *const SimpleArray) -> u32;
}
extern "C" {
    #[doc = "Get a pointer to an element contained in a SimpleArray instance.\n\nReturns:\n\n* Pointer to the element specified by index\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get an element from\n* `[in]` - index Index of the element in question. MUST be less than total element count\n\n"]
    pub fn simple_array_get(instance: *mut SimpleArray, index: u32) -> *mut SimpleArrayElement;
}
extern "C" {
    #[doc = "Get a const pointer to an element contained in a SimpleArray instance.\n\nReturns:\n\n* Const pointer to the element specified by index\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get an element from\n* `[in]` - index Index of the element in question. MUST be less than total element count\n\n"]
    pub fn simple_array_cget(instance: *const SimpleArray, index: u32)
        -> *const SimpleArrayElement;
}
extern "C" {
    #[doc = "Get a pointer to the internal data of a SimpleArray instance.\n\nReturns:\n\n* Pointer to the instance's internal data\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get the data of\n\n"]
    pub fn simple_array_get_data(instance: *mut SimpleArray) -> *mut SimpleArrayData;
}
extern "C" {
    #[doc = "Get a constant pointer to the internal data of a SimpleArray instance.\n\nReturns:\n\n* Constant pointer to the instance's internal data\n\n# Arguments\n\n* `[in]` - instance Pointer to the SimpleArray instance to get the data of\n\n"]
    pub fn simple_array_cget_data(instance: *const SimpleArray) -> *const SimpleArrayData;
}
extern "C" {
    pub static simple_array_config_uint8_t: SimpleArrayConfig;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireVersion {
    pub hw_vendor: u8,
    pub hw_type: u8,
    pub hw_subtype: u8,
    pub hw_major: u8,
    pub hw_minor: u8,
    pub hw_storage: u8,
    pub hw_proto: u8,
    pub sw_vendor: u8,
    pub sw_type: u8,
    pub sw_subtype: u8,
    pub sw_major: u8,
    pub sw_minor: u8,
    pub sw_storage: u8,
    pub sw_proto: u8,
    pub uid: [u8; 7usize],
    pub batch: [u8; 5usize],
    pub prod_week: u8,
    pub prod_year: u8,
}
#[test]
fn bindgen_test_layout_MfDesfireVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireVersion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireVersion>(),
        28usize,
        concat!("Size of: ", stringify!(MfDesfireVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MfDesfireVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_vendor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_subtype) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_major) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_storage) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_proto) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(hw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_vendor) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_subtype) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_major) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_minor) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_storage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sw_proto) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(sw_proto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).batch) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(batch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_week) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(prod_week)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_year) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireVersion),
            "::",
            stringify!(prod_year)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFreeMemory {
    pub bytes_free: u32,
    pub is_present: bool,
}
#[test]
fn bindgen_test_layout_MfDesfireFreeMemory() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFreeMemory> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFreeMemory>(),
        8usize,
        concat!("Size of: ", stringify!(MfDesfireFreeMemory))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFreeMemory>(),
        4usize,
        concat!("Alignment of ", stringify!(MfDesfireFreeMemory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_free) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFreeMemory),
            "::",
            stringify!(bytes_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_present) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFreeMemory),
            "::",
            stringify!(is_present)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireKeySettings {
    pub is_master_key_changeable: bool,
    pub is_free_directory_list: bool,
    pub is_free_create_delete: bool,
    pub is_config_changeable: bool,
    pub change_key_id: u8,
    pub max_keys: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_MfDesfireKeySettings() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireKeySettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireKeySettings>(),
        7usize,
        concat!("Size of: ", stringify!(MfDesfireKeySettings))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireKeySettings>(),
        1usize,
        concat!("Alignment of ", stringify!(MfDesfireKeySettings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_master_key_changeable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(is_master_key_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_free_directory_list) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(is_free_directory_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_free_create_delete) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(is_free_create_delete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_config_changeable) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(is_config_changeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change_key_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(change_key_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_keys) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(max_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireKeySettings),
            "::",
            stringify!(flags)
        )
    );
}
pub const MfDesfireFileType_MfDesfireFileTypeStandard: MfDesfireFileType = 0;
pub const MfDesfireFileType_MfDesfireFileTypeBackup: MfDesfireFileType = 1;
pub const MfDesfireFileType_MfDesfireFileTypeValue: MfDesfireFileType = 2;
pub const MfDesfireFileType_MfDesfireFileTypeLinearRecord: MfDesfireFileType = 3;
pub const MfDesfireFileType_MfDesfireFileTypeCyclicRecord: MfDesfireFileType = 4;
pub type MfDesfireFileType = core::ffi::c_uchar;
pub const MfDesfireFileCommunicationSettings_MfDesfireFileCommunicationSettingsPlaintext:
    MfDesfireFileCommunicationSettings = 0;
pub const MfDesfireFileCommunicationSettings_MfDesfireFileCommunicationSettingsAuthenticated:
    MfDesfireFileCommunicationSettings = 1;
pub const MfDesfireFileCommunicationSettings_MfDesfireFileCommunicationSettingsEnciphered:
    MfDesfireFileCommunicationSettings = 3;
pub type MfDesfireFileCommunicationSettings = core::ffi::c_uchar;
pub type MfDesfireFileId = u8;
pub type MfDesfireFileAccessRights = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MfDesfireFileSettings {
    pub type_: MfDesfireFileType,
    pub comm: MfDesfireFileCommunicationSettings,
    pub access_rights: MfDesfireFileAccessRights,
    pub __bindgen_anon_1: MfDesfireFileSettings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfDesfireFileSettings__bindgen_ty_1 {
    pub data: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1,
    pub value: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2,
    pub record: MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1 {
    pub size: u32,
}
#[test]
fn bindgen_test_layout_MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2 {
    pub lo_limit: u32,
    pub hi_limit: u32,
    pub limited_credit_value: u32,
    pub limited_credit_enabled: bool,
}
#[test]
fn bindgen_test_layout_MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lo_limit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(lo_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hi_limit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hi_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).limited_credit_enabled) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(limited_credit_enabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3 {
    pub size: u32,
    pub max: u32,
    pub cur: u32,
}
#[test]
fn bindgen_test_layout_MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cur) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(cur)
        )
    );
}
#[test]
fn bindgen_test_layout_MfDesfireFileSettings__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileSettings__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileSettings__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MfDesfireFileSettings__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileSettings__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings__bindgen_ty_1),
            "::",
            stringify!(record)
        )
    );
}
#[test]
fn bindgen_test_layout_MfDesfireFileSettings() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileSettings> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileSettings>(),
        20usize,
        concat!("Size of: ", stringify!(MfDesfireFileSettings))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(MfDesfireFileSettings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comm) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings),
            "::",
            stringify!(comm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).access_rights) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileSettings),
            "::",
            stringify!(access_rights)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireFileData {
    pub data: *mut SimpleArray,
}
#[test]
fn bindgen_test_layout_MfDesfireFileData() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireFileData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireFileData>(),
        4usize,
        concat!("Size of: ", stringify!(MfDesfireFileData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireFileData>(),
        4usize,
        concat!("Alignment of ", stringify!(MfDesfireFileData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireFileData),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireApplicationId {
    pub data: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_MfDesfireApplicationId() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireApplicationId> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireApplicationId>(),
        3usize,
        concat!("Size of: ", stringify!(MfDesfireApplicationId))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireApplicationId>(),
        1usize,
        concat!("Alignment of ", stringify!(MfDesfireApplicationId))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplicationId),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireApplication {
    pub key_settings: MfDesfireKeySettings,
    pub key_versions: *mut SimpleArray,
    pub file_ids: *mut SimpleArray,
    pub file_settings: *mut SimpleArray,
    pub file_data: *mut SimpleArray,
}
#[test]
fn bindgen_test_layout_MfDesfireApplication() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireApplication> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireApplication>(),
        24usize,
        concat!("Size of: ", stringify!(MfDesfireApplication))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireApplication>(),
        4usize,
        concat!("Alignment of ", stringify!(MfDesfireApplication))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_settings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplication),
            "::",
            stringify!(key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_versions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplication),
            "::",
            stringify!(key_versions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_ids) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplication),
            "::",
            stringify!(file_ids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_settings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplication),
            "::",
            stringify!(file_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireApplication),
            "::",
            stringify!(file_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfDesfireData {
    pub iso14443_4a_data: *mut Iso14443_4aData,
    pub version: MfDesfireVersion,
    pub free_memory: MfDesfireFreeMemory,
    pub master_key_settings: MfDesfireKeySettings,
    pub master_key_versions: *mut SimpleArray,
    pub application_ids: *mut SimpleArray,
    pub applications: *mut SimpleArray,
}
#[test]
fn bindgen_test_layout_MfDesfireData() {
    const UNINIT: ::core::mem::MaybeUninit<MfDesfireData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfDesfireData>(),
        60usize,
        concat!("Size of: ", stringify!(MfDesfireData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfDesfireData>(),
        4usize,
        concat!("Alignment of ", stringify!(MfDesfireData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso14443_4a_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(iso14443_4a_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_memory) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(free_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_settings) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(master_key_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).master_key_versions) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(master_key_versions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).application_ids) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(application_ids)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).applications) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MfDesfireData),
            "::",
            stringify!(applications)
        )
    );
}
extern "C" {
    pub fn mf_desfire_alloc() -> *mut MfDesfireData;
}
extern "C" {
    pub fn mf_desfire_free(data: *mut MfDesfireData);
}
extern "C" {
    pub fn mf_desfire_reset(data: *mut MfDesfireData);
}
extern "C" {
    pub fn mf_desfire_copy(data: *mut MfDesfireData, other: *const MfDesfireData);
}
extern "C" {
    pub fn mf_desfire_verify(data: *mut MfDesfireData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn mf_desfire_load(data: *mut MfDesfireData, ff: *mut FlipperFormat, version: u32) -> bool;
}
extern "C" {
    pub fn mf_desfire_save(data: *const MfDesfireData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn mf_desfire_is_equal(data: *const MfDesfireData, other: *const MfDesfireData) -> bool;
}
extern "C" {
    pub fn mf_desfire_get_device_name(
        data: *const MfDesfireData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn mf_desfire_get_uid(data: *const MfDesfireData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn mf_desfire_set_uid(data: *mut MfDesfireData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn mf_desfire_get_base_data(data: *const MfDesfireData) -> *mut Iso14443_4aData;
}
extern "C" {
    pub fn mf_desfire_get_application(
        data: *const MfDesfireData,
        app_id: *const MfDesfireApplicationId,
    ) -> *const MfDesfireApplication;
}
extern "C" {
    pub fn mf_desfire_get_file_settings(
        data: *const MfDesfireApplication,
        file_id: *const MfDesfireFileId,
    ) -> *const MfDesfireFileSettings;
}
extern "C" {
    pub fn mf_desfire_get_file_data(
        data: *const MfDesfireApplication,
        file_id: *const MfDesfireFileId,
    ) -> *const MfDesfireFileData;
}
pub const MfUltralightError_MfUltralightErrorNone: MfUltralightError = 0;
pub const MfUltralightError_MfUltralightErrorNotPresent: MfUltralightError = 1;
pub const MfUltralightError_MfUltralightErrorProtocol: MfUltralightError = 2;
pub const MfUltralightError_MfUltralightErrorAuth: MfUltralightError = 3;
pub const MfUltralightError_MfUltralightErrorTimeout: MfUltralightError = 4;
pub type MfUltralightError = core::ffi::c_uchar;
pub const MfUltralightType_MfUltralightTypeUnknown: MfUltralightType = 0;
pub const MfUltralightType_MfUltralightTypeNTAG203: MfUltralightType = 1;
pub const MfUltralightType_MfUltralightTypeMfulC: MfUltralightType = 2;
pub const MfUltralightType_MfUltralightTypeUL11: MfUltralightType = 3;
pub const MfUltralightType_MfUltralightTypeUL21: MfUltralightType = 4;
pub const MfUltralightType_MfUltralightTypeNTAG213: MfUltralightType = 5;
pub const MfUltralightType_MfUltralightTypeNTAG215: MfUltralightType = 6;
pub const MfUltralightType_MfUltralightTypeNTAG216: MfUltralightType = 7;
pub const MfUltralightType_MfUltralightTypeNTAGI2C1K: MfUltralightType = 8;
pub const MfUltralightType_MfUltralightTypeNTAGI2C2K: MfUltralightType = 9;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus1K: MfUltralightType = 10;
pub const MfUltralightType_MfUltralightTypeNTAGI2CPlus2K: MfUltralightType = 11;
pub const MfUltralightType_MfUltralightTypeNum: MfUltralightType = 12;
pub type MfUltralightType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightPage {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfUltralightPage() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightPage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightPage>(),
        4usize,
        concat!("Size of: ", stringify!(MfUltralightPage))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightPage>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightPage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightPage),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightVersion {
    pub header: u8,
    pub vendor_id: u8,
    pub prod_type: u8,
    pub prod_subtype: u8,
    pub prod_ver_major: u8,
    pub prod_ver_minor: u8,
    pub storage_size: u8,
    pub protocol_type: u8,
}
#[test]
fn bindgen_test_layout_MfUltralightVersion() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightVersion> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightVersion>(),
        8usize,
        concat!("Size of: ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightVersion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_subtype) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_subtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_major) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prod_ver_minor) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(prod_ver_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).storage_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(storage_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightVersion),
            "::",
            stringify!(protocol_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightSignature {
    pub data: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_MfUltralightSignature() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightSignature> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightSignature>(),
        32usize,
        concat!("Size of: ", stringify!(MfUltralightSignature))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightSignature>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightSignature))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightSignature),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightCounter {
    pub counter: u32,
    pub data: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_MfUltralightCounter() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightCounter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightCounter>(),
        4usize,
        concat!("Size of: ", stringify!(MfUltralightCounter))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightCounter>(),
        4usize,
        concat!("Alignment of ", stringify!(MfUltralightCounter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightCounter),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightCounter),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightTearingFlag {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_MfUltralightTearingFlag() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightTearingFlag> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightTearingFlag>(),
        1usize,
        concat!("Size of: ", stringify!(MfUltralightTearingFlag))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightTearingFlag>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightTearingFlag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightTearingFlag),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightAuthPassword {
    pub data: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_MfUltralightAuthPassword() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightAuthPassword> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightAuthPassword>(),
        4usize,
        concat!("Size of: ", stringify!(MfUltralightAuthPassword))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightAuthPassword>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightAuthPassword))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuthPassword),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightAuthPack {
    pub data: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_MfUltralightAuthPack() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightAuthPack> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightAuthPack>(),
        2usize,
        concat!("Size of: ", stringify!(MfUltralightAuthPack))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightAuthPack>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightAuthPack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightAuthPack),
            "::",
            stringify!(data)
        )
    );
}
pub const MfUltralightMirrorConf_MfUltralightMirrorNone: MfUltralightMirrorConf = 0;
pub const MfUltralightMirrorConf_MfUltralightMirrorUid: MfUltralightMirrorConf = 1;
pub const MfUltralightMirrorConf_MfUltralightMirrorCounter: MfUltralightMirrorConf = 2;
pub const MfUltralightMirrorConf_MfUltralightMirrorUidCounter: MfUltralightMirrorConf = 3;
pub type MfUltralightMirrorConf = core::ffi::c_uchar;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct MfUltralightConfigPages {
    pub mirror: MfUltralightConfigPages__bindgen_ty_1,
    pub rfui1: u8,
    pub mirror_page: u8,
    pub auth0: u8,
    pub access: MfUltralightConfigPages__bindgen_ty_2,
    pub vctid: u8,
    pub rfui2: [u8; 2usize],
    pub password: MfUltralightAuthPassword,
    pub pack: MfUltralightAuthPack,
    pub rfui3: [u8; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightConfigPages__bindgen_ty_1 {
    pub value: u8,
    pub __bindgen_anon_1: MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl MfUltralightConfigPages__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn rfui1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_rfui1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn strg_mod_en(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_strg_mod_en(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfui2(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfui2(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_byte(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mirror_byte(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mirror_conf(&self) -> MfUltralightMirrorConf {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_mirror_conf(&mut self, val: MfUltralightMirrorConf) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rfui1: u8,
        strg_mod_en: bool,
        rfui2: bool,
        mirror_byte: u8,
        mirror_conf: MfUltralightMirrorConf,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let rfui1: u8 = unsafe { ::core::mem::transmute(rfui1) };
            rfui1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let strg_mod_en: u8 = unsafe { ::core::mem::transmute(strg_mod_en) };
            strg_mod_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rfui2: u8 = unsafe { ::core::mem::transmute(rfui2) };
            rfui2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let mirror_byte: u8 = unsafe { ::core::mem::transmute(mirror_byte) };
            mirror_byte as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let mirror_conf: u8 = unsafe { ::core::mem::transmute(mirror_conf) };
            mirror_conf as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MfUltralightConfigPages__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightConfigPages__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MfUltralightConfigPages__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_1),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MfUltralightConfigPages__bindgen_ty_2 {
    pub value: u8,
    pub __bindgen_anon_1: MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl MfUltralightConfigPages__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn authlim(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_authlim(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn nfc_cnt_pwd_prot(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_cnt_pwd_prot(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nfc_cnt_en(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_cnt_en(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nfc_dis_sec1(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nfc_dis_sec1(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cfglck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cfglck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prot(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_prot(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        authlim: u8,
        nfc_cnt_pwd_prot: bool,
        nfc_cnt_en: bool,
        nfc_dis_sec1: bool,
        cfglck: bool,
        prot: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let authlim: u8 = unsafe { ::core::mem::transmute(authlim) };
            authlim as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nfc_cnt_pwd_prot: u8 = unsafe { ::core::mem::transmute(nfc_cnt_pwd_prot) };
            nfc_cnt_pwd_prot as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nfc_cnt_en: u8 = unsafe { ::core::mem::transmute(nfc_cnt_en) };
            nfc_cnt_en as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let nfc_dis_sec1: u8 = unsafe { ::core::mem::transmute(nfc_dis_sec1) };
            nfc_dis_sec1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let cfglck: u8 = unsafe { ::core::mem::transmute(cfglck) };
            cfglck as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let prot: u8 = unsafe { ::core::mem::transmute(prot) };
            prot as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MfUltralightConfigPages__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightConfigPages__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightConfigPages__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightConfigPages__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MfUltralightConfigPages__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages__bindgen_ty_2),
            "::",
            stringify!(value)
        )
    );
}
#[test]
fn bindgen_test_layout_MfUltralightConfigPages() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightConfigPages> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightConfigPages>(),
        16usize,
        concat!("Size of: ", stringify!(MfUltralightConfigPages))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightConfigPages>(),
        1usize,
        concat!("Alignment of ", stringify!(MfUltralightConfigPages))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mirror) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(mirror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfui1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(rfui1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mirror_page) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(mirror_page)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth0) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(auth0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vctid) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(vctid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfui2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(rfui2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pack) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(pack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfui3) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightConfigPages),
            "::",
            stringify!(rfui3)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MfUltralightData {
    pub iso14443_3a_data: *mut Iso14443_3aData,
    pub type_: MfUltralightType,
    pub version: MfUltralightVersion,
    pub signature: MfUltralightSignature,
    pub counter: [MfUltralightCounter; 3usize],
    pub tearing_flag: [MfUltralightTearingFlag; 3usize],
    pub page: [MfUltralightPage; 510usize],
    pub pages_read: u16,
    pub pages_total: u16,
    pub auth_attempts: u32,
}
#[test]
fn bindgen_test_layout_MfUltralightData() {
    const UNINIT: ::core::mem::MaybeUninit<MfUltralightData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MfUltralightData>(),
        2112usize,
        concat!("Size of: ", stringify!(MfUltralightData))
    );
    assert_eq!(
        ::core::mem::align_of::<MfUltralightData>(),
        4usize,
        concat!("Alignment of ", stringify!(MfUltralightData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso14443_3a_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(iso14443_3a_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tearing_flag) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(tearing_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pages_read) as usize - ptr as usize },
        2104usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(pages_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pages_total) as usize - ptr as usize },
        2106usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(pages_total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auth_attempts) as usize - ptr as usize },
        2108usize,
        concat!(
            "Offset of field: ",
            stringify!(MfUltralightData),
            "::",
            stringify!(auth_attempts)
        )
    );
}
extern "C" {
    pub fn mf_ultralight_alloc() -> *mut MfUltralightData;
}
extern "C" {
    pub fn mf_ultralight_free(data: *mut MfUltralightData);
}
extern "C" {
    pub fn mf_ultralight_reset(data: *mut MfUltralightData);
}
extern "C" {
    pub fn mf_ultralight_copy(data: *mut MfUltralightData, other: *const MfUltralightData);
}
extern "C" {
    pub fn mf_ultralight_verify(
        data: *mut MfUltralightData,
        device_type: *const FuriString,
    ) -> bool;
}
extern "C" {
    pub fn mf_ultralight_load(
        data: *mut MfUltralightData,
        ff: *mut FlipperFormat,
        version: u32,
    ) -> bool;
}
extern "C" {
    pub fn mf_ultralight_save(data: *const MfUltralightData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn mf_ultralight_is_equal(
        data: *const MfUltralightData,
        other: *const MfUltralightData,
    ) -> bool;
}
extern "C" {
    pub fn mf_ultralight_get_device_name(
        data: *const MfUltralightData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn mf_ultralight_get_uid(data: *const MfUltralightData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn mf_ultralight_set_uid(
        data: *mut MfUltralightData,
        uid: *const u8,
        uid_len: usize,
    ) -> bool;
}
extern "C" {
    pub fn mf_ultralight_get_base_data(data: *const MfUltralightData) -> *mut Iso14443_3aData;
}
extern "C" {
    pub fn mf_ultralight_get_type_by_version(version: *mut MfUltralightVersion)
        -> MfUltralightType;
}
extern "C" {
    pub fn mf_ultralight_get_pages_total(type_: MfUltralightType) -> u16;
}
extern "C" {
    pub fn mf_ultralight_get_feature_support_set(type_: MfUltralightType) -> u32;
}
extern "C" {
    pub fn mf_ultralight_get_config_page_num(type_: MfUltralightType) -> u16;
}
extern "C" {
    pub fn mf_ultralight_get_pwd_page_num(type_: MfUltralightType) -> u8;
}
extern "C" {
    pub fn mf_ultralight_is_page_pwd_or_pack(type_: MfUltralightType, page_num: u16) -> bool;
}
extern "C" {
    pub fn mf_ultralight_support_feature(feature_set: u32, features_to_check: u32) -> bool;
}
extern "C" {
    pub fn mf_ultralight_get_config_page(
        data: *const MfUltralightData,
        config: *mut *mut MfUltralightConfigPages,
    ) -> bool;
}
extern "C" {
    pub fn mf_ultralight_is_all_data_read(data: *const MfUltralightData) -> bool;
}
extern "C" {
    pub fn mf_ultralight_detect_protocol(iso14443_3a_data: *const Iso14443_3aData) -> bool;
}
extern "C" {
    pub fn mf_ultralight_is_counter_configured(data: *const MfUltralightData) -> bool;
}
extern "C" {
    pub fn mf_ultralight_poller_read_page(
        nfc: *mut Nfc,
        page: u16,
        data: *mut MfUltralightPage,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_write_page(
        nfc: *mut Nfc,
        page: u16,
        data: *mut MfUltralightPage,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_read_version(
        nfc: *mut Nfc,
        data: *mut MfUltralightVersion,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_read_signature(
        nfc: *mut Nfc,
        data: *mut MfUltralightSignature,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_read_counter(
        nfc: *mut Nfc,
        counter_num: u8,
        data: *mut MfUltralightCounter,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_read_tearing_flag(
        nfc: *mut Nfc,
        flag_num: u8,
        data: *mut MfUltralightTearingFlag,
    ) -> MfUltralightError;
}
extern "C" {
    pub fn mf_ultralight_poller_read_card(
        nfc: *mut Nfc,
        data: *mut MfUltralightData,
    ) -> MfUltralightError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3SystemInfo {
    pub flags: u8,
    pub dsfid: u8,
    pub afi: u8,
    pub ic_ref: u8,
    pub block_count: u16,
    pub block_size: u8,
}
#[test]
fn bindgen_test_layout_Iso15693_3SystemInfo() {
    const UNINIT: ::core::mem::MaybeUninit<Iso15693_3SystemInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Iso15693_3SystemInfo>(),
        8usize,
        concat!("Size of: ", stringify!(Iso15693_3SystemInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<Iso15693_3SystemInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(Iso15693_3SystemInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsfid) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(dsfid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).afi) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(afi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ic_ref) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(ic_ref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(block_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3SystemInfo),
            "::",
            stringify!(block_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3LockBits {
    pub dsfid: bool,
    pub afi: bool,
}
#[test]
fn bindgen_test_layout_Iso15693_3LockBits() {
    const UNINIT: ::core::mem::MaybeUninit<Iso15693_3LockBits> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Iso15693_3LockBits>(),
        2usize,
        concat!("Size of: ", stringify!(Iso15693_3LockBits))
    );
    assert_eq!(
        ::core::mem::align_of::<Iso15693_3LockBits>(),
        1usize,
        concat!("Alignment of ", stringify!(Iso15693_3LockBits))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dsfid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3LockBits),
            "::",
            stringify!(dsfid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).afi) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3LockBits),
            "::",
            stringify!(afi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3Settings {
    pub lock_bits: Iso15693_3LockBits,
}
#[test]
fn bindgen_test_layout_Iso15693_3Settings() {
    const UNINIT: ::core::mem::MaybeUninit<Iso15693_3Settings> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Iso15693_3Settings>(),
        2usize,
        concat!("Size of: ", stringify!(Iso15693_3Settings))
    );
    assert_eq!(
        ::core::mem::align_of::<Iso15693_3Settings>(),
        1usize,
        concat!("Alignment of ", stringify!(Iso15693_3Settings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Settings),
            "::",
            stringify!(lock_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Iso15693_3Data {
    pub uid: [u8; 8usize],
    pub system_info: Iso15693_3SystemInfo,
    pub settings: Iso15693_3Settings,
    pub block_data: *mut SimpleArray,
    pub block_security: *mut SimpleArray,
}
#[test]
fn bindgen_test_layout_Iso15693_3Data() {
    const UNINIT: ::core::mem::MaybeUninit<Iso15693_3Data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Iso15693_3Data>(),
        28usize,
        concat!("Size of: ", stringify!(Iso15693_3Data))
    );
    assert_eq!(
        ::core::mem::align_of::<Iso15693_3Data>(),
        4usize,
        concat!("Alignment of ", stringify!(Iso15693_3Data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Data),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).system_info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Data),
            "::",
            stringify!(system_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).settings) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Data),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Data),
            "::",
            stringify!(block_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_security) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Iso15693_3Data),
            "::",
            stringify!(block_security)
        )
    );
}
extern "C" {
    pub fn iso15693_3_alloc() -> *mut Iso15693_3Data;
}
extern "C" {
    pub fn iso15693_3_free(data: *mut Iso15693_3Data);
}
extern "C" {
    pub fn iso15693_3_reset(data: *mut Iso15693_3Data);
}
extern "C" {
    pub fn iso15693_3_copy(data: *mut Iso15693_3Data, other: *const Iso15693_3Data);
}
extern "C" {
    pub fn iso15693_3_verify(data: *mut Iso15693_3Data, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn iso15693_3_load(data: *mut Iso15693_3Data, ff: *mut FlipperFormat, version: u32)
        -> bool;
}
extern "C" {
    pub fn iso15693_3_save(data: *const Iso15693_3Data, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn iso15693_3_is_equal(data: *const Iso15693_3Data, other: *const Iso15693_3Data) -> bool;
}
extern "C" {
    pub fn iso15693_3_get_device_name(
        data: *const Iso15693_3Data,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn iso15693_3_get_uid(data: *const Iso15693_3Data, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn iso15693_3_set_uid(data: *mut Iso15693_3Data, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn iso15693_3_get_base_data(data: *const Iso15693_3Data) -> *mut Iso15693_3Data;
}
extern "C" {
    pub fn iso15693_3_is_block_locked(data: *const Iso15693_3Data, block_index: u8) -> bool;
}
extern "C" {
    pub fn iso15693_3_get_manufacturer_id(data: *const Iso15693_3Data) -> u8;
}
extern "C" {
    pub fn iso15693_3_get_block_count(data: *const Iso15693_3Data) -> u16;
}
extern "C" {
    pub fn iso15693_3_get_block_size(data: *const Iso15693_3Data) -> u8;
}
extern "C" {
    pub fn iso15693_3_get_block_data(data: *const Iso15693_3Data, block_index: u8) -> *const u8;
}
pub type SlixTypeFeatures = u32;
pub const SlixType_SlixTypeSlix: SlixType = 0;
pub const SlixType_SlixTypeSlixS: SlixType = 1;
pub const SlixType_SlixTypeSlixL: SlixType = 2;
pub const SlixType_SlixTypeSlix2: SlixType = 3;
pub const SlixType_SlixTypeCount: SlixType = 4;
pub type SlixType = core::ffi::c_uchar;
pub const SlixPasswordType_SlixPasswordTypeRead: SlixPasswordType = 0;
pub const SlixPasswordType_SlixPasswordTypeWrite: SlixPasswordType = 1;
pub const SlixPasswordType_SlixPasswordTypePrivacy: SlixPasswordType = 2;
pub const SlixPasswordType_SlixPasswordTypeDestroy: SlixPasswordType = 3;
pub const SlixPasswordType_SlixPasswordTypeEasAfi: SlixPasswordType = 4;
pub const SlixPasswordType_SlixPasswordTypeCount: SlixPasswordType = 5;
pub type SlixPasswordType = core::ffi::c_uchar;
pub type SlixPassword = u32;
pub type SlixSignature = [u8; 32usize];
pub type SlixPrivacy = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixProtection {
    pub pointer: u8,
    pub condition: u8,
}
#[test]
fn bindgen_test_layout_SlixProtection() {
    const UNINIT: ::core::mem::MaybeUninit<SlixProtection> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SlixProtection>(),
        2usize,
        concat!("Size of: ", stringify!(SlixProtection))
    );
    assert_eq!(
        ::core::mem::align_of::<SlixProtection>(),
        1usize,
        concat!("Alignment of ", stringify!(SlixProtection))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixProtection),
            "::",
            stringify!(pointer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).condition) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixProtection),
            "::",
            stringify!(condition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixLockBits {
    pub eas: bool,
    pub ppl: bool,
}
#[test]
fn bindgen_test_layout_SlixLockBits() {
    const UNINIT: ::core::mem::MaybeUninit<SlixLockBits> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SlixLockBits>(),
        2usize,
        concat!("Size of: ", stringify!(SlixLockBits))
    );
    assert_eq!(
        ::core::mem::align_of::<SlixLockBits>(),
        1usize,
        concat!("Alignment of ", stringify!(SlixLockBits))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eas) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixLockBits),
            "::",
            stringify!(eas)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppl) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixLockBits),
            "::",
            stringify!(ppl)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixSystemInfo {
    pub protection: SlixProtection,
    pub lock_bits: SlixLockBits,
}
#[test]
fn bindgen_test_layout_SlixSystemInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SlixSystemInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SlixSystemInfo>(),
        4usize,
        concat!("Size of: ", stringify!(SlixSystemInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SlixSystemInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(SlixSystemInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixSystemInfo),
            "::",
            stringify!(protection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_bits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixSystemInfo),
            "::",
            stringify!(lock_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlixData {
    pub iso15693_3_data: *mut Iso15693_3Data,
    pub system_info: SlixSystemInfo,
    pub signature: SlixSignature,
    pub passwords: [SlixPassword; 5usize],
    pub privacy: SlixPrivacy,
}
#[test]
fn bindgen_test_layout_SlixData() {
    const UNINIT: ::core::mem::MaybeUninit<SlixData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SlixData>(),
        64usize,
        concat!("Size of: ", stringify!(SlixData))
    );
    assert_eq!(
        ::core::mem::align_of::<SlixData>(),
        4usize,
        concat!("Alignment of ", stringify!(SlixData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iso15693_3_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixData),
            "::",
            stringify!(iso15693_3_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).system_info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixData),
            "::",
            stringify!(system_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixData),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passwords) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixData),
            "::",
            stringify!(passwords)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).privacy) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SlixData),
            "::",
            stringify!(privacy)
        )
    );
}
extern "C" {
    pub fn slix_alloc() -> *mut SlixData;
}
extern "C" {
    pub fn slix_free(data: *mut SlixData);
}
extern "C" {
    pub fn slix_reset(data: *mut SlixData);
}
extern "C" {
    pub fn slix_copy(data: *mut SlixData, other: *const SlixData);
}
extern "C" {
    pub fn slix_verify(data: *mut SlixData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn slix_load(data: *mut SlixData, ff: *mut FlipperFormat, version: u32) -> bool;
}
extern "C" {
    pub fn slix_save(data: *const SlixData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn slix_is_equal(data: *const SlixData, other: *const SlixData) -> bool;
}
extern "C" {
    pub fn slix_get_device_name(
        data: *const SlixData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn slix_get_uid(data: *const SlixData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn slix_set_uid(data: *mut SlixData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn slix_get_base_data(data: *const SlixData) -> *const Iso15693_3Data;
}
extern "C" {
    pub fn slix_get_type(data: *const SlixData) -> SlixType;
}
extern "C" {
    pub fn slix_get_password(
        data: *const SlixData,
        password_type: SlixPasswordType,
    ) -> SlixPassword;
}
extern "C" {
    pub fn slix_get_counter(data: *const SlixData) -> u16;
}
extern "C" {
    pub fn slix_is_privacy_mode(data: *const SlixData) -> bool;
}
extern "C" {
    pub fn slix_is_block_protected(
        data: *const SlixData,
        password_type: SlixPasswordType,
        block_num: u8,
    ) -> bool;
}
extern "C" {
    pub fn slix_is_counter_increment_protected(data: *const SlixData) -> bool;
}
extern "C" {
    pub fn slix_type_has_features(slix_type: SlixType, features: SlixTypeFeatures) -> bool;
}
extern "C" {
    pub fn slix_type_supports_password(
        slix_type: SlixType,
        password_type: SlixPasswordType,
    ) -> bool;
}
pub const St25tbType_St25tbType512At: St25tbType = 0;
pub const St25tbType_St25tbType512Ac: St25tbType = 1;
pub const St25tbType_St25tbTypeX512: St25tbType = 2;
pub const St25tbType_St25tbType02k: St25tbType = 3;
pub const St25tbType_St25tbType04k: St25tbType = 4;
pub const St25tbType_St25tbTypeX4k: St25tbType = 5;
pub const St25tbType_St25tbTypeNum: St25tbType = 6;
pub type St25tbType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct St25tbData {
    pub uid: [u8; 8usize],
    pub type_: St25tbType,
    pub blocks: [u32; 128usize],
    pub system_otp_block: u32,
    pub chip_id: u8,
}
#[test]
fn bindgen_test_layout_St25tbData() {
    const UNINIT: ::core::mem::MaybeUninit<St25tbData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<St25tbData>(),
        532usize,
        concat!("Size of: ", stringify!(St25tbData))
    );
    assert_eq!(
        ::core::mem::align_of::<St25tbData>(),
        4usize,
        concat!("Alignment of ", stringify!(St25tbData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(St25tbData),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(St25tbData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(St25tbData),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).system_otp_block) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(St25tbData),
            "::",
            stringify!(system_otp_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chip_id) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(St25tbData),
            "::",
            stringify!(chip_id)
        )
    );
}
extern "C" {
    pub fn st25tb_alloc() -> *mut St25tbData;
}
extern "C" {
    pub fn st25tb_free(data: *mut St25tbData);
}
extern "C" {
    pub fn st25tb_reset(data: *mut St25tbData);
}
extern "C" {
    pub fn st25tb_copy(data: *mut St25tbData, other: *const St25tbData);
}
extern "C" {
    pub fn st25tb_verify(data: *mut St25tbData, device_type: *const FuriString) -> bool;
}
extern "C" {
    pub fn st25tb_load(data: *mut St25tbData, ff: *mut FlipperFormat, version: u32) -> bool;
}
extern "C" {
    pub fn st25tb_save(data: *const St25tbData, ff: *mut FlipperFormat) -> bool;
}
extern "C" {
    pub fn st25tb_is_equal(data: *const St25tbData, other: *const St25tbData) -> bool;
}
extern "C" {
    pub fn st25tb_get_block_count(type_: St25tbType) -> u8;
}
extern "C" {
    pub fn st25tb_get_device_name(
        data: *const St25tbData,
        name_type: NfcDeviceNameType,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn st25tb_get_uid(data: *const St25tbData, uid_len: *mut usize) -> *const u8;
}
extern "C" {
    pub fn st25tb_set_uid(data: *mut St25tbData, uid: *const u8, uid_len: usize) -> bool;
}
extern "C" {
    pub fn st25tb_get_base_data(data: *const St25tbData) -> *mut St25tbData;
}
extern "C" {
    pub fn maxim_crc8(data: *const u8, data_size: u8, crc_init: u8) -> u8;
}
#[doc = "Search for alarmed device\n\n"]
pub const OneWireHostSearchMode_OneWireHostSearchModeConditional: OneWireHostSearchMode = 0;
#[doc = "Search for all devices\n\n"]
pub const OneWireHostSearchMode_OneWireHostSearchModeNormal: OneWireHostSearchMode = 1;
pub type OneWireHostSearchMode = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireHost {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate OneWireHost instance\n\nReturns:\n\n* pointer to OneWireHost instance\n\n# Arguments\n\n* `[in]` - gpio_pin connection pin\n\n"]
    pub fn onewire_host_alloc(gpio_pin: *const GpioPin) -> *mut OneWireHost;
}
extern "C" {
    #[doc = "Destroy OneWireHost instance, free resources\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_free(host: *mut OneWireHost);
}
extern "C" {
    #[doc = "Reset the 1-Wire bus\n\nReturns:\n\n* true if presence was detected, false otherwise\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_reset(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = "Read one bit\n\nReturns:\n\n* received bit value\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_read_bit(host: *mut OneWireHost) -> bool;
}
extern "C" {
    #[doc = "Read one byte\n\nReturns:\n\n* received byte value\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_read(host: *mut OneWireHost) -> u8;
}
extern "C" {
    #[doc = "Read one or more bytes\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `[out]` - buffer received data buffer\n* `[in]` - count number of bytes to read\n\n"]
    pub fn onewire_host_read_bytes(host: *mut OneWireHost, buffer: *mut u8, count: u16);
}
extern "C" {
    #[doc = "Write one bit\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `value` - bit value to write\n\n"]
    pub fn onewire_host_write_bit(host: *mut OneWireHost, value: bool);
}
extern "C" {
    #[doc = "Write one byte\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `value` - byte value to write\n\n"]
    pub fn onewire_host_write(host: *mut OneWireHost, value: u8);
}
extern "C" {
    #[doc = "Write one or more bytes\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `[in]` - buffer pointer to the data to write\n* `[in]` - count size of the data to write\n\n"]
    pub fn onewire_host_write_bytes(host: *mut OneWireHost, buffer: *const u8, count: u16);
}
extern "C" {
    #[doc = "Start working with the bus\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_start(host: *mut OneWireHost);
}
extern "C" {
    #[doc = "Stop working with the bus\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_stop(host: *mut OneWireHost);
}
extern "C" {
    #[doc = "Reset previous search results\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n\n"]
    pub fn onewire_host_reset_search(host: *mut OneWireHost);
}
extern "C" {
    #[doc = "Set the family code to search for\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `[in]` - family_code device family code\n\n"]
    pub fn onewire_host_target_search(host: *mut OneWireHost, family_code: u8);
}
extern "C" {
    #[doc = "Search for devices on the 1-Wire bus\n\nReturns:\n\n* true on success, false otherwise\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `[out]` - new_addr pointer to the buffer to contain the unique ROM of the found device\n* `[in]` - mode search mode\n\n"]
    pub fn onewire_host_search(
        host: *mut OneWireHost,
        new_addr: *mut u8,
        mode: OneWireHostSearchMode,
    ) -> bool;
}
extern "C" {
    #[doc = "Enable overdrive mode\n\n# Arguments\n\n* `[in]` - host pointer to OneWireHost instance\n* `[in]` - set true to turn overdrive on, false to turn it off\n\n"]
    pub fn onewire_host_set_overdrive(host: *mut OneWireHost, set: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OneWireSlave {
    _unused: [u8; 0],
}
pub type OneWireSlaveResetCallback = ::core::option::Option<
    unsafe extern "C" fn(is_short: bool, context: *mut core::ffi::c_void) -> bool,
>;
pub type OneWireSlaveCommandCallback = ::core::option::Option<
    unsafe extern "C" fn(command: u8, context: *mut core::ffi::c_void) -> bool,
>;
pub type OneWireSlaveResultCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Allocate OneWireSlave instance\n\nReturns:\n\n* pointer to OneWireSlave instance\n\n# Arguments\n\n* `[in]` - gpio_pin connection pin\n\n"]
    pub fn onewire_slave_alloc(gpio_pin: *const GpioPin) -> *mut OneWireSlave;
}
extern "C" {
    #[doc = "Destroy OneWireSlave instance, free resources\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n\n"]
    pub fn onewire_slave_free(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = "Start working with the bus\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n\n"]
    pub fn onewire_slave_start(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = "Stop working with the bus\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n\n"]
    pub fn onewire_slave_stop(bus: *mut OneWireSlave);
}
extern "C" {
    #[doc = "Receive one bit\n\nReturns:\n\n* received bit value\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n\n"]
    pub fn onewire_slave_receive_bit(bus: *mut OneWireSlave) -> bool;
}
extern "C" {
    #[doc = "Send one bit\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - value bit value to send\n\n"]
    pub fn onewire_slave_send_bit(bus: *mut OneWireSlave, value: bool) -> bool;
}
extern "C" {
    #[doc = "Send one or more bytes of data\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - data pointer to the data to send\n* `[in]` - data_size size of the data to send\n\n"]
    pub fn onewire_slave_send(bus: *mut OneWireSlave, data: *const u8, data_size: usize) -> bool;
}
extern "C" {
    #[doc = "Receive one or more bytes of data\n\nReturns:\n\n* true on success, false on failure\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[out]` - data pointer to the receive buffer\n* `[in]` - data_size number of bytes to receive\n\n"]
    pub fn onewire_slave_receive(bus: *mut OneWireSlave, data: *mut u8, data_size: usize) -> bool;
}
extern "C" {
    #[doc = "Enable overdrive mode\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - set true to turn overdrive on, false to turn it off\n\n"]
    pub fn onewire_slave_set_overdrive(bus: *mut OneWireSlave, set: bool);
}
extern "C" {
    #[doc = "Set a callback function to be called on each reset. The return value of the callback determines whether the emulated device supports the short reset (passed as the is_short parameter). In most applications, it should also call onewire_slave_set_overdrive() to set the appropriate speed mode.\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - callback pointer to a callback function\n* `[in]` - context additional parameter to be passed to the callback\n\n"]
    pub fn onewire_slave_set_reset_callback(
        bus: *mut OneWireSlave,
        callback: OneWireSlaveResetCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set a callback function to be called on each command. The return value of the callback determines whether further operation is possible. As a rule of thumb, return true unless a critical error happened.\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - callback pointer to a callback function\n* `[in]` - context additional parameter to be passed to the callback\n\n"]
    pub fn onewire_slave_set_command_callback(
        bus: *mut OneWireSlave,
        callback: OneWireSlaveCommandCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set a callback to report emulation success\n\n# Arguments\n\n* `[in]` - bus pointer to OneWireSlave instance\n* `[in]` - result_cb pointer to a callback function\n* `[in]` - context additional parameter to be passed to the callback\n\n"]
    pub fn onewire_slave_set_result_callback(
        bus: *mut OneWireSlave,
        result_cb: OneWireSlaveResultCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wrap_printf(format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_vsnprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_puts(str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putchar(ch: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_putc(ch: core::ffi::c_int, stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_snprintf(
        str_: *mut core::ffi::c_char,
        size: usize,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap_fflush(stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wrap___assert(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        e: *const core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __wrap___assert_func(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        e: *const core::ffi::c_char,
    ) -> !;
}
pub const SignalReaderEventType_SignalReaderEventTypeHalfBufferFilled: SignalReaderEventType = 0;
pub const SignalReaderEventType_SignalReaderEventTypeFullBufferFilled: SignalReaderEventType = 1;
pub type SignalReaderEventType = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReaderEventData {
    pub data: *mut u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_SignalReaderEventData() {
    const UNINIT: ::core::mem::MaybeUninit<SignalReaderEventData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SignalReaderEventData>(),
        8usize,
        concat!("Size of: ", stringify!(SignalReaderEventData))
    );
    assert_eq!(
        ::core::mem::align_of::<SignalReaderEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(SignalReaderEventData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SignalReaderEventData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SignalReaderEventData),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReaderEvent {
    pub type_: SignalReaderEventType,
    pub data: *mut SignalReaderEventData,
}
#[test]
fn bindgen_test_layout_SignalReaderEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SignalReaderEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SignalReaderEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SignalReaderEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SignalReaderEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SignalReaderEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SignalReaderEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SignalReaderEvent),
            "::",
            stringify!(data)
        )
    );
}
pub const SignalReaderTimeUnit_SignalReaderTimeUnit64Mhz: SignalReaderTimeUnit = 0;
pub type SignalReaderTimeUnit = core::ffi::c_uchar;
pub const SignalReaderPolarity_SignalReaderPolarityNormal: SignalReaderPolarity = 0;
pub const SignalReaderPolarity_SignalReaderPolarityInverted: SignalReaderPolarity = 1;
pub type SignalReaderPolarity = core::ffi::c_uchar;
pub const SignalReaderTrigger_SignalReaderTriggerNone: SignalReaderTrigger = 0;
pub const SignalReaderTrigger_SignalReaderTriggerRisingFallingEdge: SignalReaderTrigger = 1;
pub type SignalReaderTrigger = core::ffi::c_uchar;
pub type SignalReaderCallback = ::core::option::Option<
    unsafe extern "C" fn(event: SignalReaderEvent, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalReader {
    _unused: [u8; 0],
}
extern "C" {
    pub fn signal_reader_alloc(gpio_pin: *const GpioPin, size: u32) -> *mut SignalReader;
}
extern "C" {
    pub fn signal_reader_free(instance: *mut SignalReader);
}
extern "C" {
    pub fn signal_reader_set_pull(instance: *mut SignalReader, pull: GpioPull);
}
extern "C" {
    pub fn signal_reader_set_polarity(instance: *mut SignalReader, polarity: SignalReaderPolarity);
}
extern "C" {
    pub fn signal_reader_set_sample_rate(
        instance: *mut SignalReader,
        time_unit: SignalReaderTimeUnit,
        time: u32,
    );
}
extern "C" {
    pub fn signal_reader_set_trigger(instance: *mut SignalReader, trigger: SignalReaderTrigger);
}
extern "C" {
    pub fn signal_reader_start(
        instance: *mut SignalReader,
        callback: SignalReaderCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn signal_reader_stop(instance: *mut SignalReader);
}
#[doc = "Structure definition of some features of COMP instance.\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_COMP_InitTypeDef {
    #[doc = "Set comparator operating mode to adjust power and speed.\nThis parameter can be a value of  [`COMP_LL_EC_POWERMODE`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetPowerMode()`]\n\n"]
    pub PowerMode: u32,
    #[doc = "Set comparator input plus (non-inverting input).\nThis parameter can be a value of  [`COMP_LL_EC_INPUT_PLUS`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetInputPlus()`]\n\n"]
    pub InputPlus: u32,
    #[doc = "Set comparator input minus (inverting input).\nThis parameter can be a value of  [`COMP_LL_EC_INPUT_MINUS`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetInputMinus()`]\n\n"]
    pub InputMinus: u32,
    #[doc = "Set comparator hysteresis mode of the input minus.\nThis parameter can be a value of  [`COMP_LL_EC_INPUT_HYSTERESIS`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetInputHysteresis()`]\n\n"]
    pub InputHysteresis: u32,
    #[doc = "Set comparator output polarity.\nThis parameter can be a value of  [`COMP_LL_EC_OUTPUT_POLARITY`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetOutputPolarity()`]\n\n"]
    pub OutputPolarity: u32,
    #[doc = "Set comparator blanking source.\nThis parameter can be a value of  [`COMP_LL_EC_OUTPUT_BLANKING_SOURCE`]\nThis feature can be modified afterwards using unitary function  [`LL_COMP_SetOutputBlankingSource()`]\n\n"]
    pub OutputBlankingSource: u32,
}
#[test]
fn bindgen_test_layout_LL_COMP_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_COMP_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_COMP_InitTypeDef>(),
        24usize,
        concat!("Size of: ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_COMP_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_COMP_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(PowerMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputPlus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputPlus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputMinus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputMinus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InputHysteresis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(InputHysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputPolarity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputPolarity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutputBlankingSource) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_COMP_InitTypeDef),
            "::",
            stringify!(OutputBlankingSource)
        )
    );
}
extern "C" {
    pub fn LL_COMP_Init(
        COMPx: *mut COMP_TypeDef,
        COMP_InitStruct: *const LL_COMP_InitTypeDef,
    ) -> ErrorStatus;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_DMA_InitTypeDef {
    #[doc = "Specifies the peripheral base address for DMA transfer\nor as Source base address in case of memory to memory transfer direction.\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF.\n\n"]
    pub PeriphOrM2MSrcAddress: u32,
    #[doc = "Specifies the memory base address for DMA transfer\nor as Destination base address in case of memory to memory transfer direction.\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0xFFFFFFFF.\n\n"]
    pub MemoryOrM2MDstAddress: u32,
    #[doc = "Specifies if the data will be transferred from memory to peripheral,\nfrom memory to memory or from peripheral to memory.\nThis parameter can be a value of  [`DMA_LL_EC_DIRECTION`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetDataTransferDirection()`]\n\n"]
    pub Direction: u32,
    #[doc = "Specifies the normal or circular operation mode.\nThis parameter can be a value of  [`DMA_LL_EC_MODE`]\ndata transfer direction is configured on the selected Channel\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetMode()`]\n\n# Notes\n\n* The circular buffer mode cannot be used if the memory to memory\n\n"]
    pub Mode: u32,
    #[doc = "Specifies whether the Peripheral address or Source address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of  [`DMA_LL_EC_PERIPH`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetPeriphIncMode()`]\n\n"]
    pub PeriphOrM2MSrcIncMode: u32,
    #[doc = "Specifies whether the Memory address or Destination address in case of memory to memory transfer direction\nis incremented or not.\nThis parameter can be a value of  [`DMA_LL_EC_MEMORY`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetMemoryIncMode()`]\n\n"]
    pub MemoryOrM2MDstIncMode: u32,
    #[doc = "Specifies the Peripheral data size alignment or Source data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of  [`DMA_LL_EC_PDATAALIGN`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetPeriphSize()`]\n\n"]
    pub PeriphOrM2MSrcDataSize: u32,
    #[doc = "Specifies the Memory data size alignment or Destination data size alignment (byte, half word, word)\nin case of memory to memory transfer direction.\nThis parameter can be a value of  [`DMA_LL_EC_MDATAALIGN`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetMemorySize()`]\n\n"]
    pub MemoryOrM2MDstDataSize: u32,
    #[doc = "Specifies the number of data to transfer, in data unit.\nThe data unit is equal to the source buffer configuration set in PeripheralSize\nor MemorySize parameters depending in the transfer direction.\nThis parameter must be a value between Min_Data = 0 and Max_Data = 0x0000FFFF\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetDataLength()`]\n\n"]
    pub NbData: u32,
    #[doc = "Specifies the peripheral request.\nThis parameter can be a value of  [`DMAMUX_LL_EC_REQUEST`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetPeriphRequest()`]\n\n"]
    pub PeriphRequest: u32,
    #[doc = "Specifies the channel priority level.\nThis parameter can be a value of  [`DMA_LL_EC_PRIORITY`]\nThis feature can be modified afterwards using unitary function  [`LL_DMA_SetChannelPriorityLevel()`]\n\n"]
    pub Priority: u32,
}
#[test]
fn bindgen_test_layout_LL_DMA_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_DMA_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_DMA_InitTypeDef>(),
        44usize,
        concat!("Size of: ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_DMA_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_DMA_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Direction) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcIncMode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstIncMode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstIncMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphOrM2MSrcDataSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphOrM2MSrcDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MemoryOrM2MDstDataSize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(MemoryOrM2MDstDataSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(NbData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeriphRequest) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(PeriphRequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_DMA_InitTypeDef),
            "::",
            stringify!(Priority)
        )
    );
}
extern "C" {
    pub fn LL_DMA_Init(
        DMAx: *mut DMA_TypeDef,
        Channel: u32,
        DMA_InitStruct: *mut LL_DMA_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_DMA_DeInit(DMAx: *mut DMA_TypeDef, Channel: u32) -> ErrorStatus;
}
#[doc = "LPTIM Init structure definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPTIM_InitTypeDef {
    #[doc = "Specifies the source of the clock used by the LPTIM instance.\nThis parameter can be a value of  [`LPTIM_LL_EC_CLK_SOURCE`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPTIM_SetClockSource()`]\n\n"]
    pub ClockSource: u32,
    #[doc = "Specifies the prescaler division ratio.\nThis parameter can be a value of  [`LPTIM_LL_EC_PRESCALER`]\nThis feature can be modified afterwards using using unitary\nfunction  [`LL_LPTIM_SetPrescaler()`]\n\n"]
    pub Prescaler: u32,
    #[doc = "Specifies the waveform shape.\nThis parameter can be a value of  [`LPTIM_LL_EC_OUTPUT_WAVEFORM`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPTIM_ConfigOutput()`]\n\n"]
    pub Waveform: u32,
    #[doc = "Specifies waveform polarity.\nThis parameter can be a value of  [`LPTIM_LL_EC_OUTPUT_POLARITY`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPTIM_ConfigOutput()`]\n\n"]
    pub Polarity: u32,
}
#[test]
fn bindgen_test_layout_LL_LPTIM_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPTIM_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPTIM_InitTypeDef>(),
        16usize,
        concat!("Size of: ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPTIM_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPTIM_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClockSource) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(ClockSource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Prescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Prescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Waveform) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Waveform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Polarity) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPTIM_InitTypeDef),
            "::",
            stringify!(Polarity)
        )
    );
}
extern "C" {
    pub fn LL_LPTIM_DeInit(LPTIMx: *mut LPTIM_TypeDef) -> ErrorStatus;
}
extern "C" {
    pub fn LL_LPTIM_Init(
        LPTIMx: *mut LPTIM_TypeDef,
        LPTIM_InitStruct: *const LL_LPTIM_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "LL LPUART Init Structure definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_LPUART_InitTypeDef {
    #[doc = "Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of  [`LPUART_LL_EC_PRESCALER`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetPrescaler()`]\n\n"]
    pub PrescalerValue: u32,
    #[doc = "This field defines expected LPUART communication baud rate.\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetBaudRate()`]\n\n"]
    pub BaudRate: u32,
    #[doc = "Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of  [`LPUART_LL_EC_DATAWIDTH`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetDataWidth()`]\n\n"]
    pub DataWidth: u32,
    #[doc = "Specifies the number of stop bits transmitted.\nThis parameter can be a value of  [`LPUART_LL_EC_STOPBITS`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetStopBitsLength()`]\n\n"]
    pub StopBits: u32,
    #[doc = "Specifies the parity mode.\nThis parameter can be a value of  [`LPUART_LL_EC_PARITY`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetParity()`]\n\n"]
    pub Parity: u32,
    #[doc = "Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of  [`LPUART_LL_EC_DIRECTION`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetTransferDirection()`]\n\n"]
    pub TransferDirection: u32,
    #[doc = "Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of  [`LPUART_LL_EC_HWCONTROL`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_LPUART_SetHWFlowCtrl()`]\n\n"]
    pub HardwareFlowControl: u32,
}
#[test]
fn bindgen_test_layout_LL_LPUART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_LPUART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_LPUART_InitTypeDef>(),
        28usize,
        concat!("Size of: ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_LPUART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_LPUART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_LPUART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
}
extern "C" {
    pub fn LL_LPUART_Init(
        LPUARTx: *mut USART_TypeDef,
        LPUART_InitStruct: *const LL_LPUART_InitTypeDef,
    ) -> ErrorStatus;
}
#[doc = "RTC Init structures definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_RTC_InitTypeDef {
    #[doc = "Specifies the RTC Hours Format.\nThis parameter can be a value of  [`RTC_LL_EC_HOURFORMAT`]\nThis feature can be modified afterwards using unitary function [`LL_RTC_SetHourFormat()`]\n\n"]
    pub HourFormat: u32,
    #[doc = "Specifies the RTC Asynchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7F\nThis feature can be modified afterwards using unitary function [`LL_RTC_SetAsynchPrescaler()`]\n\n"]
    pub AsynchPrescaler: u32,
    #[doc = "Specifies the RTC Synchronous Predivider value.\nThis parameter must be a number between Min_Data = 0x00 and Max_Data = 0x7FFF\nThis feature can be modified afterwards using unitary function [`LL_RTC_SetSynchPrescaler()`]\n\n"]
    pub SynchPrescaler: u32,
}
#[test]
fn bindgen_test_layout_LL_RTC_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_RTC_InitTypeDef> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_RTC_InitTypeDef>(),
        12usize,
        concat!("Size of: ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_RTC_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_RTC_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HourFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(HourFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchPrescaler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(AsynchPrescaler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SynchPrescaler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_RTC_InitTypeDef),
            "::",
            stringify!(SynchPrescaler)
        )
    );
}
extern "C" {
    pub fn LL_RTC_Init(
        RTCx: *mut RTC_TypeDef,
        RTC_InitStruct: *mut LL_RTC_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_RTC_EnterInitMode(RTCx: *mut RTC_TypeDef) -> ErrorStatus;
}
#[doc = "LL USART Init Structure definition\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LL_USART_InitTypeDef {
    #[doc = "Specifies the Prescaler to compute the communication baud rate.\nThis parameter can be a value of  [`USART_LL_EC_PRESCALER`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetPrescaler()`]\n\n"]
    pub PrescalerValue: u32,
    #[doc = "This field defines expected Usart communication baud rate.\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetBaudRate()`]\n\n"]
    pub BaudRate: u32,
    #[doc = "Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of  [`USART_LL_EC_DATAWIDTH`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetDataWidth()`]\n\n"]
    pub DataWidth: u32,
    #[doc = "Specifies the number of stop bits transmitted.\nThis parameter can be a value of  [`USART_LL_EC_STOPBITS`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetStopBitsLength()`]\n\n"]
    pub StopBits: u32,
    #[doc = "Specifies the parity mode.\nThis parameter can be a value of  [`USART_LL_EC_PARITY`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetParity()`]\n\n"]
    pub Parity: u32,
    #[doc = "Specifies whether the Receive and/or Transmit mode is enabled or disabled.\nThis parameter can be a value of  [`USART_LL_EC_DIRECTION`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetTransferDirection()`]\n\n"]
    pub TransferDirection: u32,
    #[doc = "Specifies whether the hardware flow control mode is enabled or disabled.\nThis parameter can be a value of  [`USART_LL_EC_HWCONTROL`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetHWFlowCtrl()`]\n\n"]
    pub HardwareFlowControl: u32,
    #[doc = "Specifies whether USART oversampling mode is 16 or 8.\nThis parameter can be a value of  [`USART_LL_EC_OVERSAMPLING`]\nThis feature can be modified afterwards using unitary\nfunction  [`LL_USART_SetOverSampling()`]\n\n"]
    pub OverSampling: u32,
}
#[test]
fn bindgen_test_layout_LL_USART_InitTypeDef() {
    const UNINIT: ::core::mem::MaybeUninit<LL_USART_InitTypeDef> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<LL_USART_InitTypeDef>(),
        32usize,
        concat!("Size of: ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        ::core::mem::align_of::<LL_USART_InitTypeDef>(),
        4usize,
        concat!("Alignment of ", stringify!(LL_USART_InitTypeDef))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PrescalerValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(PrescalerValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaudRate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(BaudRate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataWidth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(DataWidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StopBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(StopBits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(Parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TransferDirection) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(TransferDirection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HardwareFlowControl) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(HardwareFlowControl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OverSampling) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LL_USART_InitTypeDef),
            "::",
            stringify!(OverSampling)
        )
    );
}
extern "C" {
    pub fn LL_USART_Init(
        USARTx: *mut USART_TypeDef,
        USART_InitStruct: *const LL_USART_InitTypeDef,
    ) -> ErrorStatus;
}
extern "C" {
    pub fn LL_SetSystemCoreClock(HCLKFrequency: u32);
}
extern "C" {
    pub fn subghz_custom_btn_set(btn_id: u8) -> bool;
}
extern "C" {
    pub fn subghz_custom_btn_get() -> u8;
}
extern "C" {
    pub fn subghz_custom_btn_get_original() -> u8;
}
extern "C" {
    pub fn subghz_custom_btns_reset();
}
extern "C" {
    pub fn subghz_custom_btn_is_allowed() -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockDecoder {
    pub parser_step: u32,
    pub te_last: u32,
    pub decode_data: u64,
    pub decode_count_bit: u8,
}
#[test]
fn bindgen_test_layout_SubGhzBlockDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockDecoder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockDecoder>(),
        24usize,
        concat!("Size of: ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockDecoder>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parser_step) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(parser_step)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).te_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(te_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decode_count_bit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockDecoder),
            "::",
            stringify!(decode_count_bit)
        )
    );
}
extern "C" {
    #[doc = "Add data bit when decoding.\n\n# Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n* `bit` - data, 1bit\n\n"]
    pub fn subghz_protocol_blocks_add_bit(decoder: *mut SubGhzBlockDecoder, bit: u8);
}
extern "C" {
    #[doc = "Add data to_128 bit when decoding.\n\n# Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n* `head_64_bit` - Pointer to a head_64_bit\n* `bit` - data, 1bit\n\n"]
    pub fn subghz_protocol_blocks_add_to_128_bit(
        decoder: *mut SubGhzBlockDecoder,
        bit: u8,
        head_64_bit: *mut u64,
    );
}
extern "C" {
    #[doc = "Getting the hash sum of the last randomly received parcel.\n\nReturns:\n\n* hash Hash sum\n\n# Arguments\n\n* `decoder` - Pointer to a SubGhzBlockDecoder instance\n\n"]
    pub fn subghz_protocol_blocks_get_hash_data(decoder: *mut SubGhzBlockDecoder, len: usize)
        -> u8;
}
pub const SubGhzProtocolBlockAlignBit_SubGhzProtocolBlockAlignBitLeft: SubGhzProtocolBlockAlignBit =
    0;
pub const SubGhzProtocolBlockAlignBit_SubGhzProtocolBlockAlignBitRight:
    SubGhzProtocolBlockAlignBit = 1;
pub type SubGhzProtocolBlockAlignBit = core::ffi::c_uchar;
extern "C" {
    #[doc = "Set data bit when encoding HEX array.\n\n# Arguments\n\n* `bit_value` - The value of the bit to be set\n* `data_array` - Pointer to a HEX array\n* `set_index_bit` - Number set a bit in the array starting from the left\n* `max_size_array` - array size, check not to overflow\n\n"]
    pub fn subghz_protocol_blocks_set_bit_array(
        bit_value: bool,
        data_array: *mut u8,
        set_index_bit: usize,
        max_size_array: usize,
    );
}
extern "C" {
    #[doc = "Get data bit when encoding HEX array.\n\nReturns:\n\n* bool value bit\n\n# Arguments\n\n* `data_array` - Pointer to a HEX array\n* `read_index_bit` - Number get a bit in the array starting from the left\n\n"]
    pub fn subghz_protocol_blocks_get_bit_array(data_array: *mut u8, read_index_bit: usize)
        -> bool;
}
extern "C" {
    #[doc = "Generating an upload from data.\n\n# Arguments\n\n* `data_array` - Pointer to a HEX array\n* `count_bit_data_array` - How many bits in the array are processed\n* `upload` - Pointer to a LevelDuration\n* `max_size_upload` - upload size, check not to overflow\n* `duration_bit` - duration 1 bit\n* `align_bit` - alignment of useful bits in an array\n\n"]
    pub fn subghz_protocol_blocks_get_upload_from_bit_array(
        data_array: *mut u8,
        count_bit_data_array: usize,
        upload: *mut LevelDuration,
        max_size_upload: usize,
        duration_bit: u32,
        align_bit: SubGhzProtocolBlockAlignBit,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzEnvironment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolRegistry {
    pub items: *mut *const SubGhzProtocol,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolRegistry() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolRegistry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolRegistry>(),
        8usize,
        concat!("Size of: ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolRegistry>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolRegistry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolRegistry),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = "Registration by name SubGhzProtocol.\n\nReturns:\n\n* SubGhzProtocol* pointer to a SubGhzProtocol instance\n\n# Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n* `name` - Protocol name\n\n"]
    pub fn subghz_protocol_registry_get_by_name(
        protocol_registry: *const SubGhzProtocolRegistry,
        name: *const core::ffi::c_char,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = "Registration protocol by index in array SubGhzProtocol.\n\nReturns:\n\n* SubGhzProtocol* pointer to a SubGhzProtocol instance\n\n# Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n* `index` - Protocol by index in array\n\n"]
    pub fn subghz_protocol_registry_get_by_index(
        protocol_registry: *const SubGhzProtocolRegistry,
        index: usize,
    ) -> *const SubGhzProtocol;
}
extern "C" {
    #[doc = "Getting the number of registered protocols.\n\nReturns:\n\n* Number of protocols\n\n# Arguments\n\n* `protocol_registry` - SubGhzProtocolRegistry\n\n"]
    pub fn subghz_protocol_registry_count(
        protocol_registry: *const SubGhzProtocolRegistry,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzKeystore {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate SubGhzEnvironment.\n\nReturns:\n\n* SubGhzEnvironment* pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_alloc() -> *mut SubGhzEnvironment;
}
extern "C" {
    #[doc = "Free SubGhzEnvironment.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_free(instance: *mut SubGhzEnvironment);
}
extern "C" {
    #[doc = "Downloading the manufacture key file.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `filename` - Full path to the file\n\n"]
    pub fn subghz_environment_load_keystore(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Get pointer to a SubGhzKeystore* instance.\n\nReturns:\n\n* SubGhzEnvironment* pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_get_keystore(instance: *mut SubGhzEnvironment)
        -> *mut SubGhzKeystore;
}
extern "C" {
    #[doc = "Set filename to work with Came Atomo.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `filename` - Full path to the file\n\n"]
    pub fn subghz_environment_set_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Get filename to work with Came Atomo.\n\nReturns:\n\n* Full path to the file\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_get_came_atomo_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Set filename to work with Alutech at-4n.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `filename` - Full path to the file\n\n"]
    pub fn subghz_environment_set_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Get filename to work with Alutech at-4n.\n\nReturns:\n\n* Full path to the file\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_get_alutech_at_4n_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Set filename to work with Nice Flor-S.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `filename` - Full path to the file\n\n"]
    pub fn subghz_environment_set_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
        filename: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Get filename to work with Nice Flor-S.\n\nReturns:\n\n* Full path to the file\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_get_nice_flor_s_rainbow_table_file_name(
        instance: *mut SubGhzEnvironment,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Set list of protocols to work.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `protocol_registry_items` - Pointer to a SubGhzProtocolRegistry\n\n"]
    pub fn subghz_environment_set_protocol_registry(
        instance: *mut SubGhzEnvironment,
        protocol_registry_items: *const SubGhzProtocolRegistry,
    );
}
extern "C" {
    #[doc = "Get list of protocols to work.\n\nReturns:\n\n* Pointer to a SubGhzProtocolRegistry\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_get_protocol_registry(
        instance: *mut SubGhzEnvironment,
    ) -> *const SubGhzProtocolRegistry;
}
extern "C" {
    #[doc = "Get list of protocols names.\n\nReturns:\n\n* Pointer to a SubGhzProtocolRegistry\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n* `idx` - index protocols\n\n"]
    pub fn subghz_environment_get_protocol_name_registry(
        instance: *mut SubGhzEnvironment,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = "Resetting the parameters used in the keeloq protocol.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_environment_reset_keeloq(instance: *mut SubGhzEnvironment);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzRadioPreset {
    pub name: *mut FuriString,
    pub frequency: u32,
    pub data: *mut u8,
    pub data_size: usize,
    pub latitude: f32,
    pub longitude: f32,
}
#[test]
fn bindgen_test_layout_SubGhzRadioPreset() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzRadioPreset> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzRadioPreset>(),
        24usize,
        concat!("Size of: ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzRadioPreset>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzRadioPreset))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frequency) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzRadioPreset),
            "::",
            stringify!(longitude)
        )
    );
}
pub const SubGhzProtocolStatus_SubGhzProtocolStatusOk: SubGhzProtocolStatus = 0;
#[doc = "General unclassified error\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusError: SubGhzProtocolStatus = -1;
#[doc = "Missing or invalid file header\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserHeader: SubGhzProtocolStatus = -2;
#[doc = "Missing `Frequency`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserFrequency: SubGhzProtocolStatus = -3;
#[doc = "Missing `Preset`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserPreset: SubGhzProtocolStatus = -4;
#[doc = "Missing `Custom_preset_module`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserCustomPreset: SubGhzProtocolStatus =
    -5;
#[doc = "Missing `Protocol` name\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserProtocolName: SubGhzProtocolStatus =
    -6;
#[doc = "Missing `Bit`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserBitCount: SubGhzProtocolStatus = -7;
#[doc = "Missing `Key`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserKey: SubGhzProtocolStatus = -8;
#[doc = "Missing `Te`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserTe: SubGhzProtocolStatus = -9;
#[doc = "Missing some other mandatory keys\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserOthers: SubGhzProtocolStatus = -10;
#[doc = "Invalid bit count value\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorValueBitCount: SubGhzProtocolStatus = -11;
#[doc = "Payload encoder failure\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorEncoderGetUpload: SubGhzProtocolStatus =
    -12;
#[doc = "Protocol not found\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorProtocolNotFound: SubGhzProtocolStatus =
    -13;
#[doc = "Missing `Latitude`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserLatitude: SubGhzProtocolStatus = -14;
#[doc = "Missing `Longitude`\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusErrorParserLongitude: SubGhzProtocolStatus = -15;
#[doc = "Prevents enum down-size compiler optimization.\n\n"]
pub const SubGhzProtocolStatus_SubGhzProtocolStatusReserved: SubGhzProtocolStatus = 2147483647;
pub type SubGhzProtocolStatus = core::ffi::c_int;
pub type SubGhzAlloc = ::core::option::Option<
    unsafe extern "C" fn(environment: *mut SubGhzEnvironment) -> *mut core::ffi::c_void,
>;
pub type SubGhzFree = ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzSerialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus,
>;
pub type SubGhzDeserialize = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus,
>;
pub type SubGhzDecoderFeed = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, level: bool, duration: u32),
>;
pub type SubGhzDecoderReset =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void)>;
pub type SubGhzGetHashData =
    ::core::option::Option<unsafe extern "C" fn(decoder: *mut core::ffi::c_void) -> u8>;
pub type SubGhzGetString = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut core::ffi::c_void, output: *mut FuriString),
>;
pub type SubGhzEncoderStop =
    ::core::option::Option<unsafe extern "C" fn(encoder: *mut core::ffi::c_void)>;
pub type SubGhzEncoderYield =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void) -> LevelDuration>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub feed: SubGhzDecoderFeed,
    pub reset: SubGhzDecoderReset,
    pub get_hash_data: SubGhzGetHashData,
    pub get_string: SubGhzGetString,
    pub serialize: SubGhzSerialize,
    pub deserialize: SubGhzDeserialize,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoder>(),
        32usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoder>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(feed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_hash_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_hash_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoder),
            "::",
            stringify!(deserialize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoder {
    pub alloc: SubGhzAlloc,
    pub free: SubGhzFree,
    pub deserialize: SubGhzDeserialize,
    pub stop: SubGhzEncoderStop,
    pub yield_: SubGhzEncoderYield,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoder() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoder> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoder>(),
        20usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoder>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yield_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoder),
            "::",
            stringify!(yield_)
        )
    );
}
pub const SubGhzProtocolType_SubGhzProtocolTypeUnknown: SubGhzProtocolType = 0;
pub const SubGhzProtocolType_SubGhzProtocolTypeStatic: SubGhzProtocolType = 1;
pub const SubGhzProtocolType_SubGhzProtocolTypeDynamic: SubGhzProtocolType = 2;
pub const SubGhzProtocolType_SubGhzProtocolTypeRAW: SubGhzProtocolType = 3;
pub const SubGhzProtocolType_SubGhzProtocolWeatherStation: SubGhzProtocolType = 4;
pub const SubGhzProtocolType_SubGhzProtocolCustom: SubGhzProtocolType = 5;
pub const SubGhzProtocolType_SubGhzProtocolTypeBinRAW: SubGhzProtocolType = 6;
pub type SubGhzProtocolType = core::ffi::c_uchar;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_RAW: SubGhzProtocolFlag = 1;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Decodable: SubGhzProtocolFlag = 2;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_315: SubGhzProtocolFlag = 4;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_433: SubGhzProtocolFlag = 8;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_868: SubGhzProtocolFlag = 16;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_AM: SubGhzProtocolFlag = 32;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_FM: SubGhzProtocolFlag = 64;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Save: SubGhzProtocolFlag = 128;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Load: SubGhzProtocolFlag = 256;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_Send: SubGhzProtocolFlag = 512;
pub const SubGhzProtocolFlag_SubGhzProtocolFlag_BinRAW: SubGhzProtocolFlag = 1024;
pub type SubGhzProtocolFlag = core::ffi::c_ushort;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_StarLine: SubGhzProtocolFilter = 1;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_AutoAlarms: SubGhzProtocolFilter = 2;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_Magellan: SubGhzProtocolFilter = 4;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_Princeton: SubGhzProtocolFilter = 8;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_NiceFlorS: SubGhzProtocolFilter = 16;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_Weather: SubGhzProtocolFilter = 32;
pub const SubGhzProtocolFilter_SubGhzProtocolFilter_TPMS: SubGhzProtocolFilter = 64;
pub type SubGhzProtocolFilter = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocol {
    pub name: *const core::ffi::c_char,
    pub type_: SubGhzProtocolType,
    pub flag: SubGhzProtocolFlag,
    pub encoder: *const SubGhzProtocolEncoder,
    pub decoder: *const SubGhzProtocolDecoder,
    pub filter: SubGhzProtocolFilter,
}
#[test]
fn bindgen_test_layout_SubGhzProtocol() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocol> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocol>(),
        20usize,
        concat!("Size of: ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocol>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocol))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(decoder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocol),
            "::",
            stringify!(filter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzBlockGeneric {
    pub protocol_name: *const core::ffi::c_char,
    pub latitude: f32,
    pub longitude: f32,
    pub data: u64,
    pub data_2: u64,
    pub serial: u32,
    pub data_count_bit: u16,
    pub btn: u8,
    pub cnt: u32,
    pub cnt_2: u8,
    pub seed: u32,
}
#[test]
fn bindgen_test_layout_SubGhzBlockGeneric() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzBlockGeneric> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzBlockGeneric>(),
        56usize,
        concat!("Size of: ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzBlockGeneric>(),
        8usize,
        concat!("Alignment of ", stringify!(SubGhzBlockGeneric))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(protocol_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latitude) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).longitude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(longitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_count_bit) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(data_count_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).btn) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(btn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt_2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(cnt_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzBlockGeneric),
            "::",
            stringify!(seed)
        )
    );
}
extern "C" {
    #[doc = "Get name preset.\n\n# Arguments\n\n* `preset_name` - name preset\n* `preset_str` - Output name preset\n\n"]
    pub fn subghz_block_generic_get_preset_name(
        preset_name: *const core::ffi::c_char,
        preset_str: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Serialize data SubGhzBlockGeneric.\n\nReturns:\n\n* Status Error\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n\n"]
    pub fn subghz_block_generic_serialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Deserialize data SubGhzBlockGeneric.\n\nReturns:\n\n* Status Error\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn subghz_block_generic_deserialize(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Deserialize data SubGhzBlockGeneric.\n\nReturns:\n\n* Status Error\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzBlockGeneric instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `count_bit` - Count bit protocol\n\n"]
    pub fn subghz_block_generic_deserialize_check_count_bit(
        instance: *mut SubGhzBlockGeneric,
        flipper_format: *mut FlipperFormat,
        count_bit: u16,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Flip the data bitwise\n\nReturns:\n\n* Reverse data\n\n# Arguments\n\n* `key` - In data\n* `bit_count` - number of data bits\n\n"]
    pub fn subghz_protocol_blocks_reverse_key(key: u64, bit_count: u8) -> u64;
}
extern "C" {
    #[doc = "Get parity the data bitwise\n\nReturns:\n\n* parity\n\n# Arguments\n\n* `key` - In data\n* `bit_count` - number of data bits\n\n"]
    pub fn subghz_protocol_blocks_get_parity(key: u64, bit_count: u8) -> u8;
}
extern "C" {
    #[doc = "CRC-4\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - CRC polynomial\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc4(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "CRC-7\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - CRC polynomial\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc7(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "Generic Cyclic Redundancy Check CRC-8. Example polynomial: 0x31 = x8 + x5 + x4 + 1 (x8 is implicit) Example polynomial: 0x80 = x8 + x7 (a normal bit-by-bit parity XOR)\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - byte is from x^7 to x^0 (x^8 is implicitly one)\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc8(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "\"Little-endian\" Cyclic Redundancy Check CRC-8 LE Input and output are reflected, i.e. least significant bit is shifted in first\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - CRC polynomial\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc8le(
        message: *const u8,
        size: usize,
        polynomial: u8,
        init: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "CRC-16 LSB. Input and output are reflected, i.e. least significant bit is shifted in first. Note that poly and init already need to be reflected\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - CRC polynomial\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc16lsb(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = "CRC-16\n\nReturns:\n\n* CRC value\n\n# Arguments\n\n* `message` - array of bytes to check\n* `size` - number of bytes in message\n* `polynomial` - CRC polynomial\n* `init` - starting crc value\n\n"]
    pub fn subghz_protocol_blocks_crc16(
        message: *const u8,
        size: usize,
        polynomial: u16,
        init: u16,
    ) -> u16;
}
extern "C" {
    #[doc = "Digest-8 by \"LFSR-based Toeplitz hash\"\n\nReturns:\n\n* digest value\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to digest\n* `gen` - key stream generator, needs to includes the MSB if the LFSR is rolling\n* `key` - initial key\n\n"]
    pub fn subghz_protocol_blocks_lfsr_digest8(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "Digest-8 by \"LFSR-based Toeplitz hash\", byte reflect, bit reflect\n\nReturns:\n\n* digest value\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to digest\n* `gen` - key stream generator, needs to includes the MSB if the LFSR is rolling\n* `key` - initial key\n\n"]
    pub fn subghz_protocol_blocks_lfsr_digest8_reflect(
        message: *const u8,
        size: usize,
        gen: u8,
        key: u8,
    ) -> u8;
}
extern "C" {
    #[doc = "Digest-16 by \"LFSR-based Toeplitz hash\"\n\nReturns:\n\n* digest value\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to digest\n* `gen` - key stream generator, needs to includes the MSB if the LFSR is rolling\n* `key` - initial key\n\n"]
    pub fn subghz_protocol_blocks_lfsr_digest16(
        message: *const u8,
        size: usize,
        gen: u16,
        key: u16,
    ) -> u16;
}
extern "C" {
    #[doc = "Compute Addition of a number of bytes\n\nReturns:\n\n* summation value\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to sum\n\n"]
    pub fn subghz_protocol_blocks_add_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = "Compute bit parity of a single byte (8 bits)\n\nReturns:\n\n* 1 odd parity, 0 even parity\n\n# Arguments\n\n* `byte` - single byte to check\n\n"]
    pub fn subghz_protocol_blocks_parity8(byte: u8) -> u8;
}
extern "C" {
    #[doc = "Compute bit parity of a number of bytes\n\nReturns:\n\n* 1 odd parity, 0 even parity\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to sum\n\n"]
    pub fn subghz_protocol_blocks_parity_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    #[doc = "Compute XOR (byte-wide parity) of a number of bytes\n\nReturns:\n\n* summation value, per bit-position 1 odd parity, 0 even parity\n\n# Arguments\n\n* `message` - bytes of message data\n* `size` - number of bytes to sum\n\n"]
    pub fn subghz_protocol_blocks_xor_bytes(message: *const u8, size: usize) -> u8;
}
extern "C" {
    pub static subghz_device_cc1101_preset_ook_270khz_async_regs: [u8; 0usize];
}
extern "C" {
    pub static subghz_device_cc1101_preset_ook_650khz_async_regs: [u8; 0usize];
}
extern "C" {
    pub static subghz_device_cc1101_preset_2fsk_dev2_38khz_async_regs: [u8; 0usize];
}
extern "C" {
    pub static subghz_device_cc1101_preset_2fsk_dev47_6khz_async_regs: [u8; 0usize];
}
extern "C" {
    pub static subghz_device_cc1101_preset_msk_99_97kb_async_regs: [u8; 0usize];
}
extern "C" {
    pub static subghz_device_cc1101_preset_gfsk_9_99kb_async_regs: [u8; 0usize];
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderSecPlus_v2 instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 32 bit\n* `btn` - Button number, 8 bit\n* `cnt` - Container value, 28 bit\n* `manufacture_name` - Name of manufacturer's key\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_secplus_v2_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u32,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderKeeloq instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 28 bit\n* `btn` - Button number, 4 bit\n* `cnt` - Counter value, 16 bit\n* `manufacture_name` - Name of manufacturer's key\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_keeloq_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        manufacture_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation for BFT.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderKeeloq instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 28 bit\n* `btn` - Button number, 4 bit\n* `cnt` - Counter value, 16 bit\n* `seed` - Seed value, 32 bit\n* `manufacture_name` - Name of manufacturer's key\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_keeloq_bft_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        seed: u32,
        manufacture_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderFaacSLH instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 28 bit\n* `btn` - Button number, 4 bit\n* `cnt` - Counter value, 16 bit\n* `seed` - Seed value, 32 bit\n* `manufacture_name` - Name of manufacturer's key\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_faac_slh_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u32,
        seed: u32,
        manufacture_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderAlutech_at_4n instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 24 bit\n* `btn` - Button number, 8 bit\n* `cnt` - Counter value, 16 bit\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_alutech_at_4n_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderCameAtomo instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 24 bit\n* `cnt` - Counter value, 16 bit\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_came_atomo_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        cnt: u16,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "New remote generation.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderNiceFlorS instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number\n* `btn` - Button number, 4 bit\n* `cnt` - Counter value, 16 bit\n* `preset` - Modulation, SubGhzRadioPreset\n* `nice_one` - Nice One if true, Nice Flor S if false\n\n"]
    pub fn subghz_protocol_nice_flor_s_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        preset: *mut SubGhzRadioPreset,
        nice_one: bool,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderStarLine instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 24 bit\n* `btn` - Button number, 8 bit\n* `cnt` - Counter value, 16 bit\n* `manufacture_name` - Name of manufacturer's key\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_star_line_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        manufacture_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderSomfyTelis instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 24 bit\n* `btn` - Button number, 8 bit\n* `cnt` - Counter value, 16 bit\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_somfy_telis_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Key generation from simple data.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderSomfyKeytis instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `serial` - Serial number, 24 bit\n* `btn` - Button number, 8 bit\n* `cnt` - Counter value, 16 bit\n* `preset` - Modulation, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_somfy_keytis_create_data(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
        serial: u32,
        btn: u8,
        cnt: u16,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBinRAW {
    _unused: [u8; 0],
}
extern "C" {
    pub fn subghz_protocol_decoder_bin_raw_data_input_rssi(
        instance: *mut SubGhzProtocolDecoderBinRAW,
        rssi: f32,
    );
}
extern "C" {
    #[doc = "Validation of fixed parts SubGhzProtocolDecoderSecPlus_v1.\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `fixed` - fixed parts\n\n"]
    pub fn subghz_protocol_secplus_v1_check_fixed(fixed: u32) -> bool;
}
pub type SubGhzProtocolDecoderBaseRxCallback = ::core::option::Option<
    unsafe extern "C" fn(instance: *mut SubGhzProtocolDecoderBase, context: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderBase {
    pub protocol: *const SubGhzProtocol,
    pub callback: SubGhzProtocolDecoderBaseRxCallback,
    pub context: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolDecoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolDecoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolDecoderBase>(),
        12usize,
        concat!("Size of: ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolDecoderBase>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolDecoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolDecoderBase),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = "Getting a textual representation of the received data.\n\n# Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n* `output` - Resulting text\n\n"]
    pub fn subghz_protocol_decoder_base_get_string(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        output: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Serialize data SubGhzProtocolDecoderBase.\n\nReturns:\n\n* Status Error\n\n# Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_decoder_base_serialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
        preset: *mut SubGhzRadioPreset,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Deserialize data SubGhzProtocolDecoderBase.\n\nReturns:\n\n* Status Error\n\n# Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn subghz_protocol_decoder_base_deserialize(
        decoder_base: *mut SubGhzProtocolDecoderBase,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Getting the hash sum of the last randomly received parcel.\n\nReturns:\n\n* hash Hash sum\n\n# Arguments\n\n* `decoder_base` - Pointer to a SubGhzProtocolDecoderBase instance\n\n"]
    pub fn subghz_protocol_decoder_base_get_hash_data(
        decoder_base: *mut SubGhzProtocolDecoderBase,
    ) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderBase {
    pub protocol: *const SubGhzProtocol,
}
#[test]
fn bindgen_test_layout_SubGhzProtocolEncoderBase() {
    const UNINIT: ::core::mem::MaybeUninit<SubGhzProtocolEncoderBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SubGhzProtocolEncoderBase>(),
        4usize,
        concat!("Size of: ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        ::core::mem::align_of::<SubGhzProtocolEncoderBase>(),
        4usize,
        concat!("Alignment of ", stringify!(SubGhzProtocolEncoderBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).protocol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SubGhzProtocolEncoderBase),
            "::",
            stringify!(protocol)
        )
    );
}
pub type SubGhzProtocolEncoderRAWCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolDecoderRAW {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzProtocolEncoderRAW {
    _unused: [u8; 0],
}
extern "C" {
    pub static subghz_protocol_raw_decoder: SubGhzProtocolDecoder;
}
extern "C" {
    pub static subghz_protocol_raw_encoder: SubGhzProtocolEncoder;
}
extern "C" {
    pub static subghz_protocol_raw: SubGhzProtocol;
}
extern "C" {
    #[doc = "Open file for writing\n\nReturns:\n\n* true On success\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance\n* `dev_name` - File name\n* `preset` - The modulation on which the signal was received, SubGhzRadioPreset\n\n"]
    pub fn subghz_protocol_raw_save_to_file_init(
        instance: *mut SubGhzProtocolDecoderRAW,
        dev_name: *const core::ffi::c_char,
        preset: *mut SubGhzRadioPreset,
    ) -> bool;
}
extern "C" {
    #[doc = "Stop writing file to flash\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance\n\n"]
    pub fn subghz_protocol_raw_save_to_file_stop(instance: *mut SubGhzProtocolDecoderRAW);
}
extern "C" {
    #[doc = "Get the number of samples received SubGhzProtocolDecoderRAW.\n\nReturns:\n\n* count of samples\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzProtocolDecoderRAW instance\n\n"]
    pub fn subghz_protocol_raw_get_sample_write(instance: *mut SubGhzProtocolDecoderRAW) -> usize;
}
extern "C" {
    #[doc = "Allocate SubGhzProtocolDecoderRAW.\n\nReturns:\n\n* SubGhzProtocolDecoderRAW* pointer to a SubGhzProtocolDecoderRAW instance\n\n# Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_protocol_decoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Free SubGhzProtocolDecoderRAW.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n\n"]
    pub fn subghz_protocol_decoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Reset decoder SubGhzProtocolDecoderRAW.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n\n"]
    pub fn subghz_protocol_decoder_raw_reset(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Parse a raw sequence of levels and durations received from the air.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n* `level` - Signal level true-high false-low\n* `duration` - Duration of this level in, us\n\n"]
    pub fn subghz_protocol_decoder_raw_feed(
        context: *mut core::ffi::c_void,
        level: bool,
        duration: u32,
    );
}
extern "C" {
    #[doc = "Deserialize data SubGhzProtocolDecoderRAW.\n\nReturns:\n\n* status\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn subghz_protocol_decoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Getting a textual representation of the received data.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolDecoderRAW instance\n* `output` - Resulting text\n\n"]
    pub fn subghz_protocol_decoder_raw_get_string(
        context: *mut core::ffi::c_void,
        output: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Allocate SubGhzProtocolEncoderRAW.\n\nReturns:\n\n* SubGhzProtocolEncoderRAW* pointer to a SubGhzProtocolEncoderRAW instance\n\n# Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_protocol_encoder_raw_alloc(
        environment: *mut SubGhzEnvironment,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Free SubGhzProtocolEncoderRAW.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n\n"]
    pub fn subghz_protocol_encoder_raw_free(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Forced transmission stop.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n\n"]
    pub fn subghz_protocol_encoder_raw_stop(context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "pause writing to flash.\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n* `pause` - pause writing\n\n"]
    pub fn subghz_protocol_raw_save_to_file_pause(
        instance: *mut SubGhzProtocolDecoderRAW,
        pause: bool,
    );
}
extern "C" {
    #[doc = "Set callback on completion of file transfer.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzProtocolEncoderRAW instance\n* `callback_end` - Callback, SubGhzProtocolEncoderRAWCallbackEnd\n* `context_end` - Context\n\n"]
    pub fn subghz_protocol_raw_file_encoder_worker_set_callback_end(
        instance: *mut SubGhzProtocolEncoderRAW,
        callback_end: SubGhzProtocolEncoderRAWCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "File generation for RAW work.\n\n# Arguments\n\n* `flipper_format` - Pointer to a FlipperFormat instance\n* `file_path` - File path\n* `radio_dev_name` - Radio device name\n\n"]
    pub fn subghz_protocol_raw_gen_fff_data(
        flipper_format: *mut FlipperFormat,
        file_path: *const core::ffi::c_char,
        radio_dev_name: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Deserialize and generating an upload to send.\n\nReturns:\n\n* status\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn subghz_protocol_encoder_raw_deserialize(
        context: *mut core::ffi::c_void,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n\nReturns:\n\n* LevelDuration\n\n# Arguments\n\n* `context` - Pointer to a SubGhzProtocolEncoderRAW instance\n\n"]
    pub fn subghz_protocol_encoder_raw_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzReceiver {
    _unused: [u8; 0],
}
pub type SubGhzReceiverCallback = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut SubGhzReceiver,
        decoder_base: *mut SubGhzProtocolDecoderBase,
        context: *mut core::ffi::c_void,
    ),
>;
extern "C" {
    #[doc = "Allocate and init SubGhzReceiver.\n\nReturns:\n\n* SubGhzReceiver* pointer to a SubGhzReceiver instance\n\n# Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_receiver_alloc_init(environment: *mut SubGhzEnvironment) -> *mut SubGhzReceiver;
}
extern "C" {
    #[doc = "Free SubGhzReceiver.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n\n"]
    pub fn subghz_receiver_free(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = "Parse a raw sequence of levels and durations received from the air.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n* `level` - Signal level true-high false-low\n* `duration` - Duration of this level in, us\n\n"]
    pub fn subghz_receiver_decode(instance: *mut SubGhzReceiver, level: bool, duration: u32);
}
extern "C" {
    #[doc = "Reset decoder SubGhzReceiver.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n\n"]
    pub fn subghz_receiver_reset(instance: *mut SubGhzReceiver);
}
extern "C" {
    #[doc = "Set a callback upon completion of successful decoding of one of the protocols.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n* `callback` - Callback, SubGhzReceiverCallback\n* `context` - Context\n\n"]
    pub fn subghz_receiver_set_rx_callback(
        instance: *mut SubGhzReceiver,
        callback: SubGhzReceiverCallback,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set the filter of receivers that will work at the moment.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n* `filter` - Filter, SubGhzProtocolFlag\n\n"]
    pub fn subghz_receiver_set_filter(instance: *mut SubGhzReceiver, filter: SubGhzProtocolFlag);
}
extern "C" {
    #[doc = "Search for a cattery by his name.\n\nReturns:\n\n* SubGhzProtocolDecoderBase* pointer to a SubGhzProtocolDecoderBase instance\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzReceiver instance\n* `decoder_name` - Receiver name\n\n"]
    pub fn subghz_receiver_search_decoder_base_by_name(
        instance: *mut SubGhzReceiver,
        decoder_name: *const core::ffi::c_char,
    ) -> *mut SubGhzProtocolDecoderBase;
}
pub type SubGhzFileEncoderWorkerCallbackEnd =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzFileEncoderWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "End callback SubGhzWorker.\n\n# Arguments\n\n* `instance` - SubGhzFileEncoderWorker instance\n* `callback` - SubGhzFileEncoderWorkerCallbackEnd callback\n\n"]
    pub fn subghz_file_encoder_worker_callback_end(
        instance: *mut SubGhzFileEncoderWorker,
        callback_end: SubGhzFileEncoderWorkerCallbackEnd,
        context_end: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Allocate SubGhzFileEncoderWorker.\n\nReturns:\n\n* SubGhzFileEncoderWorker* pointer to a SubGhzFileEncoderWorker instance\n\n"]
    pub fn subghz_file_encoder_worker_alloc() -> *mut SubGhzFileEncoderWorker;
}
extern "C" {
    #[doc = "Free SubGhzFileEncoderWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n\n"]
    pub fn subghz_file_encoder_worker_free(instance: *mut SubGhzFileEncoderWorker);
}
extern "C" {
    #[doc = "Get a description of the progress.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n* `output` - \n\n"]
    pub fn subghz_file_encoder_worker_get_text_progress(
        instance: *mut SubGhzFileEncoderWorker,
        output: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n\nReturns:\n\n* LevelDuration\n\n# Arguments\n\n* `context` - Pointer to a SubGhzFileEncoderWorker instance\n\n"]
    pub fn subghz_file_encoder_worker_get_level_duration(
        context: *mut core::ffi::c_void,
    ) -> LevelDuration;
}
extern "C" {
    #[doc = "Start SubGhzFileEncoderWorker.\n\nReturns:\n\n* bool - true if ok\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n* `file_path` - File path\n* `radio_device_name` - Radio device name\n\n"]
    pub fn subghz_file_encoder_worker_start(
        instance: *mut SubGhzFileEncoderWorker,
        file_path: *const core::ffi::c_char,
        radio_device_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = "Stop SubGhzFileEncoderWorker\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n\n"]
    pub fn subghz_file_encoder_worker_stop(instance: *mut SubGhzFileEncoderWorker);
}
extern "C" {
    #[doc = "Check if worker is running\n\nReturns:\n\n* bool - true if running\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzFileEncoderWorker instance\n\n"]
    pub fn subghz_file_encoder_worker_is_running(instance: *mut SubGhzFileEncoderWorker) -> bool;
}
extern "C" {
    pub static subghz_protocol_registry: SubGhzProtocolRegistry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzSetting {
    _unused: [u8; 0],
}
extern "C" {
    pub fn subghz_setting_alloc() -> *mut SubGhzSetting;
}
extern "C" {
    pub fn subghz_setting_free(instance: *mut SubGhzSetting);
}
extern "C" {
    pub fn subghz_setting_load(instance: *mut SubGhzSetting, file_path: *const core::ffi::c_char);
}
extern "C" {
    pub fn subghz_setting_get_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_count(instance: *mut SubGhzSetting) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_name(
        instance: *mut SubGhzSetting,
        idx: usize,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn subghz_setting_get_inx_preset_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subghz_setting_get_preset_data(instance: *mut SubGhzSetting, idx: usize) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_size(instance: *mut SubGhzSetting, idx: usize) -> usize;
}
extern "C" {
    pub fn subghz_setting_get_preset_data_by_name(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> *mut u8;
}
extern "C" {
    pub fn subghz_setting_load_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
        fff_data_file: *mut FlipperFormat,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_delete_custom_preset(
        instance: *mut SubGhzSetting,
        preset_name: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn subghz_setting_get_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_hopper_frequency(instance: *mut SubGhzSetting, idx: usize) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_frequency_default_index(instance: *mut SubGhzSetting) -> u32;
}
extern "C" {
    pub fn subghz_setting_get_default_frequency(instance: *mut SubGhzSetting) -> u32;
}
extern "C" {
    pub fn subghz_setting_set_default_frequency(
        instance: *mut SubGhzSetting,
        frequency_to_setup: u32,
    );
}
extern "C" {
    pub fn subghz_setting_customs_presets_to_log(instance: *mut SubGhzSetting) -> u8;
}
extern "C" {
    pub fn subghz_devices_init();
}
extern "C" {
    pub fn subghz_devices_deinit();
}
extern "C" {
    pub fn subghz_devices_get_by_name(device_name: *const core::ffi::c_char)
        -> *const SubGhzDevice;
}
extern "C" {
    pub fn subghz_devices_get_name(device: *const SubGhzDevice) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn subghz_devices_begin(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_end(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_is_connect(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_reset(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_sleep(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_idle(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_load_preset(
        device: *const SubGhzDevice,
        preset: FuriHalSubGhzPreset,
        preset_data: *mut u8,
    );
}
extern "C" {
    pub fn subghz_devices_set_frequency(device: *const SubGhzDevice, frequency: u32) -> u32;
}
extern "C" {
    pub fn subghz_devices_is_frequency_valid(device: *const SubGhzDevice, frequency: u32) -> bool;
}
extern "C" {
    pub fn subghz_devices_set_async_mirror_pin(device: *const SubGhzDevice, gpio: *const GpioPin);
}
extern "C" {
    pub fn subghz_devices_get_data_gpio(device: *const SubGhzDevice) -> *const GpioPin;
}
extern "C" {
    pub fn subghz_devices_set_tx(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_flush_tx(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_start_async_tx(
        device: *const SubGhzDevice,
        callback: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    ) -> bool;
}
extern "C" {
    pub fn subghz_devices_is_async_complete_tx(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_stop_async_tx(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_set_rx(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_flush_rx(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_start_async_rx(
        device: *const SubGhzDevice,
        callback: *mut core::ffi::c_void,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn subghz_devices_stop_async_rx(device: *const SubGhzDevice);
}
extern "C" {
    pub fn subghz_devices_get_rssi(device: *const SubGhzDevice) -> f32;
}
extern "C" {
    pub fn subghz_devices_get_lqi(device: *const SubGhzDevice) -> u8;
}
extern "C" {
    pub fn subghz_devices_rx_pipe_not_empty(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_is_rx_data_crc_valid(device: *const SubGhzDevice) -> bool;
}
extern "C" {
    pub fn subghz_devices_read_packet(device: *const SubGhzDevice, data: *mut u8, size: *mut u8);
}
extern "C" {
    pub fn subghz_devices_write_packet(device: *const SubGhzDevice, data: *const u8, size: u8);
}
pub type SubGhzTxRxWorkerCallbackHaveRead =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTxRxWorker {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "SubGhzTxRxWorker, add data to transfer\n\nReturns:\n\n* bool true if ok\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n* `data` - *data\n* `size` - data size\n\n"]
    pub fn subghz_tx_rx_worker_write(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "SubGhzTxRxWorker, get available data\n\nReturns:\n\n* size_t data size\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n\n"]
    pub fn subghz_tx_rx_worker_available(instance: *mut SubGhzTxRxWorker) -> usize;
}
extern "C" {
    #[doc = "SubGhzTxRxWorker, read data\n\nReturns:\n\n* size_t data size, how much is actually read\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n* `data` - *data\n* `size` - max data size, which can be read\n\n"]
    pub fn subghz_tx_rx_worker_read(
        instance: *mut SubGhzTxRxWorker,
        data: *mut u8,
        size: usize,
    ) -> usize;
}
extern "C" {
    #[doc = "Сallback SubGhzTxRxWorker when there is data to read in an empty buffer\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n* `callback` - SubGhzTxRxWorkerCallbackHaveRead callback\n* `context` - \n\n"]
    pub fn subghz_tx_rx_worker_set_callback_have_read(
        instance: *mut SubGhzTxRxWorker,
        callback: SubGhzTxRxWorkerCallbackHaveRead,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Allocate SubGhzTxRxWorker\n\nReturns:\n\n* SubGhzTxRxWorker* Pointer to a SubGhzTxRxWorker instance\n\n"]
    pub fn subghz_tx_rx_worker_alloc() -> *mut SubGhzTxRxWorker;
}
extern "C" {
    #[doc = "Free SubGhzTxRxWorker\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n\n"]
    pub fn subghz_tx_rx_worker_free(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = "Start SubGhzTxRxWorker\n\nReturns:\n\n* bool - true if ok\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n* `device` - Pointer to a SubGhzDevice instance\n\n"]
    pub fn subghz_tx_rx_worker_start(
        instance: *mut SubGhzTxRxWorker,
        device: *const SubGhzDevice,
        frequency: u32,
    ) -> bool;
}
extern "C" {
    #[doc = "Stop SubGhzTxRxWorker\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n\n"]
    pub fn subghz_tx_rx_worker_stop(instance: *mut SubGhzTxRxWorker);
}
extern "C" {
    #[doc = "Check if worker is running\n\nReturns:\n\n* bool - true if running\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTxRxWorker instance\n\n"]
    pub fn subghz_tx_rx_worker_is_running(instance: *mut SubGhzTxRxWorker) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzWorker {
    _unused: [u8; 0],
}
pub type SubGhzWorkerOverrunCallback =
    ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>;
pub type SubGhzWorkerPairCallback = ::core::option::Option<
    unsafe extern "C" fn(context: *mut core::ffi::c_void, level: bool, duration: u32),
>;
extern "C" {
    pub fn subghz_worker_rx_callback(level: bool, duration: u32, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Allocate SubGhzWorker.\n\nReturns:\n\n* SubGhzWorker* Pointer to a SubGhzWorker instance\n\n"]
    pub fn subghz_worker_alloc() -> *mut SubGhzWorker;
}
extern "C" {
    #[doc = "Free SubGhzWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n\n"]
    pub fn subghz_worker_free(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = "Overrun callback SubGhzWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n* `callback` - SubGhzWorkerOverrunCallback callback\n\n"]
    pub fn subghz_worker_set_overrun_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerOverrunCallback,
    );
}
extern "C" {
    #[doc = "Pair callback SubGhzWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n* `callback` - SubGhzWorkerOverrunCallback callback\n\n"]
    pub fn subghz_worker_set_pair_callback(
        instance: *mut SubGhzWorker,
        callback: SubGhzWorkerPairCallback,
    );
}
extern "C" {
    #[doc = "Context callback SubGhzWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n* `context` - \n\n"]
    pub fn subghz_worker_set_context(instance: *mut SubGhzWorker, context: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Start SubGhzWorker.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n\n"]
    pub fn subghz_worker_start(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = "Stop SubGhzWorker\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n\n"]
    pub fn subghz_worker_stop(instance: *mut SubGhzWorker);
}
extern "C" {
    #[doc = "Check if worker is running.\n\nReturns:\n\n* bool - true if running\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n\n"]
    pub fn subghz_worker_is_running(instance: *mut SubGhzWorker) -> bool;
}
extern "C" {
    #[doc = "Short duration filter setting. glues short durations into 1. The default setting is 30 us, if set to 0 the filter will be disabled\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzWorker instance\n* `timeout` - time in us\n\n"]
    pub fn subghz_worker_set_filter(instance: *mut SubGhzWorker, timeout: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SubGhzTransmitter {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate and init SubGhzTransmitter.\n\nReturns:\n\n* SubGhzTransmitter* pointer to a SubGhzTransmitter instance\n\n# Arguments\n\n* `environment` - Pointer to a SubGhzEnvironment instance\n\n"]
    pub fn subghz_transmitter_alloc_init(
        environment: *mut SubGhzEnvironment,
        protocol_name: *const core::ffi::c_char,
    ) -> *mut SubGhzTransmitter;
}
extern "C" {
    #[doc = "Free SubGhzTransmitter.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance\n\n"]
    pub fn subghz_transmitter_free(instance: *mut SubGhzTransmitter);
}
extern "C" {
    #[doc = "Get protocol instance.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance\n\n"]
    pub fn subghz_transmitter_get_protocol_instance(
        instance: *mut SubGhzTransmitter,
    ) -> *mut SubGhzProtocolEncoderBase;
}
extern "C" {
    #[doc = "Forced transmission stop.\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance\n\n"]
    pub fn subghz_transmitter_stop(instance: *mut SubGhzTransmitter) -> bool;
}
extern "C" {
    #[doc = "Deserialize and generating an upload to send.\n\nReturns:\n\n* status\n\n# Arguments\n\n* `instance` - Pointer to a SubGhzTransmitter instance\n* `flipper_format` - Pointer to a FlipperFormat instance\n\n"]
    pub fn subghz_transmitter_deserialize(
        instance: *mut SubGhzTransmitter,
        flipper_format: *mut FlipperFormat,
    ) -> SubGhzProtocolStatus;
}
extern "C" {
    #[doc = "Getting the level and duration of the upload to be loaded into DMA.\n\nReturns:\n\n* LevelDuration\n\n# Arguments\n\n* `context` - Pointer to a SubGhzTransmitter instance\n\n"]
    pub fn subghz_transmitter_yield(context: *mut core::ffi::c_void) -> LevelDuration;
}
extern "C" {
    #[doc = "Extract int value and trim arguments string\n\nReturns:\n\n* true - success\n* false - arguments string does not contain int\n\n# Arguments\n\n* `args` - - arguments string\n* `word` - first argument, output\n\n"]
    pub fn args_read_int_and_trim(args: *mut FuriString, value: *mut core::ffi::c_int) -> bool;
}
extern "C" {
    #[doc = "Extract first argument from arguments string and trim arguments string\n\nReturns:\n\n* true - success\n* false - arguments string does not contain anything\n\n# Arguments\n\n* `args` - arguments string\n* `word` - first argument, output\n\n"]
    pub fn args_read_string_and_trim(args: *mut FuriString, word: *mut FuriString) -> bool;
}
extern "C" {
    #[doc = "Extract the first quoted argument from the argument string and trim the argument string. If the argument is not quoted, calls args_read_string_and_trim.\n\nReturns:\n\n* true - success\n* false - arguments string does not contain anything\n\n# Arguments\n\n* `args` - arguments string\n* `word` - first argument, output, without quotes\n\n"]
    pub fn args_read_probably_quoted_string_and_trim(
        args: *mut FuriString,
        word: *mut FuriString,
    ) -> bool;
}
extern "C" {
    #[doc = "Convert hex ASCII values to byte array\n\nReturns:\n\n* true - success\n* false - arguments string does not contain enough values, or contain non-hex ASCII values\n\n# Arguments\n\n* `args` - arguments string\n* `bytes` - byte array pointer, output\n* `bytes_count` - needed bytes count\n\n"]
    pub fn args_read_hex_bytes(args: *mut FuriString, bytes: *mut u8, bytes_count: usize) -> bool;
}
extern "C" {
    #[doc = "Get length of first word from arguments string\n\nReturns:\n\n* size_t length of first word\n\n# Arguments\n\n* `args` - arguments string\n\n"]
    pub fn args_get_first_word_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = "Get length of arguments string\n\nReturns:\n\n* size_t length of arguments string\n\n# Arguments\n\n* `args` - arguments string\n\n"]
    pub fn args_length(args: *mut FuriString) -> usize;
}
extern "C" {
    #[doc = "Convert ASCII hex values to byte\n\nReturns:\n\n* bool conversion status\n\n# Arguments\n\n* `hi_nibble` - ASCII hi nibble character\n* `low_nibble` - ASCII low nibble character\n* `byte` - byte pointer, output\n\n"]
    pub fn args_char_to_hex(
        hi_nibble: core::ffi::c_char,
        low_nibble: core::ffi::c_char,
        byte: *mut u8,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompressIcon {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Initialize icon compressor\n\nReturns:\n\n* Compress Icon instance\n\n"]
    pub fn compress_icon_alloc() -> *mut CompressIcon;
}
extern "C" {
    #[doc = "Free icon compressor\n\n# Arguments\n\n* `instance` - The Compress Icon instance\n\n"]
    pub fn compress_icon_free(instance: *mut CompressIcon);
}
extern "C" {
    #[doc = "Decompress icon\n\n**Warning!**\n\n* decoded_buff pointer set by this function is valid till next `compress_icon_decode` or `compress_icon_free` call\n\n# Arguments\n\n* `instance` - The Compress Icon instance\n* `icon_data` - pointer to icon data\n* `decoded_buff` - [Direction: In] pointer to decoded buffer pointer\n\n"]
    pub fn compress_icon_decode(
        instance: *mut CompressIcon,
        icon_data: *const u8,
        decoded_buff: *mut *mut u8,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Compress {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Allocate encoder and decoder\n\nReturns:\n\n* Compress instance\n\n# Arguments\n\n* `compress_buff_size` - size of decoder and encoder buffer to allocate\n\n"]
    pub fn compress_alloc(compress_buff_size: u16) -> *mut Compress;
}
extern "C" {
    #[doc = "Free encoder and decoder\n\n# Arguments\n\n* `compress` - Compress instance\n\n"]
    pub fn compress_free(compress: *mut Compress);
}
extern "C" {
    #[doc = "Encode data\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `compress` - Compress instance\n* `data_in` - pointer to input data\n* `data_in_size` - size of input data\n* `data_out` - maximum size of output data\n* `data_res_size` - pointer to result output data size\n\n"]
    pub fn compress_encode(
        compress: *mut Compress,
        data_in: *mut u8,
        data_in_size: usize,
        data_out: *mut u8,
        data_out_size: usize,
        data_res_size: *mut usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decode data\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `compress` - Compress instance\n* `data_in` - pointer to input data\n* `data_in_size` - size of input data\n* `data_out` - maximum size of output data\n* `data_res_size` - pointer to result output data size\n\n"]
    pub fn compress_decode(
        compress: *mut Compress,
        data_in: *mut u8,
        data_in_size: usize,
        data_out: *mut u8,
        data_out_size: usize,
        data_res_size: *mut usize,
    ) -> bool;
}
extern "C" {
    pub fn crc32_calc_buffer(crc: u32, buffer: *const core::ffi::c_void, size: usize) -> u32;
}
pub type FileCrcProgressCb =
    ::core::option::Option<unsafe extern "C" fn(progress: u8, context: *mut core::ffi::c_void)>;
extern "C" {
    pub fn crc32_calc_file(
        file: *mut File,
        progress_cb: FileCrcProgressCb,
        context: *mut core::ffi::c_void,
    ) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirWalk {
    _unused: [u8; 0],
}
#[doc = "OK\n\n"]
pub const DirWalkResult_DirWalkOK: DirWalkResult = 0;
#[doc = "Error\n\n"]
pub const DirWalkResult_DirWalkError: DirWalkResult = 1;
#[doc = "Last element\n\n"]
pub const DirWalkResult_DirWalkLast: DirWalkResult = 2;
pub type DirWalkResult = core::ffi::c_uchar;
pub type DirWalkFilterCb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        fileinfo: *mut FileInfo,
        ctx: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    #[doc = "Allocate DirWalk\n\nReturns:\n\n* DirWalk*\n\n# Arguments\n\n* `storage` - \n\n"]
    pub fn dir_walk_alloc(storage: *mut Storage) -> *mut DirWalk;
}
extern "C" {
    #[doc = "Free DirWalk\n\n# Arguments\n\n* `dir_walk` - \n\n"]
    pub fn dir_walk_free(dir_walk: *mut DirWalk);
}
extern "C" {
    #[doc = "Set recursive mode (true by default)\n\n# Arguments\n\n* `dir_walk` - \n* `recursive` - \n\n"]
    pub fn dir_walk_set_recursive(dir_walk: *mut DirWalk, recursive: bool);
}
extern "C" {
    #[doc = "Set filter callback (Should return true if the data is valid)\n\n# Arguments\n\n* `dir_walk` - \n* `cb` - \n* `context` - \n\n"]
    pub fn dir_walk_set_filter_cb(
        dir_walk: *mut DirWalk,
        cb: DirWalkFilterCb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    #[doc = "Set recurse filtered paths\n\n# Arguments\n\n* `dir_walk` - \n* `array` - \n* `count` - \n\n"]
    pub fn dir_walk_set_recurse_filter(
        dir_walk: *mut DirWalk,
        array: *mut *const core::ffi::c_char,
        count: usize,
    );
}
extern "C" {
    #[doc = "Open directory\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `dir_walk` - \n* `path` - \n\n"]
    pub fn dir_walk_open(dir_walk: *mut DirWalk, path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Get error id\n\nReturns:\n\n* FS_Error\n\n# Arguments\n\n* `dir_walk` - \n\n"]
    pub fn dir_walk_get_error(dir_walk: *mut DirWalk) -> FS_Error;
}
extern "C" {
    #[doc = "Read next element from directory\n\nReturns:\n\n* DirWalkResult\n\n# Arguments\n\n* `dir_walk` - \n* `return_path` - \n* `fileinfo` - \n\n"]
    pub fn dir_walk_read(
        dir_walk: *mut DirWalk,
        return_path: *mut FuriString,
        fileinfo: *mut FileInfo,
    ) -> DirWalkResult;
}
extern "C" {
    #[doc = "Close directory\n\n# Arguments\n\n* `dir_walk` - \n\n"]
    pub fn dir_walk_close(dir_walk: *mut DirWalk);
}
extern "C" {
    #[doc = "Compare two floating point numbers\n\nReturns:\n\n* bool true if a equals b, false otherwise\n\n# Arguments\n\n* `a` - First number to compare\n* `b` - Second number to compare\n\n"]
    pub fn float_is_equal(a: f32, b: f32) -> bool;
}
extern "C" {
    #[doc = "Convert ASCII hex value to nibble\n\nReturns:\n\n* bool conversion status\n\n# Arguments\n\n* `c` - ASCII character\n* `nibble` - nibble pointer, output\n\n"]
    pub fn hex_char_to_hex_nibble(c: core::ffi::c_char, nibble: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert ASCII hex value to byte\n\nReturns:\n\n* bool conversion status\n\n# Arguments\n\n* `hi` - hi nibble text\n* `low` - low nibble text\n* `value` - output value\n\n"]
    pub fn hex_char_to_uint8(hi: core::ffi::c_char, low: core::ffi::c_char, value: *mut u8)
        -> bool;
}
extern "C" {
    #[doc = "Convert ASCII hex values to uint8_t\n\nReturns:\n\n* bool conversion status\n\n# Arguments\n\n* `value_str` - ASCII data\n* `value` - output value\n\n"]
    pub fn hex_chars_to_uint8(value_str: *const core::ffi::c_char, value: *mut u8) -> bool;
}
extern "C" {
    #[doc = "Convert ASCII hex values to uint64_t\n\nReturns:\n\n* bool conversion status\n\n# Arguments\n\n* `value_str` - ASCII 64 bi data\n* `value` - output value\n\n"]
    pub fn hex_chars_to_uint64(value_str: *const core::ffi::c_char, value: *mut u64) -> bool;
}
extern "C" {
    #[doc = "Convert uint8_t to ASCII hex values\n\n# Arguments\n\n* `src` - source data\n* `target` - output value\n* `length` - data length\n\n"]
    pub fn uint8_to_hex_chars(src: *const u8, target: *mut u8, length: core::ffi::c_int);
}
pub const ManchesterEvent_ManchesterEventShortLow: ManchesterEvent = 0;
pub const ManchesterEvent_ManchesterEventShortHigh: ManchesterEvent = 2;
pub const ManchesterEvent_ManchesterEventLongLow: ManchesterEvent = 4;
pub const ManchesterEvent_ManchesterEventLongHigh: ManchesterEvent = 6;
pub const ManchesterEvent_ManchesterEventReset: ManchesterEvent = 8;
pub type ManchesterEvent = core::ffi::c_uchar;
pub const ManchesterState_ManchesterStateStart1: ManchesterState = 0;
pub const ManchesterState_ManchesterStateMid1: ManchesterState = 1;
pub const ManchesterState_ManchesterStateMid0: ManchesterState = 2;
pub const ManchesterState_ManchesterStateStart0: ManchesterState = 3;
pub type ManchesterState = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_advance(
        state: ManchesterState,
        event: ManchesterEvent,
        next_state: *mut ManchesterState,
        data: *mut bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ManchesterEncoderState {
    pub prev_bit: bool,
    pub step: u8,
}
#[test]
fn bindgen_test_layout_ManchesterEncoderState() {
    const UNINIT: ::core::mem::MaybeUninit<ManchesterEncoderState> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ManchesterEncoderState>(),
        2usize,
        concat!("Size of: ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        ::core::mem::align_of::<ManchesterEncoderState>(),
        1usize,
        concat!("Alignment of ", stringify!(ManchesterEncoderState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(prev_bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ManchesterEncoderState),
            "::",
            stringify!(step)
        )
    );
}
pub const ManchesterEncoderResult_ManchesterEncoderResultShortLow: ManchesterEncoderResult = 0;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongLow: ManchesterEncoderResult = 1;
pub const ManchesterEncoderResult_ManchesterEncoderResultLongHigh: ManchesterEncoderResult = 2;
pub const ManchesterEncoderResult_ManchesterEncoderResultShortHigh: ManchesterEncoderResult = 3;
pub type ManchesterEncoderResult = core::ffi::c_uchar;
extern "C" {
    pub fn manchester_encoder_reset(state: *mut ManchesterEncoderState);
}
extern "C" {
    pub fn manchester_encoder_advance(
        state: *mut ManchesterEncoderState,
        curr_bit: bool,
        result: *mut ManchesterEncoderResult,
    ) -> bool;
}
extern "C" {
    pub fn manchester_encoder_finish(state: *mut ManchesterEncoderState)
        -> ManchesterEncoderResult;
}
#[doc = "MD5 context structure\n\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct md5_context {
    #[doc = "number of bytes processed\n\n"]
    pub total: [u32; 2usize],
    #[doc = "intermediate digest state\n\n"]
    pub state: [u32; 4usize],
    #[doc = "data block being processed\n\n"]
    pub buffer: [core::ffi::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    const UNINIT: ::core::mem::MaybeUninit<md5_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = "MD5 context setup\n\n# Arguments\n\n* `ctx` - context to be initialized\n\n"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[doc = "MD5 process buffer\n\n# Arguments\n\n* `ctx` - MD5 context\n* `input` - buffer holding the data\n* `ilen` - length of the input data\n\n"]
    pub fn md5_update(ctx: *mut md5_context, input: *const core::ffi::c_uchar, ilen: usize);
}
extern "C" {
    #[doc = "MD5 final digest\n\n# Arguments\n\n* `ctx` - MD5 context\n* `output` - MD5 checksum result\n\n"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn md5_process(ctx: *mut md5_context, data: *const core::ffi::c_uchar);
}
extern "C" {
    #[doc = "Output = MD5( input buffer )\n\n# Arguments\n\n* `input` - buffer holding the data\n* `ilen` - length of the input data\n* `output` - MD5 checksum result\n\n"]
    pub fn md5(input: *const core::ffi::c_uchar, ilen: usize, output: *mut core::ffi::c_uchar);
}
extern "C" {
    #[doc = "Generates detailed/random name based on furi_hal flags\n\n# Arguments\n\n* `name` - buffer to write random name\n* `max_name_size` - length of given buffer\n* `prefix` - [Direction: In] The prefix of the name\n\n"]
    pub fn name_generator_make_auto(
        name: *mut core::ffi::c_char,
        max_name_size: usize,
        prefix: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Generates random name\n\n# Arguments\n\n* `name` - buffer to write random name\n* `max_name_size` - length of given buffer\n* `prefix` - [Direction: In] The prefix of the name\n\n"]
    pub fn name_generator_make_random(name: *mut core::ffi::c_char, max_name_size: usize);
}
extern "C" {
    pub fn name_generator_make_random_prefixed(
        name: *mut core::ffi::c_char,
        max_name_size: usize,
        prefix: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Generates detailed name\n\n# Arguments\n\n* `name` - buffer to write random name\n* `max_name_size` - length of given buffer\n* `prefix` - [Direction: In] The prefix of the name\n\n"]
    pub fn name_generator_make_detailed(
        name: *mut core::ffi::c_char,
        max_name_size: usize,
        prefix: *const core::ffi::c_char,
    );
}
extern "C" {
    #[doc = "Extract filename without extension from path.\n\n# Arguments\n\n* `path` - path string\n* `filename` - output filename string. Must be initialized before.\n\n"]
    pub fn path_extract_filename_no_ext(path: *const core::ffi::c_char, filename: *mut FuriString);
}
extern "C" {
    #[doc = "Extract filename string from path.\n\n# Arguments\n\n* `path` - path string\n* `filename` - output filename string. Must be initialized before.\n* `trim_ext` - true - get filename without extension\n\n"]
    pub fn path_extract_filename(path: *mut FuriString, filename: *mut FuriString, trim_ext: bool);
}
extern "C" {
    #[doc = "Extract file extension string from path.\n\n# Arguments\n\n* `path` - path string\n* `ext` - output extension furi string\n\n"]
    pub fn path_extract_ext_str(path: *mut FuriString, ext: *mut FuriString);
}
extern "C" {
    #[doc = "Extract file extension from path.\n\n# Arguments\n\n* `path` - path string\n* `ext` - output extension string\n* `ext_len_max` - maximum extension string length\n\n"]
    pub fn path_extract_extension(
        path: *mut FuriString,
        ext: *mut core::ffi::c_char,
        ext_len_max: usize,
    );
}
extern "C" {
    #[doc = "Extract last path component\n\n# Arguments\n\n* `path` - path string\n* `filename` - output string. Must be initialized before.\n\n"]
    pub fn path_extract_basename(path: *const core::ffi::c_char, basename: *mut FuriString);
}
extern "C" {
    #[doc = "Extract path, except for last component\n\n# Arguments\n\n* `path` - path string\n* `filename` - output string. Must be initialized before.\n\n"]
    pub fn path_extract_dirname(path: *const core::ffi::c_char, dirname: *mut FuriString);
}
extern "C" {
    #[doc = "Appends new component to path, adding path delimiter\n\n# Arguments\n\n* `path` - path string\n* `suffix` - path part to apply\n\n"]
    pub fn path_append(path: *mut FuriString, suffix: *const core::ffi::c_char);
}
extern "C" {
    #[doc = "Appends new component to path, adding path delimiter\n\n# Arguments\n\n* `path` - first path part\n* `suffix` - second path part\n* `out_path` - output string to combine parts into. Must be initialized\n\n"]
    pub fn path_concat(
        path: *const core::ffi::c_char,
        suffix: *const core::ffi::c_char,
        out_path: *mut FuriString,
    );
}
extern "C" {
    #[doc = "Check that path contains only ascii characters\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `path` - \n\n"]
    pub fn path_contains_only_ascii(path: *const core::ffi::c_char) -> bool;
}
extern "C" {
    #[doc = "Format a data buffer as a canonical HEX dump\n\n# Arguments\n\n* `[out]` - result pointer to the output string (must be initialised)\n* `[in]` - num_places the number of bytes on one line (both as HEX and ASCII)\n* `[in]` - line_prefix if not NULL, prepend this string to each line\n* `[in]` - data pointer to the input data buffer\n* `[in]` - data_size input data size\n\n"]
    pub fn pretty_format_bytes_hex_canonical(
        result: *mut FuriString,
        num_places: usize,
        line_prefix: *const core::ffi::c_char,
        data: *const u8,
        data_size: usize,
    );
}
extern "C" {
    pub fn saved_struct_load(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    pub fn saved_struct_save(
        path: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        size: usize,
        magic: u8,
        version: u8,
    ) -> bool;
}
extern "C" {
    pub fn saved_struct_get_payload_size(
        path: *const core::ffi::c_char,
        magic: u8,
        version: u8,
        payload_size: *mut usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sha256_context {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub wbuf: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_sha256_context() {
    const UNINIT: ::core::mem::MaybeUninit<sha256_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        104usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wbuf) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(wbuf)
        )
    );
}
extern "C" {
    pub fn sha256(
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
        output: *mut core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn sha256_start(ctx: *mut sha256_context);
}
extern "C" {
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn sha256_update(
        ctx: *mut sha256_context,
        input: *const core::ffi::c_uchar,
        ilen: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sha256_process(ctx: *mut sha256_context);
}
extern "C" {
    #[doc = "Allocate a file stream with buffered read operations\n\nReturns:\n\n* Stream*\n\n"]
    pub fn buffered_file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = "Opens an existing file or creates a new one.\n\nReturns:\n\n* True on success, False on failure. You need to close the file even if the open operation failed.\n\n# Arguments\n\n* `stream` - pointer to file stream object.\n* `path` - path to file\n* `access_mode` - access mode from FS_AccessMode\n* `open_mode` - open mode from FS_OpenMode\n\n"]
    pub fn buffered_file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = "Closes the file.\n\nReturns:\n\n* True on success, False on failure.\n\n# Arguments\n\n* `stream` - pointer to file stream object.\n\n"]
    pub fn buffered_file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = "Forces write from cache to the underlying file.\n\nReturns:\n\n* True on success, False on failure.\n\n# Arguments\n\n* `stream` - pointer to file stream object.\n\n"]
    pub fn buffered_file_stream_sync(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = "Retrieves the error id from the file object\n\nReturns:\n\n* FS_Error error id\n\n# Arguments\n\n* `stream` - pointer to stream object.\n\n"]
    pub fn buffered_file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
    #[doc = "Allocate file stream\n\nReturns:\n\n* Stream*\n\n"]
    pub fn file_stream_alloc(storage: *mut Storage) -> *mut Stream;
}
extern "C" {
    #[doc = "Opens an existing file or create a new one.\n\nReturns:\n\n* success flag. You need to close the file even if the open operation failed.\n\n# Arguments\n\n* `stream` - pointer to file stream object.\n* `path` - path to file\n* `access_mode` - access mode from FS_AccessMode\n* `open_mode` - open mode from FS_OpenMode\n\n"]
    pub fn file_stream_open(
        stream: *mut Stream,
        path: *const core::ffi::c_char,
        access_mode: FS_AccessMode,
        open_mode: FS_OpenMode,
    ) -> bool;
}
extern "C" {
    #[doc = "Closes the file.\n\nReturns:\n\n* true\n* false\n\n# Arguments\n\n* `stream` - \n\n"]
    pub fn file_stream_close(stream: *mut Stream) -> bool;
}
extern "C" {
    #[doc = "Retrieves the error id from the file object\n\nReturns:\n\n* FS_Error error id\n\n# Arguments\n\n* `stream` - pointer to stream object.\n\n"]
    pub fn file_stream_get_error(stream: *mut Stream) -> FS_Error;
}
extern "C" {
    #[doc = "Allocate string stream\n\nReturns:\n\n* Stream*\n\n"]
    pub fn string_stream_alloc() -> *mut Stream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TarArchive {
    _unused: [u8; 0],
}
pub const TarOpenMode_TAR_OPEN_MODE_READ: TarOpenMode = 114;
pub const TarOpenMode_TAR_OPEN_MODE_WRITE: TarOpenMode = 119;
pub const TarOpenMode_TAR_OPEN_MODE_STDOUT: TarOpenMode = 115;
pub type TarOpenMode = core::ffi::c_uchar;
extern "C" {
    pub fn tar_archive_alloc(storage: *mut Storage) -> *mut TarArchive;
}
extern "C" {
    pub fn tar_archive_open(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        mode: TarOpenMode,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_free(archive: *mut TarArchive);
}
extern "C" {
    pub fn tar_archive_unpack_to(
        archive: *mut TarArchive,
        destination: *const core::ffi::c_char,
        converter: Storage_name_converter,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_file(
        archive: *mut TarArchive,
        fs_file_path: *const core::ffi::c_char,
        archive_fname: *const core::ffi::c_char,
        file_size: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_add_dir(
        archive: *mut TarArchive,
        fs_full_path: *const core::ffi::c_char,
        path_prefix: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_get_entries_count(archive: *mut TarArchive) -> i32;
}
extern "C" {
    pub fn tar_archive_unpack_file(
        archive: *mut TarArchive,
        archive_fname: *const core::ffi::c_char,
        destination: *const core::ffi::c_char,
    ) -> bool;
}
pub type tar_unpack_file_cb = ::core::option::Option<
    unsafe extern "C" fn(
        name: *const core::ffi::c_char,
        is_directory: bool,
        context: *mut core::ffi::c_void,
    ) -> bool,
>;
extern "C" {
    pub fn tar_archive_set_file_callback(
        archive: *mut TarArchive,
        callback: tar_unpack_file_cb,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn tar_archive_dir_add_element(
        archive: *mut TarArchive,
        dirpath: *const core::ffi::c_char,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_header(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_add_data_block(
        archive: *mut TarArchive,
        data_block: *const u8,
        block_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_file_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
    pub fn tar_archive_store_data(
        archive: *mut TarArchive,
        path: *const core::ffi::c_char,
        data: *const u8,
        data_len: i32,
    ) -> bool;
}
extern "C" {
    pub fn tar_archive_finalize(archive: *mut TarArchive) -> bool;
}
extern "C" {
    #[doc = "Get the index of a int32_t array element which is closest to the given value.\nReturned index corresponds to the first element found. If no suitable elements were found, the function returns 0.\n\nReturns:\n\n* value's index.\n\n# Arguments\n\n* `value` - value to be searched.\n* `values` - pointer to the array to perform the search in.\n* `values_count` - array size.\n\n"]
    pub fn value_index_int32(value: i32, values: *const i32, values_count: u8) -> u8;
}
extern "C" {
    #[doc = "Get the index of a uint32_t array element which is closest to the given value.\nReturned index corresponds to the first element found. If no suitable elements were found, the function returns 0.\n\nReturns:\n\n* value's index.\n\n# Arguments\n\n* `value` - value to be searched.\n* `values` - pointer to the array to perform the search in.\n* `values_count` - array size.\n\n"]
    pub fn value_index_uint32(value: u32, values: *const u32, values_count: u8) -> u8;
}
extern "C" {
    #[doc = "Get the index of a float array element which is closest to the given value.\nReturned index corresponds to the first element found. If no suitable elements were found, the function returns 0.\n\nReturns:\n\n* value's index.\n\n# Arguments\n\n* `value` - value to be searched.\n* `values` - pointer to the array to perform the search in.\n* `values_count` - array size.\n\n"]
    pub fn value_index_float(value: f32, values: *const f32, values_count: u8) -> u8;
}
extern "C" {
    #[doc = "Get the index of a bool array element which is equal to the given value.\nReturned index corresponds to the first element found. If no suitable elements were found, the function returns 0.\n\nReturns:\n\n* value's index.\n\n# Arguments\n\n* `value` - value to be searched.\n* `values` - pointer to the array to perform the search in.\n* `values_count` - array size.\n\n"]
    pub fn value_index_bool(value: bool, values: *const bool, values_count: u8) -> u8;
}
pub const BatteryIcon_BatteryIconOff: BatteryIcon = 0;
pub const BatteryIcon_BatteryIconBar: BatteryIcon = 1;
pub const BatteryIcon_BatteryIconPercent: BatteryIcon = 2;
pub const BatteryIcon_BatteryIconInvertedPercent: BatteryIcon = 3;
pub const BatteryIcon_BatteryIconRetro3: BatteryIcon = 4;
pub const BatteryIcon_BatteryIconRetro5: BatteryIcon = 5;
pub const BatteryIcon_BatteryIconBarPercent: BatteryIcon = 6;
pub const BatteryIcon_BatteryIconCount: BatteryIcon = 7;
pub type BatteryIcon = core::ffi::c_uchar;
pub const MenuStyle_MenuStyleList: MenuStyle = 0;
pub const MenuStyle_MenuStyleWii: MenuStyle = 1;
pub const MenuStyle_MenuStyleDsi: MenuStyle = 2;
pub const MenuStyle_MenuStylePs4: MenuStyle = 3;
pub const MenuStyle_MenuStyleVertical: MenuStyle = 4;
pub const MenuStyle_MenuStyleC64: MenuStyle = 5;
pub const MenuStyle_MenuStyleEurocorp: MenuStyle = 6;
pub const MenuStyle_MenuStyleCompact: MenuStyle = 7;
pub const MenuStyle_MenuStyleTerminal: MenuStyle = 8;
pub const MenuStyle_MenuStyleCount: MenuStyle = 9;
pub type MenuStyle = core::ffi::c_uchar;
pub const SpiHandle_SpiDefault: SpiHandle = 0;
pub const SpiHandle_SpiExtra: SpiHandle = 1;
pub const SpiHandle_SpiCount: SpiHandle = 2;
pub type SpiHandle = core::ffi::c_uchar;
pub const UARTChannel_UARTDefault: UARTChannel = 0;
pub const UARTChannel_UARTExtra: UARTChannel = 1;
pub const UARTChannel_UARTCount: UARTChannel = 2;
pub type UARTChannel = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XtremeSettings {
    pub is_nsfw: bool,
    pub asset_pack: [core::ffi::c_char; 32usize],
    pub anim_speed: u32,
    pub cycle_anims: i32,
    pub unlock_anims: bool,
    pub fallback_anim: bool,
    pub menu_style: MenuStyle,
    pub lock_on_boot: bool,
    pub bad_pins_format: bool,
    pub allow_locked_rpc_commands: bool,
    pub lockscreen_time: bool,
    pub lockscreen_seconds: bool,
    pub lockscreen_date: bool,
    pub lockscreen_statusbar: bool,
    pub lockscreen_prompt: bool,
    pub lockscreen_transparent: bool,
    pub battery_icon: BatteryIcon,
    pub statusbar_clock: bool,
    pub status_icons: bool,
    pub bar_borders: bool,
    pub bar_background: bool,
    pub sort_dirs_first: bool,
    pub show_hidden_files: bool,
    pub show_internal_tab: bool,
    pub favorite_timeout: u32,
    pub bad_bt: bool,
    pub bad_bt_remember: bool,
    pub dark_mode: bool,
    pub rgb_backlight: bool,
    pub butthurt_timer: u32,
    pub charge_cap: u32,
    pub spi_cc1101_handle: SpiHandle,
    pub spi_nrf24_handle: SpiHandle,
    pub uart_esp_channel: UARTChannel,
    pub uart_nmea_channel: UARTChannel,
    pub uart_general_channel: UARTChannel,
}
#[test]
fn bindgen_test_layout_XtremeSettings() {
    const UNINIT: ::core::mem::MaybeUninit<XtremeSettings> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XtremeSettings>(),
        88usize,
        concat!("Size of: ", stringify!(XtremeSettings))
    );
    assert_eq!(
        ::core::mem::align_of::<XtremeSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(XtremeSettings))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_nsfw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(is_nsfw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asset_pack) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(asset_pack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).anim_speed) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(anim_speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cycle_anims) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(cycle_anims)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unlock_anims) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(unlock_anims)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fallback_anim) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(fallback_anim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menu_style) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(menu_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_on_boot) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lock_on_boot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bad_pins_format) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(bad_pins_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allow_locked_rpc_commands) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(allow_locked_rpc_commands)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_time) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_seconds) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_seconds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_date) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_statusbar) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_statusbar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_prompt) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_prompt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lockscreen_transparent) as usize - ptr as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(lockscreen_transparent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).battery_icon) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(battery_icon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statusbar_clock) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(statusbar_clock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status_icons) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(status_icons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bar_borders) as usize - ptr as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(bar_borders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bar_background) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(bar_background)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sort_dirs_first) as usize - ptr as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(sort_dirs_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).show_hidden_files) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(show_hidden_files)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).show_internal_tab) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(show_internal_tab)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).favorite_timeout) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(favorite_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bad_bt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(bad_bt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bad_bt_remember) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(bad_bt_remember)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dark_mode) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(dark_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rgb_backlight) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(rgb_backlight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).butthurt_timer) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(butthurt_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charge_cap) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(charge_cap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_cc1101_handle) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(spi_cc1101_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi_nrf24_handle) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(spi_nrf24_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uart_esp_channel) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(uart_esp_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uart_nmea_channel) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(uart_nmea_channel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uart_general_channel) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XtremeSettings),
            "::",
            stringify!(uart_general_channel)
        )
    );
}
extern "C" {
    pub fn XTREME_SETTINGS_SAVE();
}
extern "C" {
    pub static mut xtreme_settings: XtremeSettings;
}
extern "C" {
    pub fn XTREME_ASSETS_LOAD();
}
extern "C" {
    pub fn XTREME_ASSETS_FREE();
}
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdTim1PA7: FuriHalPwmOutputId = 0;
pub const FuriHalPwmOutputId_FuriHalPwmOutputIdLptim2PA4: FuriHalPwmOutputId = 1;
pub type FuriHalPwmOutputId = core::ffi::c_uchar;
extern "C" {
    #[doc = "Enable PWM channel and set parameters\n\n# Arguments\n\n* `channel` - [Direction: In] PWM channel (FuriHalPwmOutputId)\n* `freq` - [Direction: In] Frequency in Hz\n* `duty` - [Direction: In] Duty cycle value in %\n\n"]
    pub fn furi_hal_pwm_start(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
    #[doc = "Disable PWM channel\n\n# Arguments\n\n* `channel` - [Direction: In] PWM channel (FuriHalPwmOutputId)\n\n"]
    pub fn furi_hal_pwm_stop(channel: FuriHalPwmOutputId);
}
extern "C" {
    #[doc = "Set PWM channel parameters\n\n# Arguments\n\n* `channel` - [Direction: In] PWM channel (FuriHalPwmOutputId)\n* `freq` - [Direction: In] Frequency in Hz\n* `duty` - [Direction: In] Duty cycle value in %\n\n"]
    pub fn furi_hal_pwm_set_params(channel: FuriHalPwmOutputId, freq: u32, duty: u8);
}
extern "C" {
    #[doc = "Is PWM channel running?\n\nReturns:\n\n* bool - true if running\n\n# Arguments\n\n* `channel` - [Direction: In] PWM channel (FuriHalPwmOutputId)\n\n"]
    pub fn furi_hal_pwm_is_running(channel: FuriHalPwmOutputId) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CdcCallbacks {
    pub tx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub rx_ep_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void)>,
    pub state_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub ctrl_line_callback:
        ::core::option::Option<unsafe extern "C" fn(context: *mut core::ffi::c_void, state: u8)>,
    pub config_callback: ::core::option::Option<
        unsafe extern "C" fn(context: *mut core::ffi::c_void, config: *mut usb_cdc_line_coding),
    >,
}
#[test]
fn bindgen_test_layout_CdcCallbacks() {
    const UNINIT: ::core::mem::MaybeUninit<CdcCallbacks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CdcCallbacks>(),
        20usize,
        concat!("Size of: ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        ::core::mem::align_of::<CdcCallbacks>(),
        4usize,
        concat!("Alignment of ", stringify!(CdcCallbacks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_ep_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(tx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_ep_callback) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(rx_ep_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(state_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl_line_callback) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(ctrl_line_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CdcCallbacks),
            "::",
            stringify!(config_callback)
        )
    );
}
extern "C" {
    pub fn furi_hal_cdc_set_callbacks(
        if_num: u8,
        cb: *mut CdcCallbacks,
        context: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn furi_hal_cdc_get_port_settings(if_num: u8) -> *mut usb_cdc_line_coding;
}
extern "C" {
    pub fn furi_hal_cdc_get_ctrl_line_state(if_num: u8) -> u8;
}
extern "C" {
    pub fn furi_hal_cdc_send(if_num: u8, buf: *mut u8, len: u16);
}
extern "C" {
    pub fn furi_hal_cdc_receive(if_num: u8, buf: *mut u8, max_len: u16) -> i32;
}
extern "C" {
    pub fn __errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn __clear_cache(arg1: *mut core::ffi::c_void, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __aeabi_uldivmod(arg1: u64, arg2: u64) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Start Hid Keyboard Profile\n\n"]
    pub fn furi_hal_bt_hid_start();
}
extern "C" {
    #[doc = "Stop Hid Keyboard Profile\n\n"]
    pub fn furi_hal_bt_hid_stop();
}
extern "C" {
    #[doc = "Press keyboard button\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `button` - button code from HID specification\n\n"]
    pub fn furi_hal_bt_hid_kb_press(button: u16) -> bool;
}
extern "C" {
    #[doc = "Release keyboard button\n\nReturns:\n\n* true on success\n\n# Arguments\n\n* `button` - button code from HID specification\n\n"]
    pub fn furi_hal_bt_hid_kb_release(button: u16) -> bool;
}
extern "C" {
    #[doc = "Release all keyboard buttons\n\nReturns:\n\n* true on success\n\n"]
    pub fn furi_hal_bt_hid_kb_release_all() -> bool;
}
extern "C" {
    #[doc = "Set mouse movement and send HID report\n\n# Arguments\n\n* `dx` - x coordinate delta\n* `dy` - y coordinate delta\n\n"]
    pub fn furi_hal_bt_hid_mouse_move(dx: i8, dy: i8) -> bool;
}
extern "C" {
    #[doc = "Set mouse button to pressed state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_mouse_press(button: u8) -> bool;
}
extern "C" {
    #[doc = "Set mouse button to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_mouse_release(button: u8) -> bool;
}
extern "C" {
    #[doc = "Set mouse button to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_mouse_release_all() -> bool;
}
extern "C" {
    #[doc = "Set mouse wheel position and send HID report\n\n# Arguments\n\n* `delta` - number of scroll steps\n\n"]
    pub fn furi_hal_bt_hid_mouse_scroll(delta: i8) -> bool;
}
extern "C" {
    #[doc = "Set the following consumer key to pressed state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_consumer_key_press(button: u16) -> bool;
}
extern "C" {
    #[doc = "Set the following consumer key to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_consumer_key_release(button: u16) -> bool;
}
extern "C" {
    #[doc = "Set consumer key to released state and send HID report\n\n# Arguments\n\n* `button` - key code\n\n"]
    pub fn furi_hal_bt_hid_consumer_key_release_all() -> bool;
}
extern "C" {
    #[doc = "Retrieves LED state from remote BT HID host\n\nReturns:\n\n* (look at HID usage page to know what each bit of the returned byte means) NB: RFU bit has been shifted out in the returned octet so USB defines should work\n\n"]
    pub fn furi_hal_bt_hid_get_led_state() -> u8;
}
extern "C" {
    #[doc = "Init memory pool manager\n\n"]
    pub fn furi_hal_memory_init();
}
extern "C" {
    #[doc = "Allocate memory from separate memory pool. That memory can't be freed.\n\nReturns:\n\n* void*\n\n# Arguments\n\n* `size` - \n\n"]
    pub fn furi_hal_memory_alloc(size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = "Get free memory pool size\n\nReturns:\n\n* size_t\n\n"]
    pub fn furi_hal_memory_get_free() -> usize;
}
extern "C" {
    #[doc = "Get max free block size from memory pool\n\nReturns:\n\n* size_t\n\n"]
    pub fn furi_hal_memory_max_pool_block() -> usize;
}
pub const FuriHalMpuRegion_FuriHalMpuRegionNULL: FuriHalMpuRegion = 0;
pub const FuriHalMpuRegion_FuriHalMpuRegionStack: FuriHalMpuRegion = 1;
pub const FuriHalMpuRegion_FuriHalMpuRegion2: FuriHalMpuRegion = 2;
pub const FuriHalMpuRegion_FuriHalMpuRegion3: FuriHalMpuRegion = 3;
pub const FuriHalMpuRegion_FuriHalMpuRegion4: FuriHalMpuRegion = 4;
pub const FuriHalMpuRegion_FuriHalMpuRegion5: FuriHalMpuRegion = 5;
pub const FuriHalMpuRegion_FuriHalMpuRegion6: FuriHalMpuRegion = 6;
pub const FuriHalMpuRegion_FuriHalMpuRegion7: FuriHalMpuRegion = 7;
pub type FuriHalMpuRegion = core::ffi::c_uchar;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32B: FuriHalMPURegionSize = 4;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64B: FuriHalMPURegionSize = 5;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128B: FuriHalMPURegionSize = 6;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256B: FuriHalMPURegionSize = 7;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512B: FuriHalMPURegionSize = 8;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1KB: FuriHalMPURegionSize = 9;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2KB: FuriHalMPURegionSize = 10;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4KB: FuriHalMPURegionSize = 11;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8KB: FuriHalMPURegionSize = 12;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16KB: FuriHalMPURegionSize = 13;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32KB: FuriHalMPURegionSize = 14;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64KB: FuriHalMPURegionSize = 15;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128KB: FuriHalMPURegionSize = 16;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256KB: FuriHalMPURegionSize = 17;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512KB: FuriHalMPURegionSize = 18;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1MB: FuriHalMPURegionSize = 19;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2MB: FuriHalMPURegionSize = 20;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4MB: FuriHalMPURegionSize = 21;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize8MB: FuriHalMPURegionSize = 22;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize16MB: FuriHalMPURegionSize = 23;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize32MB: FuriHalMPURegionSize = 24;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize64MB: FuriHalMPURegionSize = 25;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize128MB: FuriHalMPURegionSize = 26;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize256MB: FuriHalMPURegionSize = 27;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize512MB: FuriHalMPURegionSize = 28;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize1GB: FuriHalMPURegionSize = 29;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize2GB: FuriHalMPURegionSize = 30;
pub const FuriHalMPURegionSize_FuriHalMPURegionSize4GB: FuriHalMPURegionSize = 31;
pub type FuriHalMPURegionSize = core::ffi::c_uchar;
extern "C" {
    #[doc = "Enable memory protection unit\n\n"]
    pub fn furi_hal_mpu_enable();
}
extern "C" {
    #[doc = "Disable memory protection unit\n\n"]
    pub fn furi_hal_mpu_disable();
}
extern "C" {
    pub fn furi_hal_mpu_protect_no_access(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_read_only(
        region: FuriHalMpuRegion,
        address: u32,
        size: FuriHalMPURegionSize,
    );
}
extern "C" {
    pub fn furi_hal_mpu_protect_disable(region: FuriHalMpuRegion);
}
pub const HidU2fEvent_HidU2fDisconnected: HidU2fEvent = 0;
pub const HidU2fEvent_HidU2fConnected: HidU2fEvent = 1;
pub const HidU2fEvent_HidU2fRequest: HidU2fEvent = 2;
pub type HidU2fEvent = core::ffi::c_uchar;
pub type HidU2fCallback =
    ::core::option::Option<unsafe extern "C" fn(ev: HidU2fEvent, context: *mut core::ffi::c_void)>;
extern "C" {
    #[doc = "Get HID U2F connection state\n\nReturns:\n\n* true / false\n\n"]
    pub fn furi_hal_hid_u2f_is_connected() -> bool;
}
extern "C" {
    #[doc = "Set HID U2F event callback\n\n# Arguments\n\n* `cb` - callback\n* `ctx` - callback context\n\n"]
    pub fn furi_hal_hid_u2f_set_callback(cb: HidU2fCallback, ctx: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = "Get received U2F HID packet\n\n"]
    pub fn furi_hal_hid_u2f_get_request(data: *mut u8) -> u32;
}
extern "C" {
    #[doc = "Send U2F HID response packet\n\n# Arguments\n\n* `data` - response data\n* `len` - packet length\n\n"]
    pub fn furi_hal_hid_u2f_send_response(data: *mut u8, len: u8);
}
